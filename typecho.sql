-- MySQL dump 10.13  Distrib 5.5.46, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: typecho
-- ------------------------------------------------------
-- Server version	5.5.46-0ubuntu0.14.04.2

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `typecho_comments`
--

DROP TABLE IF EXISTS `typecho_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_comments`
--

LOCK TABLES `typecho_comments` WRITE;
/*!40000 ALTER TABLE `typecho_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_contents`
--

DROP TABLE IF EXISTS `typecho_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` text,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=335 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_contents`
--

LOCK TABLES `typecho_contents` WRITE;
/*!40000 ALTER TABLE `typecho_contents` DISABLE KEYS */;
INSERT INTO `typecho_contents` VALUES (9,'序','9',1461172860,1461175573,'<!--markdown-->.喜欢创造不喜拘束\r\n.狂乱追逐不懂眷顾\r\n.再美不因你而驻足\r\n.不为谁去停止脚步\r\n.至始至终义无反顾\r\n.哪怕伤的体无完肤\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(8,'About Me','link',1461171900,1461171976,'<!--markdown-->',5,1,'page-link.php','page','publish',NULL,0,'1','1','1',0),(3,'分类','categories',1461171606,1461171606,'<!--markdown-->',3,1,'page-categories.php','page','publish',NULL,0,'1','1','1',0),(5,'归档','archive',1461171719,1461171719,'<!--markdown-->',4,1,'page-archive.php','page','publish',NULL,0,'1','1','1',0),(7,'标签','tags',1461171840,1461172022,'<!--markdown-->',4,1,'page-tags.php','page','publish',NULL,0,'1','1','1',0),(12,'假面','12',1461379288,1461385893,'<!--markdown-->.总有一天你会和我遇见\r\n.像好友一样却失散多年\r\n.你一句我一句单纯聊天\r\n.说你过得还不错在以前\r\n.靓丽光鲜印在了我眼睑\r\n.讲我的过往传到你耳边\r\n.装作自己和你一样体面\r\n.各有各心思我们谈话间\r\n.撕下吧莫于虚有的假面\r\n.毫无伪装我们坦诚相见\r\n.会发现这样却更加新鲜',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(13,'伪装','@13',1461379260,1461386037,'<!--markdown-->.总有一天你会和我遇见\r\n.像好友一样却失散多年\r\n.你一句我一句单纯聊天\r\n.说你过得还不错在以前\r\n.靓丽光鲜印在了我眼睑\r\n.讲我的过往传到你耳边\r\n.装作自己和你一样体面\r\n.各有各心思我们谈话间\r\n.撕下吧莫于虚有的假面\r\n.毫无伪装我们坦诚相见\r\n.会发现这样却更加新鲜',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',12),(14,'php 注释 大小写敏感','14',1468576260,1479290374,'<!--markdown-->**php脚本注释**\r\n```\r\n<?php \r\necho \"\";\r\n//  单行注释\r\n#   单行注释\r\n/*\r\n这里是多行注释\r\n它横跨了\r\n多行\r\n*/\r\n?>\r\n\r\n```\r\n **php大小写敏感**\r\n在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。\r\n\r\n在下面的例子中，所有这三天 echo 语句都是合法的（等价）：\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<?php\r\nECHO \"Hello World!<br>\";\r\necho \"Hello World!<br>\";\r\nEcHo \"Hello World!<br>\";\r\n?>\r\n\r\n</body>\r\n</html>\r\n结果\r\nHello World!\r\nHello World!\r\nHello World!\r\n```\r\n\r\nPHP 中，所有变量都对大小写敏感。\r\n\r\n在下面的例子中，只有第一条语句会显示 $color 变量的值（这是因为 $color、$COLOR 以及 $coLOR 被视作三个不同的变量）：\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<?php\r\n$color=\"red\";\r\necho \"My car is \" . $color . \"<br>\";\r\necho \"My house is \" . $COLOR . \"<br>\";\r\necho \"My boat is \" . $coLOR . \"<br>\";\r\n?>\r\n\r\n</body>\r\n</html>\r\n结果\r\nMy car is red\r\nMy house is\r\nMy boat is \r\n```',0,1,NULL,'post','hidden',NULL,0,'1','1','1',0),(16,'php 变量','16',1468577580,1479290367,'<!--markdown-->**变量是存储信息的容器；**\r\n```\r\n<?php\r\n$x=5;\r\n$y=6;\r\n$z=$x+$y;\r\necho $z;\r\n?>\r\n11\r\n```\r\n**变量规则：**\r\n1.变量以$符号开头，其后是变量的名称\r\n2.变量名称必须以字母或下划线开头\r\n3.变量名称不能以数字开头\r\n4.变量名称只能包含字母，数字，字符和下划线(A-z.0-9以及_)可以是中文 $中文=1； echo $中文；\r\n5.变量名称对大小写敏感($y , $Y 是两个不同的变量)\r\n\r\n**注释：PHP 变量名称对大小写敏感！**\r\n\r\n**创建php变量**\r\nphp没有创建变量的命令。\r\n变量会在首次为其赋值时被创建；\r\n\r\n**PHP 变量作用域**\r\nPHP 有三种不同的变量作用域：\r\n\r\n    local（局部）\r\n    global（全局）\r\n    static（静态）\r\n\r\n**Local 和 Global 作用域**\r\n\r\n函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。\r\n\r\n函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。\r\n\r\n\r\n**PHP global 关键词**\r\n\r\nglobal 关键词用于访问函数内的全局变量。\r\n\r\n要做到这一点，请在（函数内部）变量前面使用 global 关键词：\r\n```\r\n<?php\r\n$x=5;\r\n$y=10;\r\n\r\nfunction myTest() {\r\n  global $x,$y;\r\n  $y=$x+$y;\r\n}\r\n\r\nmyTest();\r\necho $y; // 输出 15\r\n?>\r\n```\r\n\r\nPHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。\r\n```\r\n<?php\r\n\r\n$x=5;\r\n$y=10;\r\n\r\nfunction myTest() {\r\n    $GLOBALS[\'z\']=$GLOBALS[\'x\']+$GLOBALS[\'y\'];\r\n}\r\n\r\nmyTest();\r\necho $z; // 输出 15\r\n$z =0;\r\necho $z;  // 输出 0\r\n```\r\n\r\n\r\n**PHP static 关键词**\r\n\r\n通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作。\r\n\r\n要完成这一点，请在您首次声明变量时使用 static 关键词：\r\n```\r\n<?php\r\n\r\nfunction myTest() {\r\n  static $x=0;\r\n  echo $x;\r\n  $x++;\r\n}\r\n\r\nmyTest();\r\nmyTest();\r\nmyTest();\r\n0\r\n1\r\n2\r\n3\r\n```\r\n然后，每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。\r\n\r\n**注释：该变量仍然是函数的局部变量。**\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(18,'echo print print_r','18',1468581420,1479290360,'<!--markdown-->**PHP echo 和 print 语句**\r\n\r\n**echo 和 print 之间的差异：**\r\necho print 都是语言结构\r\n\r\n    echo - 能够输出一个以上的字符串\r\n    print - 只能输出一个字符串，并始终返回 1\r\n\r\n提示：echo 比 print 稍快，因为它不返回任何值。\r\nprint 实际上不是一个函数（它是一个语言结构），因此你可以不必使用圆括号来括起它的参数列表\r\n```\r\necho \"This\", \" string\", \" was\", \" made\", \" with multiple parameters.\";\r\nprint 1;  1\r\nprint (1);1\r\n```\r\necho和print都可以做输出，不同的是，echo不是函数，没有返回值，而print是一个函数有返回值，所以相对而言如果只是输出 echo 会更快，而print_r通常用于打印变量的相关信息，通常在调试中使用。\r\n\r\nprint   是打印字符串\r\nprint_r 则是打印复合类型  如数组 对象\r\n\r\n\r\n\r\n在实际使用中， print 和 echo 两者的功能几乎是完全一样。\r\n可以这么说，凡是有一个可以使用的地方，另一个也可以使用。但是，两者之间也还是一个非常重要的区别：\r\n在 echo 函数中，可以同时输出多个字符串，而在 print 函数中则只可以同时输出一个字符串。同时，echo函数并不需要圆括号，所以echo函数更像是语句而不像是函数。\r\n\r\necho 和 print 都不是函数，而是语言结构，所以圆括号都不是必需的。他们的区别在于：\r\n(1) echo可以输出多个字符串，像下面这样：\r\necho \'a\',\'b\',\'c\';\r\n如果你非要加上圆括号，注意写成echo (\'a\',\'b\',\'c\');是错误的，应该写成：\r\necho (\'a\'),(\'b\'),(\'c\');\r\n它没有像函数的行为，所以不能用于函数的上下文\r\n(2) print只能输出一个字符串，它可以表现得像一个函数，比如你可以如下使用：\r\n$ret = print \'Hello World\';\r\n所有它能用在更复杂的表达式中。\r\n\r\n另外，echo的效率相对比较快～\r\n\r\n如下代码：\r\n```\r\n<?php\r\n$a=\'hello \';$b=\'php world!\';echo $a,$b.\'<br />\';//echo 可以用逗号分隔字符串变量来显示\r\n\r\nprint $a.$b.\'<br />\';//而print不能使用逗号，只能用点号分隔，print $a,$b.\'<br />\';//使用逗号时报错。\r\n?>\r\n```\r\necho    命令和    print    命令    相同，没有区别  \r\necho    函数    和    print    函数    有区别。  \r\necho()    无返回值，与echo    命令相同  \r\nprint()    有返回值，成功，返1，false,返0.    \r\n\r\nprintf()    和    sprintf()    类似，均为格式化输出，不同的是前者输出到标准输出，后者输出到变量  \r\n\r\n形如  \r\necho    <<<    EOT  \r\nEOT;  \r\nprint    <<<    EOT  \r\nEOT;  \r\n的书写格式，其含义如下:  \r\n<<<    运算符，将由自定义分界符间的内容视为字符串，可对其间的变量做处理  \r\nEOT    自定义分界符，结束时必须位于行首  ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(23,'PHP 常量 const','23',1468727280,1479290344,'<!--markdown-->常量包含数字字母字符和下划线，数字允许作为常量名。 常量名的所有字母必须大写。类常量必须通过 const 定义为类的成员，强烈不鼓励使用 define 定义的全局常量\r\n```\r\n\r\nconst COSD= 11111;\r\nvar_dump(COSD);\r\n\r\n\r\nconst DEMO = \'DEMO\';\r\n\r\nclass Person{\r\n    const MAN = \'男\';\r\n    const WOMAN = \'女\';\r\n}\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(24,'const   define 区别','24',1468728480,1479290339,'<!--markdown-->众所周知，在PHP中(PHP 4及以后)，我们可以使用函数define()来定义常量，例如：\r\n```\r\n    <?php\r\n    define(\'PI\', 3.14159);  //定义一个名为PI的常量\r\n\r\n    echo PI;    //输出：3.14159\r\n    ?>\r\n```\r\n不过，在PHP 5.3.0之后，除了使用函数define()之外，我们还可以使用PHP关键字const来定义常量。\r\n\r\n例如：\r\n```\r\n    <?php\r\n    //以下代码需在PHP 5.3.0及之后的版本中运行\r\n    const PI = 3.14159; //使用const关键字定义一个名为PI的常量\r\n    echo PI;    //输出：3.14159\r\n    ?>\r\n```\r\n虽然上述两种方式均可以定义常量，但是它们之间有什么不同之处呢。下面我们来一一讲解PHP中define()函数和const关键字定义常量的区别：\r\n\r\n1.版本差异\r\n首先，毫无疑问的是，两种定义常量的方式之间存在版本差异，函数define()在PHP4和PHP5中均可使用，关键字const只能在PHP 5.3.0及其后的版本中使用。\r\n\r\n2.定义位置的区别\r\n**由于函数define()定义的常量是在执行define()函数时定义的，因此可以在函数内、循环内、if语句内等函数能够被调用的任何地方使用define()函数定义常量。与define()不同的是，由于const关键字定义的常量是在编译时定义的，因此const关键字定义常量必须处于最顶端的作用区域。这也就意味着不能在函数内、循环内以及if语句之内用const来定义常量。**\r\n```\r\n    <?php\r\n    //使用const关键字定义常量必须处于最顶端的作用区域\r\n    //也就是可以在编译时直接解析定义的地方\r\n    const DEMO = \'DEMO\';\r\n    class Person{\r\n        const MAN = \'男\';\r\n        const WOMAN = \'女\';\r\n    }\r\n\r\n    interface USB{\r\n        const VERSION_2 = \'2.0\';\r\n        const VERSION_3 = \'3.0\';\r\n    }\r\n    ?>\r\n```\r\n3.对值的表达式支持的差异\r\n虽然关键字const和define()定义的常量值都只能为null或标量数据(boolean，integer，float和string类型)以及resource类型(不推荐定义resource类型的常量，否则可能出现无法预知的结果)。不过，由于关键字const定义常量是在编译时定义的，因此**const关键字定义的常量值的表达式中不支持算术运算符、位运算符、比较运算符等多种运算符，而这些运算符在define()函数定义常量时都是可以直接使用的。**\r\n```\r\n    <?php\r\n    define(\'DEFINE_VAR1\', 1 << 1);\r\n    //const CONST_VAR1 = (1 << 1); //const不支持位运算符，PHP会报语法错误\r\n\r\n    define(\'DEFINE_VAR2\', 1 + 1);\r\n    //const CONST_VAR2 = 1 + 1 ; //const不支持算术运算符，PHP会报语法错误\r\n\r\n    define(\'DEFINE_VAR3\', 1 == 1);\r\n    //const CONST_VAR3 = 1 == 1 ; //const不支持比较运算符，PHP会报语法错误\r\n\r\n    $value = 3;\r\n    define(\'DEFINE_VAR4\', $value);\r\n    //const CONST_VAR4 = $value ; //const不支持变量形式的值，PHP会报语法错误\r\n\r\n    define(\'DEFINE_VAR5\', true || false);\r\n    //const CONST_VAR5 = true || false ; //const不支持逻辑运算符，PHP会报语法错误\r\n\r\n    define(\'DEFINE_VAR6\', \'Hello\'.\' World!\');\r\n    //const CONST_VAR6 = \'Hello\'.\' World!\' ; //const不支持字符串运算符，PHP会报语法错误\r\n\r\n    class User{ \r\n    }$user = new User();define(\'DEFINE_VAR7\', $user instanceof User);\r\n    //const CONST_VAR7 = $user instanceof User ; //const不支持类型运算符，PHP会报语法错误\r\n    ?>\r\n```\r\n4.对字符大小写敏感的支持差异\r\n除上述3个区别外，还有一个不太起眼的区别。函数define()可以接收第3个参数，如果该参数为true，则表示常量名的大小写不敏感。而使用const关键字定义常量却没有提供类似的功能。\r\n```\r\n    <?php\r\n    //设置编码为UTF-8，以避免中文乱码\r\n    header(\'Content-Type:text/html;charset=utf-8\');\r\n\r\n    //define()的第3个参数为true时，表示大小写不敏感\r\n    define(\'SITE_NAME\', \'CodePlayer\', true);\r\n    echo SITE_NAME; //输出：CodePlayer\r\n    echo site_name; //输出：CodePlayer\r\n    echo SiTe_NamE; //输出：CodePlayer\r\n\r\n    const DOMAIN_NAME = \'365mini.com\';\r\n    echo DOMAIN_NAME;   //输出：365mini.com\r\n    echo domain_name;   //PHP提示常量未定义\r\n    echo DomaIN_nAMe;   //PHP提示常量未定义\r\n    ?>\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(22,'PHP 常量 define','22',1468722900,1479290349,'<!--markdown-->常量类似变量，但是常量一旦被定义就无法更改或撤销定义。\r\n\r\n常量是单个值的标识符（名称）。在脚本中无法改变该值。\r\n\r\n有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。\r\n\r\n注释：与变量不同，常量贯穿整个脚本是自动全局的。\r\n\r\n设置 PHP 常量\r\n\r\n如需设置常量，请使用 define() 函数 - 它使用三个参数：\r\n\r\n    首个参数定义常量的名称\r\n    第二个参数定义常量的值\r\n    可选的第三个参数规定常量名是否对大小写敏感。默认是 false。\r\n\r\n下例创建了一个对大小写敏感的常量，值为 \"Welcome to W3School.com.cn!\"：\r\n实例\r\n\r\n```\r\ndefine(\"GREETING\", \"Welcome to W3School.com.cn!\");\r\necho GREETING;\r\n\r\n如果\r\necho greering （报错）\r\n```\r\n\r\n运行实例\r\n\r\n下例创建了一个对大小写不敏感的常量，值为 \"Welcome to W3School.com.cn!\"：\r\n实例\r\n\r\n```\r\ndefine(\"GREETING\", \"Welcome to W3School.com.cn!\", true);\r\necho greeting;\r\ntrue 大小写不敏感\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(20,'PHP 数据类型','20',1468583520,1479290355,'<!--markdown-->PHP 数据类型\r\n\r\nPHP 支持八种原始类型（type）。\r\n\r\n四种标量类型：\r\nstring（字符串）\r\ninteger（整型）\r\nfloat（浮点型，也作 double ）\r\nboolean（布尔型）\r\n\r\n两种复合类型：\r\narray（数组）\r\nobject（对象）\r\n\r\n两种特殊类型：\r\nresource（资源）\r\nNULL（空）\r\n\r\n通过 gettype() 函数可以方便的查看某个变量的类型：\r\n由于历史原因，如果是 float 类型数据，gettype() 函数返回的是 double，而不是 float 。\r\n如果想查看某个表达式的值和类型，请使用用 var_dump() 函数。\r\n判断变量类型\r\n\r\n如果想通过判断变量类型来确定下一步逻辑动作，不要使用 gettype() ，而使用 is_type 系列函数：\r\n```\r\n<?php$var_int = 12;// 如果 $var_int 是 int 类型，这进行加法\r\nif (is_int($var_int)) {\r\n        $var_int = $var_int+4;\r\n}echo $var_int; // 输出 16?> \r\n\r\n\r\nisset():                        //变量是否已经声明\r\nempty():                        //变量是否为空\r\ndefined():　　　　　　　　　　　　　　　　　　　　　　　//常量是否已经定义 define()\r\narray_key_exists(mixed key, array search):        //检查给定的键名或索引是否存在于数组中\r\n\r\nis_numeric ( mixed var ):                //检测变量是 否为数字或数字字符串\r\nis_bool():            // 检测变量是否是布尔型\r\nis_float():            // 检测变量是否是浮点型 和is_double，is_real()都一样的用法\r\nis_int():            // 检测变量是否是整数is_integer() 一样的 用法\r\nis_string():            // 检测变量是否是字符串\r\nis_object():            // 检测变量是否是一个对象\r\nis_array():            // 检测变量是否是数组\r\nis_null():            // 检测变量是否为 NULL 值是否是NULL大小写敏感\r\n\r\n强制转换\r\n•(int), (integer) - 转换为 整型(integer)\r\n•(bool), (boolean) - 转换为 布尔型(boolean)\r\n•(float), (double), (real) - 转换为 浮点型(float)\r\n•(string) - 转换为 字符串(string)\r\n•(binary) - 转换为二进制 字符串(string) (PHP 6)\r\n•(array) - 转换为 数组(array)\r\n•(object) - 转换为 对象(object)\r\n•(unset) - 转换为 NULL (PHP 5)\r\n\r\n\r\n$num1=3.14;\r\n$num2=(int)$num1; //强制转换为int类型\r\nvar_dump($num1); //输出float(3.14)\r\nvar_dump($num2); //输出int(3)\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(25,'if...else...elseif...','25',1468729860,1479290333,'<!--markdown-->在您编写代码时，经常会希望为不同的决定执行不同的动作。您可以在代码中使用条件语句来实现这一点。\r\n\r\n在 PHP 中，我们可以使用以下条件语句：\r\n\r\n    if 语句 - 如果指定条件为真，则执行代码\r\n    if...else 语句 - 如果条件为 true，则执行代码；如果条件为 false，则执行另一端代码\r\n    if...elseif....else 语句 - 选择若干段代码块之一来执行\r\n    switch 语句 - 语句多个代码块之一来执行\r\n```\r\nif (条件) {\r\n  当条件为 true 时执行的代码;\r\n}\r\n\r\nif (条件) {\r\n  条件为 true 时执行的代码;\r\n} else {\r\n  条件为 false 时执行的代码;\r\n}\r\n\r\n\r\nif (条件) {\r\n  条件为 true 时执行的代码;\r\n} elseif (condition) {\r\n  条件为 true 时执行的代码;\r\n} elseif {\r\n  条件为 false 时执行的代码;\r\n}\r\n\r\n$t=date(\"H\");\r\nvar_dump($t);\r\nif ($t<\"10\") {\r\n    echo \"Have a good morning!\";\r\n} else   if ($t<\"20\") {\r\n    echo \"Have a good day!\";\r\n} else {\r\n    echo \"Have a good night!\";\r\n}\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(26,'elseif / else     if  ','26',1468730340,1479290327,'<!--markdown-->elseif/else if\r\n\r\n(PHP 4, PHP 5, PHP 7)\r\n\r\nelseif，和此名称暗示的一样，是 if 和 else 的组合。和 else 一样，它延伸了 if 语句，可以在原来的 if 表达式值为 FALSE 时执行不同语句。但是和 else 不一样的是，它仅在 elseif 的条件表达式值为 TRUE 时执行语句。例如以下代码将根据条件分别显示 a is bigger than b，a equal to b 或者 a is smaller than b：\r\n```\r\n<?php\r\nif ($a > $b) {\r\n    echo \"a is bigger than b\";\r\n} elseif ($a == $b) {\r\n    echo \"a is equal to b\";\r\n} else {\r\n    echo \"a is smaller than b\";\r\n}\r\n?>\r\n```\r\n在同一个 if 语句中可以有多个 elseif 部分，其中第一个表达式值为 TRUE（如果有的话）的 elseif 部分将会执行。在 PHP 中，也可以写成“else if”（两个单词），它和“elseif”（一个单词）的行为完全一样。句法分析的含义有少许区别（如果你熟悉 C 语言的话，与之行为相同），但是底线是两者会产生完全一样的行为。\r\n\r\nelseif 的语句仅在之前的 if 和所有之前 elseif 的表达式值为 FALSE，并且当前的 elseif 表达式值为 TRUE 时执行。\r\n\r\n    Note: 必须要注意的是 elseif 与 else if 只有在类似上例中使用花括号的情况下才认为是完全相同。如果用冒号来定义 if/elseif 条件，那就不能用两个单词的 else if，否则 PHP 会产生解析错误。 \r\n```\r\n<?php\r\n\r\n/* 不正确的使用方法： */\r\nif($a > $b):\r\n    echo $a.\" is greater than \".$b;\r\nelse if($a == $b): // 将无法编译\r\n    echo \"The above line causes a parse error.\";\r\nendif;\r\n\r\n\r\n/* 正确的使用方法： */\r\nif($a > $b):\r\n    echo $a.\" is greater than \".$b;\r\nelseif($a == $b): // 注意使用了一个单词的 elseif\r\n    echo $a.\" equals \".$b;\r\nelse:\r\n    echo $a.\" is neither greater than or equal to \".$b;\r\nendif;\r\n\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(27,'switch','27',1468730700,1479290322,'<!--markdown-->**switch 语句用于基于不同条件执行不同动作。**\r\n\r\n如果您希望有选择地执行若干代码块之一，请使用 Switch 语句。\r\n\r\n使用 Switch 语句可以避免冗长的 if..elseif..else 代码块。\r\n```\r\nswitch (expression)\r\n{\r\ncase label1:\r\n  code to be executed if expression = label1;\r\n  break;  \r\ncase label2:\r\n  code to be executed if expression = label2;\r\n  break;\r\ndefault:\r\n  code to be executed\r\n  if expression is different \r\n  from both label1 and label2;\r\n}\r\n```\r\n\r\n工作原理：\r\n\r\n    对表达式（通常是变量）进行一次计算\r\n    把表达式的值与结构中 case 的值进行比较\r\n    如果存在匹配，则执行与 case 关联的代码\r\n    代码执行后，break 语句阻止代码跳入下一个 case 中继续执行\r\n    如果没有 case 为真，则使用 default 语句\r\n```\r\n<?php\r\nswitch ($x)\r\n{\r\ncase 1:\r\n  echo \"Number 1\";\r\n  break;\r\ncase 2:\r\n  echo \"Number 2\";\r\n  break;\r\ncase 3:\r\n  echo \"Number 3\";\r\n  break;\r\ndefault:\r\n  echo \"No number between 1 and 3\";\r\n}\r\n?>\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(28,'PHP while 循环','28',1468730880,1479290317,'<!--markdown-->**PHP while 循环在指定条件为 true 时执行代码块。**\r\n\r\n在您编写代码时，经常需要反复运行同一代码块。我们可以使用循环来执行这样的任务，而不是在脚本中添加若干几乎相等的代码行。\r\n\r\n在 PHP 中，我们有以下循环语句：\r\n\r\n    while - 只要指定条件为真，则循环代码块\r\n    do...while - 先执行一次代码块，然后只要指定条件为真则重复循环\r\n    for - 循环代码块指定次数\r\n    foreach - 遍历数组中的每个元素并循环代码块\r\n\r\n**PHP while 循环**\r\n只要指定的条件为真，while 循环就会执行代码块。\r\n```\r\nwhile (条件为真) {\r\n  要执行的代码;\r\n}\r\n\r\n<?php \r\n$x=1; \r\n\r\nwhile($x<=5) {\r\n  echo \"这个数字是：$x <br>\";\r\n  $x++;\r\n} \r\n?>\r\n```\r\n\r\n**PHP do...while 循环**\r\n\r\ndo...while 循环首先会执行一次代码块，然后检查条件，如果指定条件为真，则重复循环。\r\n语法\r\n```\r\ndo {\r\n  要执行的代码;\r\n} while (条件为真);\r\n```\r\n下面的例子首先把变量 $x 设置为 1（$x=1）。然后，do while 循环输出一段字符串，然后对变量 $x 递增 1。随后对条件进行检查（$x 是否小于或等于 5）。只要 $x 小于或等于 5，循环将会继续运行：\r\n实例\r\n```\r\n<?php \r\n$x=1; \r\n\r\ndo {\r\n  echo \"这个数字是：$x <br>\";\r\n  $x++;\r\n} while ($x<=5);\r\n?>\r\n```\r\n\r\n请注意，do while 循环只在执行循环内的语句之后才对条件进行测试。这意味着 do while 循环至少会执行一次语句，即使条件测试在第一次就失败了。\r\n\r\n下面的例子把 $x 设置为 6，然后运行循环，随后对条件进行检查：\r\n实例\r\n```\r\n<?php \r\n$x=6;\r\n\r\ndo {\r\n  echo \"这个数字是：$x <br>\";\r\n  $x++;\r\n} while ($x<=5);\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(29,'PHP for 循环','29',1468731180,1479290312,'<!--markdown-->PHP for 循环执行代码块指定的次数。\r\n\r\n语法\r\n```\r\nfor (init counter; test counter; increment counter) {\r\n  code to be executed;\r\n}\r\n\r\n参数：\r\n\r\n    init counter：初始化循环计数器的值\r\n    test counter：: 评估每个循环迭代。如果值为 TRUE，继续循环。如果它的值为 FALSE，循环结束。\r\n    increment counter：增加循环计数器的值\r\n```\r\n下面的例子显示了从 0 到 10 的数字：\r\n\r\n```\r\n<?php \r\nfor ($x=0; $x<=10; $x++) {\r\n  echo \"数字是：$x <br>\";\r\n} \r\n?>\r\n```\r\nPHP foreach 循环\r\n\r\nforeach 循环只适用于数组，并用于遍历数组中的每个键/值对。\r\n语法\r\n```\r\nforeach ($array as $value) {\r\n  code to be executed;\r\n}\r\n```\r\n每进行一次循环迭代，当前数组元素的值就会被赋值给 $value 变量，并且数组指针会逐一地移动，直到到达最后一个数组元素。\r\n\r\n下面的例子演示的循环将输出给定数组（$colors）的值：\r\n实例\r\n```\r\n<?php \r\n$colors = array(\"red\",\"green\",\"blue\",\"yellow\"); \r\n\r\nforeach ($colors as $value) {\r\n  echo \"$value <br>\";\r\n}\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(30,'PHP 函数','30',1468731420,1479290295,'<!--markdown-->PHP 用户定义函数\r\n\r\n除了内建的 PHP 函数，我们可以创建我们自己的函数。\r\n\r\n函数是可以在程序中重复使用的语句块。\r\n\r\n页面加载时函数不会立即执行。\r\n\r\n函数只有在被调用时才会执行。\r\n在 PHP 创建用户定义函数\r\n\r\n用户定义的函数声明以关单 \"function\" 开头：\r\n语法\r\n```\r\nfunction functionName() {\r\n  被执行的代码;\r\n}\r\n\r\n注释：函数名能够以字母或下划线开头（而非数字）。\r\n\r\n注释：函数名对大小写不敏感。\r\n\r\n提示：函数名应该能够反映函数所执行的任务。\r\n```\r\n在下面的例子中，我们创建名为 \"writeMsg()\" 的函数。打开的花括号（{）指示函数代码的开始，而关闭的花括号（}）指示函数的结束。此函数输出 \"Hello world!\"。如需调用该函数，只要使用函数名即可：\r\n\r\n```\r\n<?php\r\nfunction writeMsg() {\r\n  echo \"Hello world!\";\r\n}\r\n\r\nwriteMsg(); // 调用函数\r\n?>\r\n```\r\n\r\nPHP 函数参数\r\n\r\n可以通过参数向函数传递信息。参数类似变量。\r\n\r\n参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。\r\n\r\n下面的例子中的函数有一个参数（$fname）。当调用 familyName() 函数时，我们同时要传递一个名字（例如 Bill），这样会输出不同的名字，但是姓氏相同：\r\n实例\r\n```\r\n<?php\r\nfunction familyName($fname) {\r\n  echo \"$fname Zhang.<br>\";\r\n}\r\n\r\nfamilyName(\"Li\");\r\nfamilyName(\"Hong\");\r\nfamilyName(\"Tao\");\r\nfamilyName(\"Xiao Mei\");\r\nfamilyName(\"Jian\");\r\n?>\r\n```\r\n\r\n下面的例子中的函数有两个参数（$fname 和 $year）：\r\n```\r\n<?php\r\nfunction familyName($fname,$year) {\r\n  echo \"$fname Zhang. Born in $year <br>\";\r\n}\r\n\r\nfamilyName(\"Li\",\"1975\");\r\nfamilyName(\"Hong\",\"1978\");\r\nfamilyName(\"Tao\",\"1983\");\r\n?>\r\n```\r\nPHP 默认参数值\r\n\r\n下面的例子展示了如何使用默认参数。如果我们调用没有参数的 setHeight() 函数，它的参数会取默认值：\r\n```\r\n\r\n<?php\r\nfunction setHeight($minheight=50) {\r\n  echo \"The height is : $minheight <br>\";\r\n}\r\n\r\nsetHeight(350);\r\nsetHeight(); // 将使用默认值 50\r\nsetHeight(135);\r\nsetHeight(80);\r\n?>\r\n\r\n```\r\nPHP 函数 - 返回值\r\n\r\n如需使函数返回值，请使用 return 语句：\r\n```\r\n\r\n<?php\r\nfunction sum($x,$y) {\r\n  $z=$x+$y;\r\n  return $z;\r\n}\r\n\r\necho \"5 + 10 = \" . sum(5,10) . \"<br>\";\r\necho \"7 + 13 = \" . sum(7,13) . \"<br>\";\r\necho \"2 + 4 = \" . sum(2,4);\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(31,'PHP数组','31',1468737240,1479290272,'<!--markdown-->数组能够在单独的变量名中存储一个或多个值。\r\n```\r\n<?php\r\n$cars=array(\"Volvo\",\"BMW\",\"SAAB\");\r\necho \"I like \" . $cars[0] . \", \" . $cars[1] . \" and \" . $cars[2] . \".\";\r\n?>\r\n\r\n在 PHP 中， array() 函数用于创建数组：\r\n\r\narray();\r\n\r\n在 PHP 中，有三种数组类型：\r\n\r\n    索引数组 - 带有数字索引的数组\r\n    关联数组 - 带有指定键的数组\r\n    多维数组 - 包含一个或多个数组的数组\r\n```\r\n\r\n**PHP 索引数组**\r\n\r\n有两种创建索引数组的方法：\r\n\r\n索引是自动分配的（索引从 0 开始）：\r\n```\r\n$cars=array(\"Volvo\",\"BMW\",\"SAAB\");\r\n```\r\n或者也可以手动分配索引：\r\n```\r\n$cars[0]=\"Volvo\";\r\n$cars[1]=\"BMW\";\r\n$cars[2]=\"SAAB\";\r\n\r\ncount() 函数用于返回数组的长度（元素数）：\r\n\r\n```\r\n\r\n**PHP 关联数组**\r\n\r\n**关联数组是使用您分配给数组的指定键的数组。**\r\n\r\n有两种创建关联数组的方法：\r\n```\r\n$age=array(\"Peter\"=>\"35\",\"Ben\"=>\"37\",\"Joe\"=>\"43\");\r\n```\r\n或者：\r\n```\r\n$age[\'Peter\']=\"35\";\r\n$age[\'Ben\']=\"37\";\r\n$age[\'Joe\']=\"43\";\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(32,'PHP数组排序','32',1468737660,1479290283,'<!--markdown-->    sort() - 以升序对数组排序\r\n    rsort() - 以降序对数组排序\r\n    asort() - 根据值，以升序对关联数组进行排序\r\n    ksort() - 根据键，以升序对关联数组进行排序\r\n    arsort() - 根据值，以降序对关联数组进行排序\r\n    krsort() - 根据键，以降序对关联数组进行排序\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(33,'PHP数组排序','33',1468737660,1479290267,'<!--markdown-->    sort() - 以升序对数组排序\r\n    rsort() - 以降序对数组排序\r\n    asort() - 根据值，以升序对关联数组进行排序\r\n    ksort() - 根据键，以升序对关联数组进行排序\r\n    arsort() - 根据值，以降序对关联数组进行排序\r\n    krsort() - 根据键，以降序对关联数组进行排序\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(34,'GET  POST','34',1468738260,1479290262,'<!--markdown-->GET vs. POST\r\n\r\nGET 和 POST 都创建数组（例如，array( key => value, key2 => value2, key3 => value3, ...)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。\r\n\r\nGET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。\r\n\r\n$_GET 是通过 URL 参数传递到当前脚本的变量数组。\r\n\r\n$_POST 是通过 HTTP POST 传递到当前脚本的变量数组。\r\n何时使用 GET？\r\n\r\n通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大于 **2000** 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。\r\n\r\nGET 可用于发送非敏感的数据。\r\n\r\n注释：绝不能使用 GET 来发送密码或其他敏感信息！\r\n何时使用 POST？\r\n\r\n通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。\r\n\r\n此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。\r\n\r\n不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。\r\n\r\n提示：开发者偏爱 POST 来发送表单数据。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(35,'date','35',1468739160,1479290257,'<!--markdown-->\r\nPHP date() 函数用于对日期或时间进行格式化。\r\nPHP Date() 函数\r\n\r\nPHP Date() 函数把时间戳格式化为更易读的日期和时间。\r\n```\r\n语法\r\n\r\ndate(format,timestamp)\r\n\r\n参数 	描述\r\nformat 	必需。规定时间戳的格式。\r\ntimestamp 	可选。规定时间戳。默认是当前时间和日期。\r\n```\r\ndate() 函数的格式参数是必需的，它们规定如何格式化日期或时间。\r\n\r\n下面列出了一些常用于日期的字符：\r\n\r\n    d - 表示月里的某天（01-31）\r\n    m - 表示月（01-12）\r\n    Y - 表示年（四位数）\r\n    1 - 表示周里的某天 （小写L）\r\n\r\n其他字符，比如 \"/\", \".\" 或 \"-\" 也可被插入字符中，以增加其他格式。\r\n```\r\n<?php\r\necho \"今天是 \" . date(\"Y/m/d\") . \"<br>\";\r\necho \"今天是 \" . date(\"Y.m.d\") . \"<br>\";\r\necho \"今天是 \" . date(\"Y-m-d\") . \"<br>\";\r\necho \"今天是 \" . date(\"l\");\r\n?>\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(36,'include','36',1468740360,1479290250,'<!--markdown-->\r\ninclude （或 require）语句会获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。\r\n\r\n包含文件很有用，如果您需要在网站的多张页面上引用相同的 PHP、HTML 或文本的话。\r\n\r\n通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。\r\n\r\ninclude 和 require 语句是相同的，除了错误处理方面：\r\n\r\n    **require 会生成致命错误（E_COMPILE_ERROR）并停止脚本\r\n    include 只生成警告（E_WARNING），并且脚本会继续**\r\n\r\n因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。\r\n```\r\ninclude \'filename\';\r\nrequire \'filename\';\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(37,'fopen','37',1468742940,1479290243,'<!--markdown-->fopen(filename,mode,include_path,context)\r\n\r\n参数 	描述\r\nfilename 	必需。规定要打开的文件或 URL。\r\nmode 	必需。规定要求到该文件/流的访问类型。可能的值见下表。\r\ninclude_path 	可选。如果也需要在 include_path 中检索文件的话，可以将该参数设为 1 或 TRUE。\r\ncontext 	可选。规定文件句柄的环境。Context 是可以修改流的行为的一套选项。\r\n\r\n```\r\nr  从开头逐字覆盖\r\nw  清空重写\r\na  追加\r\nx  创建新文件\r\n\"r\" 	只读方式打开，将文件指针指向文件头。\r\n\"r+\" 	读写方式打开，将文件指针指向文件头。\r\n\"w\" 	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。\r\n\"w+\" 	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。\r\n\"a\" 	写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。\r\n\"a+\" 	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。\r\n\"x\" 	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。\r\n\"x+\" 	创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(39,'fread fclose ','39',1468743720,1479290233,'<!--markdown-->PHP 读取文件 - fread()\r\n\r\nfread() 函数读取打开的文件。\r\n\r\nfread() 的第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数。\r\n\r\n如下 PHP 代码把 \"webdictionary.txt\" 文件读至结尾：\r\n```\r\nfread($myfile,filesize(\"webdictionary.txt\"));\r\n\r\n```\r\n\r\nPHP 关闭文件 - fclose()\r\n\r\nfclose() 函数用于关闭打开的文件。\r\n\r\n注释：用完文件后把它们全部关闭是一个良好的编程习惯。您并不想打开的文件占用您的服务器资源。\r\n\r\nfclose() 需要待关闭文件的名称（或者存有文件名的变量）：\r\n```\r\n<?php\r\n$myfile = fopen(\"webdictionary.txt\", \"r\");\r\n// some code to be executed....\r\nfclose($myfile);\r\n?>\r\n\r\n```\r\n\r\n\r\n\r\nPHP 读取单行文件 - fgets()\r\n\r\nfgets() 函数用于从文件读取单行。\r\n\r\n下例输出 \"webdictionary.txt\" 文件的首行：\r\n```\r\n\r\n<?php\r\n$myfile = fopen(\"webdictionary.txt\", \"r\") or die(\"Unable to open file!\");\r\necho fgets($myfile);\r\nfclose($myfile);\r\n?>\r\n```\r\n\r\n**注释：调用 fgets() 函数之后，文件指针会移动到下一行。**\r\nPHP 检查 End-Of-File - feof()\r\n\r\nfeof() 函数检查是否已到达 \"end-of-file\" (EOF)。\r\n\r\nfeof() 对于遍历未知长度的数据很有用。\r\n\r\n下例逐行读取 \"webdictionary.txt\" 文件，直到 end-of-file：\r\n```\r\n\r\n<?php\r\n$myfile = fopen(\"webdictionary.txt\", \"r\") or die(\"Unable to open file!\");\r\n// 输出单行直到 end-of-file\r\nwhile(!feof($myfile)) {\r\n  echo fgets($myfile) . \"<br>\";\r\n}\r\nfclose($myfile);\r\n?>\r\n\r\n```\r\nPHP 读取单字符 - fgetc()\r\n\r\nfgetc() 函数用于从文件中读取单个字符。\r\n\r\n下例逐字符读取 \"webdictionary.txt\" 文件，直到 end-of-file：\r\n\r\n```\r\n<?php\r\n$myfile = fopen(\"webdictionary.txt\", \"r\") or die(\"Unable to open file!\");\r\n// 输出单字符直到 end-of-file\r\nwhile(!feof($myfile)) {\r\n  echo fgetc($myfile);\r\n}\r\nfclose($myfile);\r\n?>\r\n```\r\n**注释：在调用 fgetc() 函数之后，文件指针会移动到下一个字符。**\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(40,'PHP 创建文件 - fopen()','40',1468744200,1479290223,'<!--markdown-->**PHP 创建文件 - fopen()**\r\nfopen() 函数也用于创建文件。也许有点混乱，但是在 PHP 中，创建文件所用的函数与打开文件的相同。\r\n\r\n如果您用 fopen() 打开并不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。\r\n\r\n**PHP 写入文件 - fwrite()**\r\n\r\nfwrite() 函数用于写入文件。\r\n\r\n**fwrite() 的第一个参数包含要写入的文件的文件名，第二个参数是被写的字符串。**\r\n\r\n下面的例子把姓名写入名为 \"newfile.txt\" 的新文件中：\r\n\r\n```\r\n<?php\r\n$myfile = fopen(\"newfile.txt\", \"w\") or die(\"Unable to open file!\");\r\n$txt = \"Bill Gates\\n\";\r\nfwrite($myfile, $txt);\r\n$txt = \"Steve Jobs\\n\";\r\nfwrite($myfile, $txt);\r\nfclose($myfile);\r\n?>\r\n```\r\n请注意，我们向文件 \"newfile.txt\" 写了两次。在每次我们向文件写入时，在我们发送的字符串 $txt 中，第一次包含 \"Bill Gates\"，第二次包含 \"Steve Jobs\"。在写入完成后，我们使用 fclose() 函数来关闭文件。\r\n\r\n如果我们打开 \"newfile.txt\" 文件，它应该是这样的：\r\n```\r\nBill Gates\r\nSteve Jobs\r\n```\r\n**PHP 覆盖（Overwriting）**\r\n\r\n如果现在 \"newfile.txt\" 包含了一些数据，我们可以展示在写入已有文件时发生的的事情。**所有已存在的数据会被擦除并以一个新文件开始。**\r\n\r\n在下面的例子中，我们打开一个已存在的文件 \"newfile.txt\"，并向其中写入了一些新数据：\r\n实例\r\n```\r\n<?php\r\n$myfile = fopen(\"newfile.txt\", \"w\") or die(\"Unable to open file!\");\r\n$txt = \"Mickey Mouse\\n\";\r\nfwrite($myfile, $txt);\r\n$txt = \"Minnie Mouse\\n\";\r\nfwrite($myfile, $txt);\r\nfclose($myfile);\r\n?>\r\n```\r\n如果现在我们打开这个 \"newfile.txt\" 文件，Bill 和 Steve 都已消失，只剩下我们刚写入的数据：\r\n```\r\nMickey Mouse\r\nMinnie Mouse\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(41,'PHP Cookies','41',1468744500,1479290215,'<!--markdown-->**什么是 Cookie？**\r\n\r\ncookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。\r\n\r\n如何创建 cookie？\r\n```\r\nsetcookie() 函数用于设置 cookie。\r\n```\r\n注释：setcookie() 函数必须位于 <html> 标签之前。\r\n语法\r\n```\r\nsetcookie(name, value, expire, path, domain);\r\n```\r\n例子\r\n\r\n在下面的例子中，我们将创建名为 \"user\" 的 cookie，把为它赋值 \"Alex Porter\"。我们也规定了此 cookie 在一小时后过期：\r\n```\r\n<?php \r\nsetcookie(\"user\", \"Alex Porter\", time()+3600);\r\n?>\r\n\r\n<html>\r\n<body>\r\n\r\n</body>\r\n</html>\r\n```\r\n注释：在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码（为防止 URL 编码，请使用 setrawcookie() 取而代之）。\r\n\r\n\r\n**如何取回 Cookie 的值？**\r\n\r\n****PHP 的 $_COOKIE 变量用于取回 cookie 的值。****\r\n\r\n在下面的例子中，我们取回了名为 \"user\" 的 cookie 的值，并把它显示在了页面上：\r\n```\r\n<?php\r\n// Print a cookie\r\necho $_COOKIE[\"user\"];\r\n\r\n// A way to view all cookies\r\nprint_r($_COOKIE);\r\n?>\r\n```\r\n在下面的例子中，我们使用 isset() 函数来确认是否已设置了 cookie：\r\n```\r\n<html>\r\n<body>\r\n\r\n<?php\r\nif (isset($_COOKIE[\"user\"]))\r\n  echo \"Welcome \" . $_COOKIE[\"user\"] . \"!<br />\";\r\nelse\r\n  echo \"Welcome guest!<br />\";\r\n?>\r\n\r\n</body>\r\n</html>\r\n```\r\n如何删除 cookie？\r\n\r\n**当删除 cookie 时，您应当使过期日期变更为过去的时间点。**\r\n\r\n删除的例子：\r\n```\r\n<?php \r\n// set the expiration date to one hour ago\r\nsetcookie(\"user\", \"\", time()-3600);\r\n?>\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(42,'PHP session','42',1468748100,1479290209,'<!--markdown-->PHP session 变量用于存储有关用户会话的信息，或更改用户会话的设置。Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。\r\n\r\n开始 PHP Session\r\n\r\n在您把用户信息存储到 PHP session 中之前，首先必须启动会话。\r\n注释：session_start() 函数必须位于 <html> 标签之前：\r\n```\r\n<?php session_start(); ?>\r\n\r\n<html>\r\n<body>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n**存储 Session 变量\r\n存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：**\r\n```\r\n<?php\r\nsession_start();\r\n// store session data\r\n$_SESSION[\'views\']=1;\r\n?>\r\n\r\n<html>\r\n<body>\r\n\r\n<?php\r\n//retrieve session data\r\necho \"Pageviews=\". $_SESSION[\'views\'];\r\n?>\r\n\r\n</body>\r\n</html>\r\n\r\n输出：\r\n\r\nPageviews=1\r\n```\r\n在下面的例子中，我们创建了一个简单的 page-view 计数器。isset() 函数检测是否已设置 \"views\" 变量。如果已设置 \"views\" 变量，我们累加计数器。如果 \"views\" 不存在，则我们创建 \"views\" 变量，并把它设置为 1：\r\n```\r\n<?php\r\nsession_start();\r\n\r\nif(isset($_SESSION[\'views\']))\r\n  $_SESSION[\'views\']=$_SESSION[\'views\']+1;\r\n\r\nelse\r\n  $_SESSION[\'views\']=1;\r\necho \"Views=\". $_SESSION[\'views\'];\r\n?>\r\n```\r\n**终结 Session**\r\n\r\n如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。\r\n\r\n**unset() 函数用于释放指定的 session 变量：**\r\n```\r\n<?php\r\nunset($_SESSION[\'views\']);\r\n?>\r\n```\r\n您也可以通过 session_destroy() 函数彻底终结 session：\r\n```\r\n<?php\r\nsession_destroy();\r\n?>\r\n```\r\n**注释：session_destroy() 将重置 session，您将失去所有已存储的 session 数据。**\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(43,'cookie session 区别','43',1468750260,1479290203,'<!--markdown-->cookie 和session 的区别：\r\n\r\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\r\n\r\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\r\n   考虑到安全应当使用session。\r\n\r\n3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\r\n   考虑到减轻服务器性能方面，应当使用COOKIE。\r\n\r\n4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\r\n\r\n5、所以个人建议：\r\n   将登陆信息等重要信息存放为SESSION\r\n   其他信息如果需要保留，可以放在COOKIE中',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(44,'PHP 全局变量 - 超全局变量','44',1468809240,1479290198,'<!--markdown-->    $GLOBALS  引用全局作用域中可用的全部变量\r\n    $_SERVER  保存关于报头、路径和脚本位置的信息。\r\n    $_REQUEST 用于收集 HTML 表单提交的数据。\r\n    $_POST    method=\"post\" 的 HTML 表单后的表单数据\r\n    $_GET     method=\"get\" 之后的表单数据\r\n    $_FILES\r\n    $_ENV\r\n    $_COOKIE\r\n    $_SESSION\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(45,'PHP  异常处理','45',1468809660,1479290192,'<!--markdown-->异常（Exception）用于在指定的错误发生时改变脚本的正常流程。\r\n\r\n什么是异常？\r\n\r\nPHP 5 提供了一种新的面向对象的错误处理方法。\r\n\r\n异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。\r\n\r\n当异常被触发时，通常会发生：\r\n\r\n    当前代码状态被保存\r\n    代码执行被切换到预定义的异常处理器函数\r\n    根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本\r\n\r\n我们将展示不同的错误处理方法：\r\n\r\n    异常的基本使用\r\n    创建自定义的异常处理器\r\n    多个异常\r\n    重新抛出异常\r\n    设置顶层异常处理器\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(46,'异常处理','46',1469081640,1479290185,'<!--markdown-->PHP异常处理详解\r\n\r\n         异常处理（又称为错误处理）功能提供了处理程序运行时出现的错误或异常情况的方法。\r\n\r\n　　异常处理通常是防止未知错误产生所采取的处理措施。异常处理的好处是你不用再绞尽脑汁去考虑各种错误，这为处理某一类错误提供了一个很有效的方法，使编程效率大大提高。当异常被触发时，通常会发生：\r\n          当前代码状态被保存\r\n         代码执行被切换到预定义的异常处理器函数\r\n          根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本\r\n\r\n          PHP 5 提供了一种新的面向对象的错误处理方法。可以使用检测（try）、抛出（throw）和捕获（catch）异常。即使用try检测有没有抛出（throw）异常，若有异常抛出（throw），使用catch捕获异常。\r\n\r\n         一个 try 至少要有一个与之对应的 catch。定义多个 catch 可以捕获不同的对象。PHP 会按这些 catch 被定义的顺序执行，直到完成最后一个为止。而在这些 catch 内，又可以抛出新的异常。\r\n\r\n1. 异常的使用\r\n        当一个异常被抛出时，其后的代码将不会继续执行，PHP 会尝试查找匹配的 \"catch\" 代码块。如果一个异常没有被捕获，而且又没用使用set_exception_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出未能捕获异常(Uncaught Exception ... )的提示信息。\r\n\r\n     抛出异常，但不去捕获它：\r\n\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\nini_set(\'display_errors\', \'On\');  \r\nerror_reporting(E_ALL & ~ E_WARNING);  \r\n$error = \'Always throw this error\';  \r\nthrow new Exception($error);  \r\n// 继续执行  \r\necho \'Hello World\';  \r\n?>   \r\n上面的代码会获得类似这样的一个致命错误：\r\n\r\n[plain] view plain copy print?\r\nFatal error: Uncaught exception \'Exception\' with message \'Always throw this error\' in E:\\sngrep\\index.php on line 5  \r\nException: Always throw this error in E:\\sngrep\\index.php on line 5  \r\nCall Stack:  \r\n    0.0005     330680   1. {main}() E:\\sngrep\\index.php:0  \r\n```\r\n**2. Try, throw 和 catch**\r\n\r\n要避免上面这个致命错误，可以使用try catch捕获掉。\r\n处理处理程序应当包括：\r\n         Try - 使用异常的函数应该位于 \"try\" 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。\r\n       Throw - 这里规定如何触发异常。每一个 \"throw\" 必须对应至少一个 \"catch\"\r\n       Catch - \"catch\" 代码块会捕获异常，并创建一个包含异常信息的对象\r\n       抛出异常并捕获掉，可以继续执行后面的代码：\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\ntry {  \r\n    $error = \'Always throw this error\';  \r\n    throw new Exception($error);  \r\n  \r\n    // 从这里开始，tra 代码块内的代码将不会被执行  \r\n    echo \'Never executed\';  \r\n  \r\n} catch (Exception $e) {  \r\n    echo \'Caught exception: \',  $e->getMessage(),\'<br>\';  \r\n}  \r\n  \r\n// 继续执行  \r\necho \'Hello World\';  \r\n?>   \r\n```\r\n    在 \"try\" 代码块检测有有没有抛出“throw”异常，这里抛出了异常。\r\n    \"catch\" 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。\r\n    通过从这个 exception 对象调用 $e->getMessage()，输出来自该异常的错误消息\r\n    为了遵循“每个 throw 必须对应一个 catch”的原则，可以设置一个顶层的异常处理器来处理漏掉的错误。\r\n\r\n\r\n3. 扩展 PHP 内置的异常处理类\r\n    用户可以用自定义的异常处理类来扩展 PHP 内置的异常处理类。以下的代码说明了在内置的异常处理类中，哪些属性和方法在子类中是可访问和可继承的。（注：以下这段代码只为说明内置异常处理类的结构，它并不是一段有实际意义的可用代码。）\r\n\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\nclass Exception  \r\n{  \r\n    protected $message = \'Unknown exception\';   // 异常信息  \r\n    protected $code = 0;                        // 用户自定义异常代码  \r\n    protected $file;                            // 发生异常的文件名  \r\n    protected $line;                            // 发生异常的代码行号  \r\n  \r\n    function __construct($message = null, $code = 0);  \r\n  \r\n    final function getMessage();                // 返回异常信息  \r\n    final function getCode();                   // 返回异常代码  \r\n    final function getFile();                   // 返回发生异常的文件名  \r\n    final function getLine();                   // 返回发生异常的代码行号  \r\n    final function getTrace();                  // backtrace() 数组  \r\n    final function getTraceAsString();          // 已格成化成字符串的 getTrace() 信息  \r\n  \r\n    /* 可重载的方法 */  \r\n    function __toString();                       // 可输出的字符串  \r\n} \r\n``` \r\n       如果使用自定义的类来扩展内置异常处理类，并且要重新定义构造函数的话，建议同时调用 parent::__construct() 来检查所有的变量是否已被赋值。当对象要输出字符串的时候，可以重载__toString() 并自定义输出的样式。 \r\n\r\n     构建自定义异常处理类：\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\n  \r\n/** \r\n *  \r\n * 自定义一个异常处理类 \r\n */  \r\n  \r\nclass MyException extends Exception  \r\n{  \r\n    // 重定义构造器使 message 变为必须被指定的属性  \r\n    public function __construct($message, $code = 0) {  \r\n        // 自定义的代码  \r\n  \r\n        // 确保所有变量都被正确赋值  \r\n        parent::__construct($message, $code);  \r\n    }  \r\n  \r\n    // 自定义字符串输出的样式 */  \r\n    public function __toString() {  \r\n        return __CLASS__ . \": [{$this->code}]: {$this->message}\\n\";  \r\n    }  \r\n  \r\n    public function customFunction() {  \r\n        echo \"A Custom function for this type of exception\\n\";  \r\n    }  \r\n}  \r\n// 例子 1:抛出自定义异常,但没有默认的异常  \r\necho \' 例子 1\', \'<br>\';  \r\ntry {  \r\n    // 抛出自定义异常  \r\n    throw new MyException(\'1 is an invalid parameter\', 5);  \r\n} catch (MyException $e) {      // 捕获异常  \r\n    echo \"Caught my exception\\n\", $e;  \r\n    $e->customFunction();  \r\n} catch (Exception $e) {        // 被忽略  \r\n    echo \"Caught Default Exception\\n\", $e;  \r\n}  \r\n// 执行后续代码  \r\n// 例子 2： 抛出默认的异常  但没有自定义异常  \r\necho \'<br>\', \' 例子 2:\', \'<br>\';  \r\ntry {  \r\n     // 抛出默认的异常    \r\n    throw new Exception(\'2 isnt allowed as a parameter\', 6);  \r\n} catch (MyException $e) {      // 不能匹配异常的种类，被忽略  \r\n    echo \"Caught my exception\\n\", $e;  \r\n    $e->customFunction();  \r\n} catch (Exception $e) {// 捕获异常  \r\n    echo \"Caught Default Exception\\n\", $e;  \r\n}  \r\n// 执行后续代码  \r\n// 例子 3: 抛出自定义异常 ，使用默认异常类对象来捕获  \r\necho \'<br>\', \' 例子 3:\', \'<br>\';  \r\ntry {  \r\n     // 抛出自定义异常   \r\n    throw new MyException(\'3 isnt allowed as a parameter\', 6);  \r\n} catch (Exception $e) {        // 捕获异常  \r\n    echo \"Default Exception caught\\n\", $e;  \r\n}  \r\n  \r\n// 执行后续代码  \r\n// 例子 4  \r\necho \'<br>\', \' 例子 4:\', \'<br>\';  \r\ntry {  \r\n    echo \'No Exception \';  \r\n} catch (Exception $e) {        // 没有异常，被忽略  \r\n    echo \"Default Exception caught\\n\", $e;  \r\n}  \r\n```  \r\n// 执行后续代码  \r\n           MyException 类是作为旧的 exception 类的一个扩展来创建的。这样它就继承了旧类的所有属性和方法，我们可以使用 exception 类的方法，比如 getLine() 、 getFile() 以及 getMessage()。\r\n4. 嵌套异常处理\r\n\r\n    如果在内层 \"try\" 代码块中异常没有被捕获，则它将在外层级上查找 catch 代码块去捕获。\r\n```\r\n[php] view plain copy print?\r\ntry {  \r\n    try {  \r\n    throw new MyException(\'foo!\');  \r\n    } catch (MyException $e) {  \r\n        /* 重新抛出 rethrow it */  \r\n         $e->customFunction();  \r\n        throw $e;  \r\n        \r\n     }  \r\n} catch (Exception $e) {  \r\n        var_dump($e->getMessage());  \r\n}  \r\n```\r\n5. 设置顶层异常处理器 （Top Level Exception Handler）\r\n    set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。  \r\n\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\nfunction myException($exception)  \r\n{  \r\necho \"<b>Exception:</b> \" , $exception->getMessage();  \r\n}  \r\n  \r\nset_exception_handler(\'myException\');  \r\nthrow new Exception(\'Uncaught Exception occurred\');  \r\n     输出结果：\r\n\r\n[php] view plain copy print?\r\nException: Uncaught Exception occurred  \r\n```\r\n6. 异常的规则\r\n需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。\r\n每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。\r\n使用多个 catch 代码块可以捕获不同种类的异常。\r\n可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。\r\n简而言之：如果抛出了异常，就必须捕获它,否则程序终止执行。\r\n\r\n\r\n在我们实际开发中，错误及异常捕捉仅仅靠try{}catch()是远远不够的。\r\n```\r\nset_error_handler\r\n一般用于捕捉  E_NOTICE 、E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE\r\n不能捕捉：\r\nE_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR and E_COMPILE_WARNING。\r\n一般与trigger_error(\"...\", E_USER_ERROR)，配合使用。\r\n\r\n```\r\n\r\nPHP错误处理\r\n在实际开发中，错误及异常捕捉仅仅靠try{}catch()是远远不够的。\r\n所以引用以下几中函数。\r\na)   set_error_handler\r\n一般用于捕捉  E_NOTICE 、E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE\r\n不能捕捉：\r\nE_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR and E_COMPILE_WARNING。\r\n一般与trigger_error(\"...\", E_USER_ERROR)，配合使用。\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\n// we will do our own error handling  \r\nerror_reporting(0);  \r\nfunction userErrorHandler($errno, $errmsg, $filename, $linenum, $vars)  \r\n{  \r\n    // timestamp for the error entry      \r\n    $dt = date(\"Y-m-d H:i:s (T)\");      \r\n    // define an assoc array of error string      \r\n    // in reality the only entries we should      \r\n    // consider are E_WARNING, E_NOTICE, E_USER_ERROR,      \r\n    // E_USER_WARNING and E_USER_NOTICE      \r\n    $errortype = array (                  \r\n        E_ERROR              => \'Error\',                  \r\n        E_WARNING            => \'Warning\',                  \r\n        E_PARSE              => \'Parsing Error\',                  \r\n        E_NOTICE             => \'Notice\',                  \r\n        E_CORE_ERROR         => \'Core Error\',                  \r\n        E_CORE_WARNING       => \'Core Warning\',                  \r\n        E_COMPILE_ERROR      => \'Compile Error\',                  \r\n        E_COMPILE_WARNING    => \'Compile Warning\',                  \r\n        E_USER_ERROR         => \'User Error\',                  \r\n        E_USER_WARNING       => \'User Warning\',                  \r\n        E_USER_NOTICE        => \'User Notice\',                  \r\n        E_STRICT             => \'Runtime Notice\',                  \r\n        E_RECOVERABLE_ERROR  => \'Catchable Fatal Error\'                  \r\n    );      \r\n    // set of errors for which a var trace will be saved      \r\n    $user_errors = array(E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE);          \r\n    $err = \"<errorentry>\\n\";      \r\n    $err .= \"\\t<datetime>\" . $dt . \"</datetime>\\n\";      \r\n    $err .= \"\\t<errornum>\" . $errno . \"</errornum>\\n\";      \r\n    $err .= \"\\t<errortype>\" . $errortype[$errno] . \"</errortype>\\n\";      \r\n    $err .= \"\\t<errormsg>\" . $errmsg . \"</errormsg>\\n\";      \r\n    $err .= \"\\t<scriptname>\" . $filename . \"</scriptname>\\n\";      \r\n    $err .= \"\\t<scriptlinenum>\" . $linenum . \"</scriptlinenum>\\n\";      \r\n    if (in_array($errno, $user_errors)) {          \r\n        $err .= \"\\t<vartrace>\" . wddx_serialize_value($vars, \"Variables\") . \"</vartrace>\\n\";      \r\n    }      \r\n    $err .= \"</errorentry>\\n\\n\";  \r\n    echo $err;  \r\n}  \r\nfunction distance($vect1, $vect2) {      \r\n    if (!is_array($vect1) || !is_array($vect2)) {          \r\n        trigger_error(\"Incorrect parameters, arrays expected\", E_USER_ERROR);          \r\n        return NULL;      \r\n    }      \r\n    if (count($vect1) != count($vect2)) {          \r\n        trigger_error(\"Vectors need to be of the same size\", E_USER_ERROR);          \r\n        return NULL;      \r\n    }   \r\n    for ($i=0; $i<count($vect1); $i++) {          \r\n        $c1 = $vect1[$i]; $c2 = $vect2[$i];          \r\n        $d = 0.0;          \r\n        if (!is_numeric($c1)) {              \r\n        trigger_error(\"Coordinate $i in vector 1 is not a number, using zero\",E_USER_WARNING);              \r\n        $c1 = 0.0;          \r\n    }          \r\n    if (!is_numeric($c2)) {              \r\n        trigger_error(\"Coordinate $i in vector 2 is not a number, using zero\",E_USER_WARNING);              \r\n        $c2 = 0.0;          \r\n    }  \r\n    $d += $c2*$c2 - $c1*$c1;      \r\n    }      \r\n    return sqrt($d);  \r\n}  \r\n  \r\n$old_error_handle = set_error_handler(\"userErrorHandler\");  \r\n$t = I_AM_NOT_DEFINED;  //generates a warning  \r\n  \r\n// define some \"vectors\"  \r\n$a = array(2, 3, \"foo\");  \r\n$b = array(5.5, 4.3, -1.6);  \r\n$c = array(1, -3);  \r\n  \r\n//generate a user error  \r\n$t1 = distance($c,$b);  \r\n  \r\n// generate another user error  \r\n$t2 = distance($b, \"i am not an array\") . \"\\n\";  \r\n  \r\n// generate a warning  \r\n$t3 = distance($a, $b) . \"\\n\";  \r\n?>  \r\n```\r\nb)   set_exception_handler \r\n设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。 在 exception_handler 调用后异常会中止。 \r\n与throw new Exception(\'Uncaught Exception occurred\')，连用。\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\n// we will do our own error handling  \r\nerror_reporting(0);  \r\nfunction exceptHandle($errno, $errmsg, $filename, $linenum, $vars)  \r\n{  \r\n    // timestamp for the error entry      \r\n    $dt = date(\"Y-m-d H:i:s (T)\");      \r\n    // define an assoc array of error string      \r\n    // in reality the only entries we should      \r\n    // consider are E_WARNING, E_NOTICE, E_USER_ERROR,      \r\n    // E_USER_WARNING and E_USER_NOTICE      \r\n    $errortype = array (                  \r\n        E_ERROR              => \'Error\',                  \r\n        E_WARNING            => \'Warning\',                  \r\n        E_PARSE              => \'Parsing Error\',                  \r\n        E_NOTICE             => \'Notice\',                  \r\n        E_CORE_ERROR         => \'Core Error\',                  \r\n        E_CORE_WARNING       => \'Core Warning\',                  \r\n        E_COMPILE_ERROR      => \'Compile Error\',                  \r\n        E_COMPILE_WARNING    => \'Compile Warning\',                  \r\n        E_USER_ERROR         => \'User Error\',                  \r\n        E_USER_WARNING       => \'User Warning\',                  \r\n        E_USER_NOTICE        => \'User Notice\',                  \r\n        E_STRICT             => \'Runtime Notice\',                  \r\n        E_RECOVERABLE_ERROR  => \'Catchable Fatal Error\'                  \r\n    );      \r\n    // set of errors for which a var trace will be saved      \r\n    $err = \"<errorentry>\\n\";      \r\n    $err .= \"\\t<datetime>\" . $dt . \"</datetime>\\n\";      \r\n    $err .= \"\\t<errornum>\" . $errno . \"</errornum>\\n\";      \r\n    $err .= \"\\t<errortype>\" . $errortype[$errno] . \"</errortype>\\n\";      \r\n    $err .= \"\\t<errormsg>\" . $errmsg . \"</errormsg>\\n\";      \r\n    $err .= \"\\t<scriptname>\" . $filename . \"</scriptname>\\n\";      \r\n    $err .= \"\\t<scriptlinenum>\" . $linenum . \"</scriptlinenum>\\n\";      \r\n    if (1) {          \r\n        $err .= \"\\t<vartrace>\" . wddx_serialize_value($vars, \"Variables\") . \"</vartrace>\\n\";      \r\n    }      \r\n    $err .= \"</errorentry>\\n\\n\";  \r\n    echo $err;  \r\n}  \r\n$old_except_handle = set_exception_handler(\"exceptHandle\");  \r\n//$t = I_AM_NOT_DEFINED;    //generates a warning  \r\n$a;  \r\nthrow new Exception(\'Uncaught Exception occurred\');      \r\n?>  \r\n```\r\nc)   register_shutdown_function \r\n\r\n执行机制是：php把要调用的函数调入内存。当页面所有ＰＨＰ语句都执行完成时，再调用此函数。\r\n一般与trigger_error(\"...\", E_USER_ERROR)，配合使用。\r\n```\r\n[php] view plain copy print?\r\n<?php  \r\nerror_reporting(0);  \r\ndate_default_timezone_set(\'Asia/Shanghai\');  \r\nregister_shutdown_function(\'my_exception_handler\');  \r\n  \r\n$t = I_AM_NOT_DEFINED;  //generates a warning  \r\ntrigger_error(\"Vectors need to be of the same size\", E_USER_ERROR);       \r\n  \r\nfunction my_exception_handler()  \r\n{  \r\n    if($e = error_get_last()) {  \r\n    //$e[\'type\']对应php_error常量  \r\n    $message = \'\';  \r\n    $message .= \"出错信息:\\t\".$e[\'message\'].\"\\n\\n\";  \r\n    $message .= \"出错文件:\\t\".$e[\'file\'].\"\\n\\n\";  \r\n    $message .= \"出错行数:\\t\".$e[\'line\'].\"\\n\\n\";  \r\n    $message .= \"\\t\\t请工程师检查出现程序\".$e[\'file\'].\"出现错误的原因\\n\";  \r\n    $message .= \"\\t\\t希望能您早点解决故障出现的原因<br/>\";  \r\n    echo $message;  \r\n    //sendemail to  \r\n    }  \r\n}  \r\n?>  \r\n\r\n\r\n\r\n\r\n\r\n\r\n```\r\n2、简要说明错误处理：\r\n1）、使用指定的文件记录错误报告日志\r\n      使用指定的文件记录错误报告日志使用指定的文件记录错误报告日志使用指定的文件记录错误报告日志 如果使用自己指定的文件记录错误日志，一定要确保将这个文件存放在文档根目录之外，以减少遭到攻击的可能。并且该文件一定要让PHP脚本的执行用户（Web服务器进程所有者）具有写权限。假设在Linux操作系统中，将/usr/local/目录下的error.log文件作为错误日志文件，并设置Web服务器进程用户具有写的权限。然后在PHP的配置文件中，将error_log指令的值设置为这个错误日志文件的绝对路径。\r\n``` \r\n需要将php.ini中的配置指令做如下修改： \r\n[plain] view plain copy print?\r\nerror_reporting  =  E_ALL                   ;将会向PHP报告发生的每个错误     \r\ndisplay_errors = Off                        ;不显示满足上条 指令所定义规则的所有错误报告     \r\nlog_errors = On                             ;决定日志语句记录的位置     \r\nlog_errors_max_len = 1024                   ;设置每个日志项的最大长度     \r\nerror_log = /usr/local/error.log                ;指定产生的 错误报告写入的日志文件位置    \r\n```\r\n       PHP的配置文件按上面的方式设置完成以后，并重新启动Web服务器。这样，在执行PHP的任何脚本文件时，所产生的所有错误报告都不会在浏览器中显示，而会记录在自己指定的错误日志/usr/local/error.log中。此外，不仅可以记录满足error_reporting所定义规则的所有错误，而且还可以使用PHP中的error_log()函数，送出一个用户自定义的错误信息。\r\n该函数的原型如下所示：\r\n\r\n      1. bool error_log ( string message [, int message_type  [, string destination [, string extra_headers]]] )  \r\n       此函数会送出错误信息到Web服务器的错误日志文件、某个TCP服务器或到指定文件中。该函数执行成功则返回TRUE，失败则返回FALSE。第一个参数message 是必选项，即为要送出的错误信息。如果仅使用这一个参数，会按配置文件php.ini中所设置的位置处发送消息。第二个参数message_type为整数值：0表示送到操作系统的日志中；1则使用PHP的Mail()函数，发送信息到某E-mail处，第四个参数extra_headers亦会用到；2则将错误信息送到TCP 服务器中，此时第三个参数destination表示目的地IP及Port；3则将信息存到文件destination中。\r\n如果以登入Oracle数据库出现问题的处理为例，该函数的使用如下所示： \r\n```\r\n[plain] view plain copy print?\r\n<?php        \r\n    if(!Ora_Logon($username, $password)){       \r\n          error_log(\"Oracle数据库不可用!\", 0);        //将错误消息写入到操作系统日志中     \r\n     }     \r\n    if(!($foo=allocate_new_foo()){     \r\n         error_log(\"出现大麻烦了!\", 1, \". mydomain.com\");   //发送到管理员邮箱中     \r\n    }    \r\n     error_log(\"搞砸了!\",   2,   \"localhost:5000\");     //发送到本机对应5000端口的服务器中     \r\n     error_log(\"搞砸了!\",   3,   \"/usr/local/errors.log\");  //发送到指定的文件中     \r\n?>    \r\n ```\r\n2）、 错误信息记录到操作系统的日志里\r\n      错误信息记录到操作系统的日志里错误信息记录到操作系统的日志里错误信息记录到操作系统的日志里 错误报告也可以被记录到操作系统日志里，但不同的操作系统之间的日志管理有点区别。在Linux上错误语句将送往syslog，而在Windows上错误将发送到事件日志里。如果你不熟悉syslog，起码要知道它是基于UNIX的日志工具，它提供了一个API来记录与系统和应用程序执行有关的消息。Windows事件日志实际上与UNIX的syslog相同，这些日志通常可以通过事件查看器来查看。如果希望将错误报告写到操作系统的日志里，可以在配置文件中将error_log指令的值设置为syslog。\r\n具体需要在php.ini中修改的配置指令如下所示： \r\n```\r\n[plain] view plain copy print?\r\nerror_reporting  =  E_ALL                   ;将会向PHP报告发生的每个错误     \r\ndisplay_errors = Off                            ;不显示 满足上条指令所定义规则的所有错误报告     \r\nlog_errors = On                             ;决定日志语句记录的位置     \r\nlog_errors_max_len = 1024                   ;设置每个日志项的最大长度     \r\nerror_log = syslog                          ;指定产生的错误报告写入操作系统的日志里    \r\n```\r\n除了一般的错误输出之外，PHP还允许向系统syslog中发送定制的消息。虽然通过前面介绍的error_log()函数，也可以向syslog中发送定制的消息，但在PHP中为这个特性提供了需要一起使用的4个专用函数。\r\n分别介绍如下： \r\ndefine_syslog_variables() \r\n在使用openlog()、syslog及closelog()三个函数之前必须先调用该函数。因为在调用该函数时，它会根据现在的系统环境为下面三个函数初使用化一些必需的常量。 \r\nopenlog() \r\n打开一个和当前系统中日志器的连接，为向系统插入日志消息做好准备。并将提供的第一个字符串参数插入到每个日志消息中，该函数还需要指定两个将在日志上下文使用的参数，可以参考官方文档使用。 \r\n syslog()\r\n该函数向系统日志中发送一个定制消息。需要两个必选参数，第一个参数通过指定一个常量定制消息的优先级。例如LOG_WARNING表示一般的警告，LOG_EMERG表示严重地可以预示着系统崩溃的问题，一些其他的表示严重程度的常量可以参考官方文档使用。第二个参数则是向系统日志中发送的定制消息，需要提供一个消息字符串，也可以是PHP引擎在运行时提供的错误字符串。 \r\ncloselog()\r\n该函数在向系统日志中发送完成定制消息以后调用，关闭由openlog()函数打开的日志连接。 \r\n \r\n如果在配置文件中，已经开启向syslog发送定制消息的指令，就可以使用前面介绍的四个函数发送一个警告消息到系统日志中，并通过系统中的syslog解析工具，查看和分析由PHP程序发送的定制消息，如下所示： \r\n[plain] view plain copy print?\r\n```\r\n<?php  \r\n      define_syslog_variables();     \r\n     openlog(\"PHP5\", LOG_PID , LOG_USER);     \r\n     syslog(LOG_WARNING, \"警告报告向syslog中发送的演示， 警告时间：\".date(\"Y/m/d H:i:s\"));    \r\n     closelog();     \r\n```\r\n 以Windows系统为例，通过右击\"我的电脑\"选择管理选项，然后到系统工具菜单中，选择事件查看器，再找到应用程序选项，就可以看到我们自己定制的警告消息了。上面这段代码将在系统的syslog文件中，生成类似下面的一条信息，是事件的一部分： \r\n      1. PHP5[3084], 警告报告向syslog中发送的演示， 警告时间：2009/03/26 04:09:11.  \r\n使用指定的文件还是使用syslog记录错误日志，取决于你所在的Web服务器环境。如果你可以控制Web服务器，使用syslog是最理想的，因为你能利用syslog的解析工具来查看和分析日志。但如果你的网站在共享服务器的虚拟主机中运行，就只有使用单独的文本文件记录错误日志了。\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(47,'MyISAM','47',1470021240,1479290177,'<!--markdown-->  \r\n**MyISAM存储引擎**\r\n       MyISAM是 默认存储引擎。它基于更老的ISAM代码，但有很多有用的扩展。MyISAM存储引擎的一些特征：\r\n·      所有数据值先存储低字节。这使得数据机和操作系统分离。二进制轻便性的唯一要求是机器使用补码（如最近20年的机器有的一样）和IEEE浮点格式（在主流机器中也完全是主导的）。唯一不支持二进制兼容性的机器是嵌入式系统。这些系统有时使用特殊的处理器。\r\n·        先存储数据低字节并不严重地影响速度；数据行中的字节一般是未联合的，从一个方向读未联合的字节并不比从反向读更占用更多的资源。服务器上的获取列值的代码与其它代码相比并不显得时间紧。\r\n\r\n·        大文件（达63位文件长度）在支持大文件的文件系统和操作系统上被支持。\r\n\r\n·         当把删除和更新及插入混合的时候，动态尺寸的行更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。\r\n\r\n·         每个MyISAM表最大索引数是64。 这可以通过重新编译来改变。每个索引最大的列数是16个。\r\n\r\n·         最大的键长度是1000字节。这也可以通过编译来改变。对于键长度超过250字节的情况，一个超过1024字节的的键块被用上。\r\n\r\n·         BLOB和TEXT列可以被索引。\r\n\r\n·         NULL值被允许在索引的列中。这个占每个键的0-1个字节。\r\n\r\n·         所有数字键值以高字节为先被存储以允许一个更高地索引压缩。\r\n\r\n·        当记录以排好序的顺序插入（就像你使用一个AUTO_INCREMENT列之时），索引树被劈开以便高节点仅包含一个键。这改善了索引树的空间利用率。\r\n\r\n·         每表一个AUTO_INCREMEN列的内部处理。MyISAM为INSERT和UPDATE操作自动更新这一 列。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。（当AUTO_INCREMENT列被定义为多列索 引的最后一列，可以出现重使用从序列顶部删除的值的情况 ）。AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。\r\n\r\n·         如果数据文件中间的表没有自由块了，在其它线程从表读的同时，你可以INSERT新行到表中。（这被认识为并发操作 ）。自由块的出现是作为删除行的结果，或者是用比当前内容多的数据对动态长度行更新的结果。当所有自由块被用完（填满），未来的插入又变成并发。\r\n\r\n·         你可以把数据文件和索引文件放在不同目录，用DATA DIRECTORY和INDEX DIRECTORY选项CREATE TABLE以获得更高的速度，请参阅13.1.5节，“CREATE TABLE语法”。\r\n\r\n·         每个字符列可以又不同的字符集。\r\n\r\n·         在MyISAM索引文件里又一个标志，它表明表是否被正确关闭。如果用--myisam-recover选项启动mysqld，MyISAM表在打开得时候被自动检查，如果被表被不恰当地关闭，就修复表。\r\n\r\n·         如果你用--update-state选项运行myisamchk，它标注表为已检查。myisamchk --fast只检查那些没有这个标志的表。\r\n\r\n·         myisamchk --analyze为部分键存储统计信息，也为整个键存储统计信息。\r\n\r\n·         myisampack可以打包BLOB和VARCHAR列。\r\n\r\nMyISAM也支持下列特征：\r\n\r\n·         支持true VARCHAR类型；VARCHAR列以存储在2个字节中的长度来开始。\r\n\r\n·         有VARCHAR的表可以有固定或动态记录长度。\r\n\r\n·         VARCHAR和CHAR列可以多达64KB。\r\n\r\n·         一个被搞乱的已计算索引对可对UNIQUE来使用。这允许你在表内任何列的合并上有UNIQUE。（尽管如此，你不能在一个UNIQUE已计算索引上搜索）。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(48,'InnoDB','48',1470023400,1479290170,'<!--markdown-->**InnoDB存储引擎**\r\nInnoDB给MySQL提供 了具有提交，回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句提供一个Oracle风格一致的非 锁定读。这些特色增加 了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中行级锁定适合非常小的空间。InnoDB也支持FOREIGN KEY强制。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。\r\nInnoDB是为处理巨大数据量时的最大性能设计。它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。\r\n\r\nInnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。 InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在 分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。\r\n\r\nInnoDB默认地被包含在MySQL二进制分发中。Windows Essentials installer使InnoDB成为Windows上MySQL的 默认表。\r\n\r\nInnoDB被用来在众多需要高性能的大型数据库站点上产生。著名的Internet新闻站点Slashdot.org运行在 InnoDB上。Mytrix, Inc.在InnoDB上存储超过1TB的数据，还有一些其它站点在InnoDB上处理平均每秒800次插入/更新的负荷。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(49,'InnoDB和MyISAM的区别','49',1470023460,1479290161,'<!--markdown-->**区别概述：**\r\nMyISAM 是MySQL中默认的存储引擎，一般来说不是有太多人关心这个东西。决定使用什么样的存储引擎是一个很tricky的事情，但是还是值我们去研究一下，这里的文章只考虑 MyISAM 和InnoDB这两个，因为这两个是最常见的。\r\n\r\n下面先让我们回答一些问题：\r\n\r\n你的数据库有外键吗？\r\n你需要事务支持吗？\r\n你需要全文索引吗？\r\n你经常使用什么样的查询模式？\r\n你的数据有多大？\r\n \r\n\r\n思考上面这些问题可以让你找到合适的方向，但那并不是绝对的。如果你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，然而，我们其实并不会经常地去测试两百万行记录。所以，就算是慢一点，我们可以通过使用Sphinx从 InnoDB中获得全文索引。\r\n\r\n数据的大小，是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小 决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB 只需要几分钟。\r\n\r\n您操作数据库表的习惯可能也会是一个对性能影响很大的因素。比如： COUNT() 在 MyISAM 表中会非常快，而在InnoDB 表下可能会很痛苦。而主键查询则在InnoDB下会相当相当的快，但需要小心的是如果我们的主键太长了也会导致性能问题。大批的inserts 语句在MyISAM下会快一些，但是updates 在InnoDB 下会更快一些——尤其在并发量大的时候。\r\n\r\n所以，到底你检使用哪一个呢？根据经验来看，如果是一些小型的应用或项目，那么MyISAM 也许会更适合。当然，在大型的环境下使用MyISAM 也会有很大成功的时候，但却不总是这样的。如果你正在计划使用一个超大数据量的项目，而且需要事务处理或外键支持，那么你真的应该直接使用InnoDB方 式。但需要记住InnoDB 的表需要更多的内存和存储，转换100GB 的MyISAM 表到InnoDB 表可能会让你有非常坏的体验。\r\n\r\n区别总结：\r\n1.InnoDB不支持FULLTEXT类型的索引。\r\n2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。\r\n3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。\r\n4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。\r\n5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。\r\n\r\n另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”\r\n\r\n \r\n\r\n提升InnoDB性能的方法：\r\nMyISAM和InnoDB存储引擎性能差别并不是很大，针对InnoDB来说，影响性能的主要是 innodb_flush_log_at_trx_commit 这个选项，如果设置为1的话，那么每次插入数据的时候都会自动提交，导致性能急剧下降，应该是跟刷新日志有关系，设置为0效率能够看到明显提升，当然，同 样你可以SQL中提交“SET AUTOCOMMIT = 0”来设置达到好的性能。另外，还听说通过设置innodb_buffer_pool_size能够提升InnoDB的性能，但是我测试发现没有特别明显 的提升。\r\n\r\n基本上我们可以考虑使用InnoDB来替代我们的MyISAM引擎了，因为InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多，当然，相应的在my.cnf中的配置也是比较关键 的，良好的配置，能够有效的加速你的应用。\r\n任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(50,'Mysql 存储过程','50',1470303060,1479290154,'<!--markdown-->```\r\ncreate procedure p1()\r\nbegin\r\ndeclare i  int;\r\nset i=0;\r\nwhile i<10000 do\r\ninsert into user (usernam,password) values (\'user\',1111);\r\nset i=i+1;\r\nend while ;\r\nend\r\n```\r\n\r\n查看现有存储过程\r\n```\r\nshow procedure status \\G  管道符\r\n```\r\n删除存储过程\r\n```\r\ndrop procedure 存储过程name  \r\ndrop procedure p1;\r\n```\r\n创建存储过程\r\n```\r\ncreate procedure p1()  (可以传参数)\r\nbegin\r\n过程体select * from G；\r\nend\r\n```\r\n调用存储过程\r\n```\r\ncall p1()\r\n```\r\n带参数\r\n```\r\ncreate procedure p2( n int)  (参数  参数类型，参数 参数类型) 逗号隔开\r\nbegin\r\n    select * from G where num > n;\r\nend\r\n\r\n控制结构\r\ncreate procedure p3(n int,j char() )\r\nbegin\r\n    if j >= \'h\' then    \r\n        select * from G where num > n;\r\n    else\r\n        select * from G where num < n;\r\n    end if;\r\nend\r\n\r\n循环\r\ncreate procedure p4 (n smallint)\r\nbegin\r\n   declare i int; 声明变量\r\n   declare s int;\r\n   set i = 0;     赋值\r\n   set s = 0;\r\n   while n >= i do\r\n      set s = s + i;\r\n      set i = i + 1;\r\n   end while\r\n   select s;     \r\nend\r\n\r\n```\r\n```\r\n#if语句\r\nif 条件 then 语句\r\nelseif 条件 then 语句\r\nelse 语句\r\nend if\r\n#case语句\r\ncase 条件\r\nwhen 条件 then 语句\r\nwhen 条件 then 语句\r\nelse 语句\r\nend case\r\n#loop语句\r\nfn:loop\r\n语句\r\nend loop fn;\r\nleave fn #退出循环\r\n#while语句\r\nfn：while 条件 do\r\n语句\r\nend while fn\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(51,'Mysql delimiter','51',1470305820,1479290145,'<!--markdown-->其实就是告诉mysql解释器，该段命令是否已经结束了，mysql是否可以执行了。\r\n默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，\r\n```\r\ndelimiter //     -- 末尾不要符号 “;”\r\ndelimiter $      -- 末尾不要符号 “;”\r\ndelimiter ;      -- 末尾不要符号 “//”\r\n```\r\n例子：\r\n```\r\nmysql> delimiter //\r\n\r\nmysql> CREATE PROCEDURE simpleproc (OUT param1 INT)\r\n-> BEGIN\r\n-> SELECT COUNT(*) INTO param1 FROM t;\r\n-> END;\r\n-> //\r\nQuery OK, 0 rows affected (0.00 sec)\r\n\r\nmysql> delimiter ;\r\n\r\nmysql> CALL simpleproc(@a);\r\nQuery OK, 0 rows affected (0.00 sec)\r\n\r\nmysql> SELECT @a;\r\n+------+\r\n| @a |\r\n+------+\r\n| 3 |\r\n+------+\r\n1 row in set (0.00 sec) \r\n```\r\n[参考][1]\r\n\r\n\r\n  [1]: http://www.cnblogs.com/rootq/archive/2009/05/27/1490523.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(52,' Linux  命令历史 命令别名','52',1470387120,1479289332,'<!--markdown-->**history 命令历史**\r\n```\r\n！ + 命令编号\r\n\r\n！ + 最后一次命令开头\r\n```\r\n列子\r\n```\r\nvi \r\n\r\n!vi\r\n```\r\n**命令别名**\r\n别名重启失效\r\n~/.bashrc  别名存放位置（长期使用） \r\n```\r\nalias          查看系统别名\r\nalias  dd=‘ls’ 添加\r\nunalias dd     删除\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(53,'Linux 输出重定向','53',1470387900,1479289315,'<!--markdown-->```\r\nifconfig eth0 > net.txt\r\n\r\n>  覆盖重定向\r\n>> 追加重定向\r\n\r\n1> 正确重定向   默认“ > ”\r\n2> 错误重定向   1111 2> net.txt\r\n2>>错误追加\r\n\r\nvi.red.sh\r\n#!/bin/sh\r\n>& &>正确和错误追加\r\nbash red.sh 1>>net.txt  2>&1\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(54,'Linux 管道符','54',1470388980,1479289310,'<!--markdown-->```\r\nfree -m |grep -i mem  \r\n\r\nfree -m |grep -i mem|awk‘{prindt $1,$2\"\\n\"$3}’\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(56,'Linux 文件权限  acl 权限设置  ','56',1470389520,1479289305,'<!--markdown-->rwx  读写执行\r\n\r\nlinux 用户：\r\n1.u  所有者\r\n2.g  所属组\r\n3.o  其他\r\n5.a  所有用户\r\n```\r\nchmod  字母权限\r\nchmod  u+x file \r\nchmod  u-x，o-w file\r\n\r\nchmod  数组权限\r\nr   4\r\nw   2\r\nx   1\r\nchmod  755 file \r\n```\r\n```\r\nacl 权限分配\r\n\r\n设置文件权限\r\nsetfacl -m u:user1：rw root.txt\r\n查看文件权限\r\ngetfacl file\r\n删除文件权限\r\nsetfacl -x user：user4 root.txt\r\n清空文件权限\r\nsetfacl -b root.txt\r\n\r\n创建和删除文件权限：\r\n需要对目录设置acl权限\r\nsetfacl -m u:user4：rwx /mnt\r\n```\r\n\r\n**如何对目录以及子目录和文件设置acl权限**\r\n```\r\nsetfacl -m u：user4：rwx -R /mnt\r\n```\r\n**后期添加目录子文件权限继承**\r\n```\r\nsetfacl -m u：user4：rwx -R /mnt      （必须打两行）\r\nsetfacl -m d:u：user4：rwx -R /mnt    （d：默认）\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(57,'用户管理','57',1470390360,1479289292,'<!--markdown-->```\r\n查看用户  id user1\r\netc passwd 用户信息\r\netc group  用户组\r\netc shadow  密码\r\n```\r\n```\r\n用户添加\r\nuseradd   user1\r\npasswd user1  设置密码\r\n\r\n用户删除\r\nuserdel  -r  user1\r\n```\r\n用户组\r\n```\r\n新建组\r\ngroupadd  grp1\r\n删除组\r\ngroupdel  grp1\r\n\r\ngpasswd -a user1 root 添加用户入组\r\ngpasswd -d user1 root 删除用户出组\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(59,'Linux sudo','59',1470394860,1479289253,'<!--markdown-->设置用户对命令的执行权限\r\n1.设置\r\n```\r\nvisudo\r\nuser1  localhost=/usr/sbin/useradd\r\nuser1  localhost=/usr/sbin/userdel\r\n```\r\n2.使用有命令sudo授权命令\r\n```\r\nsudo /usr/sbin/useradd  user5\r\nsudo /usr/sbin/userdel -r user5\r\n```\r\n**3.无密码sudo授权**\r\n```\r\nvisudo\r\nuser1 ALL=NOPASSWD:/usr/bin/passwd\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(60,'Shell 脚本','60',1470395700,1479290137,'<!--markdown-->文件以.sh 结尾\r\ntest.sh\r\n```\r\n#!/bin/bash  制定解析器 bash\r\n#注释\r\n#test.sh\r\n#www.blog.hoyins.com\r\n```\r\n添加执行权限\r\n```\r\nchmod a+x test.sh\r\n```\r\n执行脚本方式\r\n```\r\n1.bash test.sh   \r\n#无需写解析器\r\n#不需要之前权限\r\n2../test/sh\r\n#需要写解析器\r\n#需要设置执行权限\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(61,'shell 变量','61',1470405000,1479290127,'<!--markdown-->**shell 变量种类**\r\n\r\n用户自定义：用户自己定义，修改和使用\r\n预定义变量：bash预定义的特殊变量，不能直接修改\r\n位置变量：通过命令给程序传递执行参数\r\n\r\n**定义新的变量**\r\n1.变量名要以英文字母或下划线开头，区分大小写\r\n2.格式： 变量名=变量值\r\n\r\n**查看变量的值**\r\n格式：\r\n```\r\necho $变量名\r\nname=\'user123\'\r\necho $name\r\necho \"my name is ${name}fg\"    ${变量名}   \r\n```\r\n\r\n**read**\r\n从键盘输入内容为变量赋值\r\nread [-p \"信息\"] 变量名\r\n```\r\nread -p “please input your name”  name\r\n\r\nread -p \"please input your name\" name\r\n\r\necho \"my name is $name\"\r\n```\r\n\r\n**结合不同的引号**\r\n双引号：允许通过$符号引用其他变量值\r\n单引号：禁止引用其他变量值 $视为普通字符\r\n反撇号``：将命令执行结果输出给变量\r\n```\r\nstr=`echo 123`\r\necho $str\r\n123\r\n\r\nstr = `date`  时间函数\r\necho \"today is:$str\"\r\n```\r\n**删除变量**\r\n```\r\nunset  变量名\r\nunset $name\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(62,'shell 位置变量','62',1470408120,1479290118,'<!--markdown-->$n ,1-9  最多九个参数\r\n```\r\n./test.sh  a b c d e f g h i j k l\r\n\r\n\r\ncase $1 in\r\n	start )\r\n		echo \"start......\"\r\n		;;	\r\n	stop )\r\n		echo \"stop......\"\r\n		;;	\r\nesac\r\n```\r\n位运算\r\necho $((1+2))\r\n\r\n**expr**\r\n\r\n计算整数表达式的运算结果\r\n格式：\r\n```\r\nexpr 变量1 运算符 变量2 ...[运算符 变量n]\r\n```\r\n```\r\nexpr常用运算符\r\n加法运算：+\r\n减法运算：-\r\n乘法运算：\\*  反斜杠转译\r\n除法运算：/\r\n取于运算：%  求模\r\n\r\nnum=`expr 4+2`  反引号赋值\r\necho num\r\n6\r\n\r\nnum =`expr 4\\*2`\r\necho num\r\n2\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(63,'shell 预定义变量','63',1470410220,1479290112,'<!--markdown-->$#:命令行中位置参数的个数   echo \"总共有${#}个参数\"\r\n$*:所有位置参数的内容    \r\n$?:上一条命令执行后返回的状态  0 表示正常 非0表示异常或出错\r\n$0:当前执行进程/程序名\r\n\r\n\r\n\r\n```\r\n$*:\r\n./test.sh  123\r\n#!/bin/bash\r\n#test.sh\r\ntot = 0\r\nfor i in $*; do\r\n    tot=$(($tot+$i))\r\ndone\r\necho $tot\r\n```\r\n```\r\n$?\r\nif [[ $? == 0 ]];then\r\n    echo \"成功\"\r\nelse\r\n    echo \"失败\"\r\nfi\r\n```\r\n```\r\necho \"当前脚本的参数有${#}个\"\r\necho \"当前脚本的参数是 $*\"\r\necho \"当前正在执行的脚本名称是： $0\"\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(66,'shell  echo -e -n 转译  ,read -p  颜色控制','66',1470412620,1479290105,'<!--markdown-->echo 空行\r\necho -e 转译\r\n```\r\necho -e \"my name is user123\\nmy name is user456\"\r\nmy name is user123\r\nmy name is user456\r\n```\r\necho -n 不换行\r\n```\r\necho -n \"please input your name\"\r\nread nane\r\necho \"my name is $name\"\r\n```\r\n键盘输入\r\n```\r\nread -p \"please input your name\" name\r\necho $name\r\n```\r\n字体颜色背景颜色\r\n```\r\necho -e \"\\033[32;40m my name is user123\\033[0m\"\r\n\\033[前景颜色;背景颜色m\r\n\\033[0m 恢复到系统默认颜色\r\n```\r\n```\r\n前景  黑 红 绿 棕 蓝 紫 青 白   0 恢复默认\r\n30 设置黑色前景\r\n31 设置红色前景\r\n32 设置绿色前景\r\n33 设置棕色前景\r\n34 设置蓝色前景\r\n35 设置紫色前景\r\n36 设置青色前景\r\n37 设置白色前景\r\n背景\r\n40 设置黑色背景\r\n41 设置红色背景\r\n42 设置绿色背景\r\n43 设置棕色背景\r\n44 设置蓝色背景\r\n45 设置紫色背景\r\n46 设置青色背景\r\n47 设置白色背景\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(70,'shell 文件测试','70',1470453960,1479290097,'<!--markdown-->**test命令**\r\n用途：测试特定的表达式是否成立，当条件成立时，命令执行后返回值为0，否则其他数值\r\n格式： test 条件表达式 [ 条件表达式 ]\r\n\r\n\r\n**echo $?  0成功 非0失败**\r\n```\r\n1.返回测试状态\r\n2.返回上一条命令是否执行成功 \r\n```\r\n**常见的测试类型**\r\n```\r\n测试文件状态\r\n字符串比较\r\n整数值比较\r\n逻辑测试\r\n```\r\n\r\n**测试文件**\r\n```\r\n格式：[ 操作符 文件或者目录 ]\r\n[ -d /etc/mnt] \r\n\r\n常用测试操作符\r\n\r\n-d：是否为目录\r\n-f：是否为文件\r\n-e：是否存在\r\n-r：是否可读\r\n-w：是否可写\r\n-x：是否可执行\r\n-L：是否为链接文件\r\n```\r\n```\r\nif [ -f ./file1 ]   //当前目录file1 文件是否存在\r\nthen\r\n    echo \'file1 is exists:\'\r\nelse\r\n    echo \'flie1 is not exists\'\r\n    touch file1 \r\nfi\r\n```\r\n**&&**\r\n```\r\n&& 链接符 左边为真 执行 为假 不执行\r\n[ -e /media/cdrom]&&echo \"yes\"   //如果成立则执行后一段代码\r\nyes  \r\n```\r\n```\r\nif [ -e /media/CentOS]\r\nthen\r\n    echo \"光盘已挂载\"\r\nelse\r\n    echo \"光盘未挂载\"\r\n    mount /dev/cdrom/media &>/dev/null   //重定向 黑洞设备\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(69,'cat tee nl ','69',1470414420,1479289269,'<!--markdown-->```\r\ncat /etc/passwd |more \r\ncat /etc/passwd |head -n  默认10前行\r\ncat /etc/passwd |tail -n  默认10后行\r\n```\r\n**cat**\r\n```\r\ncat<<x\r\nplease input your name\r\n    1)user1\r\n    2)user2\r\n    3)user3\r\nx\r\nheredoc标记 原样输出 \r\n```\r\n**tee 同时复制输出**\r\n```\r\n./test.sh |tee back.txt \r\n```\r\n**nl 行号**\r\n```\r\ncat /etc/passwd |head|nl\r\nnl /etc/passwd\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(74,'shell 字符串测试','74',1470456240,1479290085,'<!--markdown-->```\r\nwc-l 共获得几条数据\r\nwho | wc -l  当前登录用户   \r\n```\r\n```\r\nif[ `who|wc -l` -ge 1 ]\r\nthen\r\n    echo \"当前登录用户大于一人\"\r\nelse    \r\n    echo \"当前用户等于一人\"\r\nfi\r\n```\r\n```\r\nbootspace =`df -Th|grep \"boot\" |awk \'{print $6}\'|cut -d \"%\" -f1`\r\n\r\nif[ $bootspace -ge 14]\r\nthen\r\n    echo \'boot space greater than 14%\'|mail -s \"boot space warning\" root@localhost\r\nelse\r\n    echo \'boot space less than 14%\'\r\nfi\r\n```\r\n**字符串测试**\r\n```\r\n格式：\r\n[ 字符串1 = 字符串2]\r\n[ 字符串1 != 字符串2]\r\n[ -z 字符串]\r\n\r\n=:  字符串内容相同\r\n!=: 字符串内容不让，！号表示相反的意思\r\n-z: 字符串内容为空\r\n```\r\n```\r\nread -p ‘name’ name\r\nread -p ‘pass’ pass\r\n \r\nif[ $name = \'user\'] && [ $pass = \'123\']\r\nthen\r\n    echo \'s\'\r\nelse\r\n    echo \'d\'\r\nfi\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(73,'shell 整数值比较','73',1470455400,1479290091,'<!--markdown-->**整数值比较**\r\n```\r\n格式 [ 整数1 操作符 整数2 ]\r\n```\r\n**常用测试操作符**\r\n```\r\n-eq：等于(Equal)\r\n-ne：不等于(not equal)\r\n-gt: 大于(greater than)\r\n-lt: 小于(lesser than)\r\n-le: 小于或等于(lesser or equal)\r\n-ge: 大于或等于(greater or equal)\r\n```\r\n```\r\nage=30\r\nif [ $age -ge 18 ]\r\nthen\r\n    echo \"成年\"\r\nelse\r\n    echo \"未成年\"\r\nfi\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(76,'shell 逻辑测试','76',1470459600,1479290079,'<!--markdown-->**逻辑测试**\r\n```\r\n格式 [ 表达式1 ] 操作符 [ 表达式2 ] ...\r\n```\r\n常用操作符\r\n```\r\n-a 或 &&: 逻辑与 ，而且的意思\r\n#前面2个表达式都成立时整个测试结果才为真，否则假\r\n\r\n-o 或 ||: 逻辑或 ，或者的意思\r\n#操作符两边只是一个为真，结果为真。否则为假\r\n\r\n!:逻辑否\r\n#当指定的条件不成立，返回结果为真。\r\n```\r\n**逻辑开关**\r\n前面成立开关就关\r\n```\r\nls && echo “yes”  \r\n\r\nlll && echo “yes” \r\n\r\n[ $user != \'teacher\'] && echo \"not teacher\"  \r\nnot teacher\r\n\r\n[ $user = \'teacher\'] || echo \"not teacher\"\r\nnot teacher\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(79,'shell case','79',1470463320,1479290065,'<!--markdown-->```\r\nweek= `date +%w`  //日期格式化\r\ncase $week in\r\n	1)\r\n	echo \"周一\"\r\n	;;\r\n	2)		\r\n	echo \"周二\"\r\n	;;\r\n	3)\r\n	echo \"周三\"\r\n	;;\r\n	*)\r\n	echo \"其他\"\r\n	;;\r\nesac\r\n```\r\n\r\n```\r\nread -p \"please press one key\" key\r\n\r\ncase $key in\r\n	[a-z]|[A-Z])\r\n		echo \"字母\"\r\n	;;\r\n	[0-9])\r\n		echo \"数字\"\r\n	;;	\r\nesac\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(80,'shell while','80',1470465960,1479290059,'<!--markdown-->```\r\n#!/bin/bash\r\n#test.sh\r\ni=0\r\n\r\nwhile [ $i -lt 10 ];\r\n do\r\n 	if [ $(($i%2)) -eq 0 ];then\r\n 		echo -e \"\\033[33;40m${i}\\033[0m\"\r\n 	else\r\n 		echo $i\r\n 	fi	\r\n 	i=$(($i+1))\r\ndone\r\n```\r\n\r\n```\r\nwhile [ $i -lt 10 ];\r\n do\r\n 	useradd user$i  添加用户\r\n 	i=$(($i+1))\r\ndone\r\n\r\n--stdin  标准输入\r\n\r\nwhile [ $i -lt 10 ];\r\n do\r\n 	echo \"123\"|passwd --stdin user$i   设置密码\r\n 	i=$(($i+1))\r\ndone\r\n\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(78,'shell  if else elif','78',1470462600,1479290072,'<!--markdown-->```\r\nread -p \"age\" age\r\n\r\nif [ $age -lt 18 ];then\r\n    echo \'未成年\'\r\nelif [ $age -eq 18 ];then\r\n    echo \'刚满18\'\r\nelse\r\n    echo \'已成年\'\r\nfi\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(81,'shell for  in','81',1470467280,1479290051,'<!--markdown-->```\r\n\r\nfor i in user0 user1 user2 user3\r\ndo\r\n	echo $i\r\ndone\r\n\r\nroot@ubuntu-512mb-sgp1-01:/# ./test.sh \r\nuser0\r\nuser1\r\nuser2\r\nuser3\r\n\r\n```\r\n```\r\n\r\nfor i in `cat user.txt`\r\ndo\r\n	echo $i\r\n	useradd $i\r\n	echo 123|passwd --stdin $i\r\ndone\r\n\r\n```\r\n```\r\nfor i in `cat /etc/passwd|awk -F: \'{print $1}\'`\r\ndo\r\n	echo $i\r\n	echo $i >> user.txt\r\ndone\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(83,'shell for (())','83',1470468480,1479289975,'<!--markdown-->break \r\ncontinue\r\n```\r\nfor((i=0;i<10;i++))\r\ndo\r\n    echo $i\r\n    if[ $i -eq 5 ] ;then\r\n            break        终止\r\n            continue     跳入下一循环   \r\n    fi\r\ndone\r\n```\r\n\r\n```\r\nfor((i=0;i<10;i++))\r\ndo\r\n    if [ $i -eq 5 ] ;then\r\n         continue     \r\n    else\r\n         echo $i\r\n    fi\r\ndone\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(87,'shell shift','87',1470469920,1479289968,'<!--markdown-->参数左移 并删除首个参数\r\n```\r\ntot=0\r\nwhile [ $# -gt 0 ];\r\n do\r\n	tot=$(($tot+$1))\r\n	shift\r\ndone\r\necho $tot\r\n```\r\n```\r\nroot@ubuntu-512mb-sgp1-01:/# ./test.sh 1111 11111 1111\r\n13333\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(88,'shell 函数','88',1470470460,1479289963,'<!--markdown-->```\r\nfunction add(){\r\n	num=$1\r\n	tot=0\r\n	for (( i = 0; i <= $num; i++ ));\r\n	do\r\n		tot=$(($tot+$i))\r\n	done\r\n		echo $tot\r\n}\r\n\r\nadd  100\r\nadd  10\r\n```\r\n\r\n```\r\nfunction add(){\r\n	echo $(($1+$2))\r\n}\r\n\r\nadd  100 10\r\n```\r\n```\r\nfunction add2(){\r\n	echo `expr $1 + $2`\r\n}\r\n\r\nadd2  10000   1\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(89,'shell mysql','89',1470473520,1479289957,'<!--markdown-->```\r\n#!/bin/bash\r\n#mysql.sh\r\nmysql=`which mysql`\r\nmysql=$mysql\" -uroot -p123456\"\r\n\r\necho $mysql\r\n创建库\r\nsql=\"create database test2\"\r\n$mysql -e \"$sql\"\r\n创建表\r\nsql=\"create table test2.user(\r\n	id int unsigned auto_increment primary key,\r\n	username varchar(50),\r\n	password varchar(50)\r\n)\"\r\n$mysql -e \"$sql\"\r\n查看所有库\r\nsql=\'show databases\'\r\n$mysql -e \"$sql\"\r\nsql=\'desc test2.user\'\r\n$mysql -e \"$sql\"\r\n\r\n#插入\r\nsql=\"insert into test2.user(username,password) values(\'user1\',\'123\') \"\r\n$mysql -e \"$sql\"\r\n\r\n#查看表\r\nsql=\"select * from test2.user\"\r\n$mysql -e \"$sql\"\r\n\r\n#updata\r\nsql=\"update  test2.user set username=\'user11111\' where id =1\"\r\n$mysql -e \"$sql\"\r\n\r\n#查看表\r\nsql=\"select * from test2.user\"\r\n$mysql -e \"$sql\"\r\n\r\n#删除\r\nsql=\"delete from test2.user where id=5\"\r\n$mysql -e \"$sql\"\r\n#查看表\r\nsql=\"select * from test2.user\"\r\n$mysql -e \"$sql\"\r\n\r\n#查看表结构\r\nsql=\"desc test2.user\"\r\n$mysql -e \"$sql\"\r\n\r\n#删除表\r\nsql=\"drop table test2.user\"\r\n$mysql -e \"$sql\"\r\n\r\n#查看库里的表\r\nsql=\"show tables from test2\"\r\n$mysql -e \"$sql\"\r\n\r\n#删除库\r\nsql=\"drop database test2\"\r\n$mysql -e \"$sql\"\r\n\r\n#查看所有表\r\nsql=\"show databases\"\r\n$mysql -e \"$sql\"\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(91,'shell mysql 增删改查','91',1470478260,1479289950,'<!--markdown-->```\r\n#!/bin/bash\r\n#mysqi.sh\r\nmysql=`which mysql`\r\n\r\nmysql=$mysql\' -uroot -p123456\'\r\n\r\n#sql=\"create database test\"\r\n\r\n#sql=\"create table test.user(\r\n#		id int unsigned auto_increment primary key,\r\n#		usernam varchar(50),\r\n#		password varchar(50)\r\n#)\"\r\n\r\n#sql=\"insert into test.user(usernam,password) values (\'user111\',123)\"\r\n#$mysql -e  \"$sql\"\r\n\r\n#sql=\"update test.user set usernam=\'aaaa\' where id=1\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"delete from test.user where id=4\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\ncase $1 in\r\n	select)\r\n		sql=\"select * from test.user\"\r\n	;;\r\n	insert)\r\n		sql=\"insert into test.user (usernam,password) values (\'$2\',\'$3\')\"\r\n	;;\r\n	update)\r\n		sql=\"update test.user set $2\"\r\n		sql=$sql\"=\'$3\' where id = $4\"\r\n	;;\r\n	delete)\r\n		sql=\"delete from test.user where id =$2\"\r\n	;;	\r\n	*)\r\n		sql=\"select * from test.user\"\r\n	;;\r\nesac\r\n\r\n$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(92,'shell mysql 增删改查','92',1470478260,1479289942,'<!--markdown-->```\r\n#!/bin/bash\r\n#mysqi.sh\r\nmysql=`which mysql`\r\n\r\nmysql=$mysql\' -uroot -p123456\'\r\n\r\n#sql=\"create database test\"\r\n\r\n#sql=\"create table test.user(\r\n#		id int unsigned auto_increment primary key,\r\n#		usernam varchar(50),\r\n#		password varchar(50)\r\n#)\"\r\n\r\n#sql=\"insert into test.user(usernam,password) values (\'user111\',123)\"\r\n#$mysql -e  \"$sql\"\r\n\r\n#sql=\"update test.user set usernam=\'aaaa\' where id=1\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"delete from test.user where id=4\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\ncase $1 in\r\n	select)\r\n		sql=\"select * from test.user\"\r\n	;;\r\n	insert)\r\n		sql=\"insert into test.user (usernam,password) values (\'$2\',\'$3\')\"\r\n	;;\r\n	update)\r\n		sql=\"update test.user set $2\"\r\n		sql=$sql\"=\'$3\' where id = $4\"\r\n	;;\r\n	delete)\r\n		sql=\"delete from test.user where id =$2\"\r\n	;;	\r\n	*)\r\n		sql=\"select * from test.user\"\r\n	;;\r\nesac\r\n\r\n$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(93,'shell mysql 增删改查','93',1470478800,1479289937,'<!--markdown-->```\r\n#!/bin/bash\r\n#mysqi.sh\r\n\r\nmysql -udkart -pdkart db_dkart -e \'delete from data_account\'\r\n\r\nmysql=`which mysql`\r\n\r\nmysql=$mysql\' -uroot -p123456\'\r\n\r\n#sql=\"create database test\"\r\n\r\n#sql=\"create table test.user(\r\n#		id int unsigned auto_increment primary key,\r\n#		usernam varchar(50),\r\n#		password varchar(50)\r\n#)\"\r\n\r\n#sql=\"insert into test.user(usernam,password) values (\'user111\',123)\"\r\n#$mysql -e  \"$sql\"\r\n\r\n#sql=\"update test.user set usernam=\'aaaa\' where id=1\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"delete from test.user where id=4\"\r\n#$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n\r\ncase $1 in\r\n	select)\r\n		sql=\"select * from test.user\"\r\n	;;\r\n	insert)\r\n		sql=\"insert into test.user (usernam,password) values (\'$2\',\'$3\')\"\r\n	;;\r\n	update)\r\n		sql=\"update test.user set $2\"\r\n		sql=$sql\"=\'$3\' where id = $4\"\r\n	;;\r\n	delete)\r\n		sql=\"delete from test.user where id =$2\"\r\n	;;	\r\n	*)\r\n		sql=\"select * from test.user\"\r\n	;;\r\nesac\r\n\r\n$mysql -e \"$sql\"\r\n\r\n#sql=\"select * from test.user\"\r\n#$mysql -e \"$sql\"\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(94,'shell 文本操作 find','94',1470484680,1479289912,'<!--markdown-->**find 查找命令**\r\n```\r\n1.find . -name \"*.txt\"\r\n在当前目录下找以txt结尾的文件\r\n```\r\n```\r\n2.find . -name \"[a-z]*\"\r\n在当前目录下找以所有字母开头的文件\r\n```\r\n```\r\n3.find /etc -name \"host\"\r\n在/etc 目录下找以host开头的文件\r\n```\r\n```\r\n4.find  / -prem 755  //当前目录可以省略目录路径\r\n权限\r\n```\r\n```\r\n5.find /etc -type f  文件\r\n  find /etc -type d  目录\r\n  find /etc -type l  链接文件\r\n查找文件类型\r\n```\r\n```\r\n6.find -user root\r\n在当前目录下找所属主root的文件\r\n```\r\n```\r\n7.find /var -mtime -5\r\n在/var下找更改时间在5天以内的文件\r\n```\r\n```\r\n8.find /var -mtime +3\r\n在/var下找更改时间在3天以前的文件\r\n```\r\n```\r\n9.find  . -size +1000000c\r\n在当前目录下查找文件大于1M的文件\r\n```\r\n\r\n**xargs**\r\n```\r\n10.find -perm 775 |xargs chmod 700\r\n当前目录下所有权限为775 并更改为700\r\n\r\n11.find . -type f |xargs ls -l\r\n查找文件并查看详细信息\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(96,'shell grep  正则','96',1470487260,1479289926,'<!--markdown-->grep \'linux\' file\r\n\r\ngrep -c \'linux\' file\r\n有多少行包含linux\r\ngrep -n \'linux\' file\r\n输出行号 -n\r\ngrep -i \'linux\' file\r\n忽略大小写 -i\r\ngrep -v \'linux\' file\r\n过滤不包含 linux\r\n\r\ngrep -vin \'linux\' file\r\n\r\n1. ^linux\r\n以linux开头\r\ngrep -Eni \'^linux\' file\r\n\r\n\r\n2. php$\r\n以php结尾\r\ngrep -Eni \'php$\' file\r\n\r\n3. .\r\n任意单个字符 \r\n\r\n4. .*\r\n 0或者多个\r\n\r\n5. .+\r\n多个字符不包含0\r\n\r\n6. [0-9a-z]\r\n匹配[]内任意一个字符\r\n\r\n7(linux)+\r\n出现多次linux\r\n\r\n8.(web){2}  web(2,4)\r\n至少出现2次以上web\r\n\r\n9. ^$\r\n空行 没有字符\r\n\r\n10. \\\r\n转译 \r\n\r\n\r\n\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(97,'sed 行定位 ','97',1470490620,1479289226,'<!--markdown-->nl 行号\r\n\r\n\r\n1.sed -n \'2\'p file\r\n只打印第二行，不打印其他行\r\n\r\n2.sed -n \'1,4\'p file\r\n从第一到第四行\r\n\r\n  sed -n  \'1./bash/\'p file\r\n  sed -n  \'/bash,$\'p file\r\n\r\n3.sed \'1,2\' d file\r\n删除\r\n\r\n\r\ndf | sed -n \'3\'p |awk \'{print $4}\'',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(98,'uniq 行定位  sort  split','98',1470491340,1479289215,'<!--markdown-->**uniq**\r\n```\r\n1. uniq -c file   //count\r\n统计重复次数  挨一起的\r\n\r\n2. uniq -d file\r\n打印重复行 一次不算\r\n```\r\n**sort**\r\n```\r\nsort file   //正序\r\n\r\nsort -r file  //倒叙\r\n\r\nsort -t： -k1   //根据列排序  -t：制定分隔符\r\n\r\nsort -t： -k1 -r //列倒叙\r\n```\r\n**split**\r\n```\r\nsplit -5 file stp //文件分割 文件每5行分割成单个文件\r\n```\r\n```\r\nroot@ubuntu-512mb-sgp1-01:/test# split -10 /etc/passwd spt\r\nroot@ubuntu-512mb-sgp1-01:/test# ll\r\ntotal 36\r\ndrwxr-xr-x  2 root root 4096 Aug  6 10:06 ./\r\ndrwxr-xr-x 23 root root 4096 Aug  6 08:37 ../\r\n-rw-r--r--  1 root root   57 Aug  6 08:39 file\r\n-rw-r--r--  1 root root  424 Aug  6 10:06 sptaa\r\n-rw-r--r--  1 root root  532 Aug  6 10:06 sptab\r\n-rw-r--r--  1 root root  411 Aug  6 10:06 sptac\r\n\r\nroot@ubuntu-512mb-sgp1-01:/test# split -10 /etc/passwd spt\r\nroot@ubuntu-512mb-sgp1-01:/test# ll\r\ntotal 36\r\ndrwxr-xr-x  2 root root 4096 Aug  6 10:06 ./\r\ndrwxr-xr-x 23 root root 4096 Aug  6 08:37 ../\r\n-rw-r--r--  1 root root   57 Aug  6 08:39 file\r\n-rw-r--r--  1 root root  424 Aug  6 10:06 sptaa\r\n-rw-r--r--  1 root root  532 Aug  6 10:06 sptab\r\n-rw-r--r--  1 root root  411 Aug  6 10:06 sptac\r\nroot@ubuntu-512mb-sgp1-01:/test# split -10 /etc/passwd spt\r\nroot@ubuntu-512mb-sgp1-01:/test# ll\r\ntotal 36\r\ndrwxr-xr-x  2 root root 4096 Aug  6 10:06 ./\r\ndrwxr-xr-x 23 root root 4096 Aug  6 08:37 ../\r\n-rw-r--r--  1 root root   57 Aug  6 08:39 file\r\n-rw-r--r--  1 root root  424 Aug  6 10:06 sptaa\r\n-rw-r--r--  1 root root  532 Aug  6 10:06 sptab\r\n-rw-r--r--  1 root root  411 Aug  6 10:06 sptac\r\n\r\n```\r\n```\r\ncat access.log|awk \'{print $1}\'|sort|uniq -c\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(100,'linux 系统','100',1470497940,1479289198,'<!--markdown-->一.初始化阶段\r\n1.grup引导界面\r\n2.识别硬件\r\n3.初始化驱动\r\n\r\n二.加载 /etc/rc.d/rc.sysinit 系统初始化脚本\r\n4.进入欢迎界面\r\n5.设置时钟\r\n6.设置主机名\r\n7.挂载文件系统\r\n8.挂载光驱\r\n9.进入3级别\r\n10.启动虚拟内存\r\n11.设置磁盘阵列\r\n\r\n三.加载/etc/rc.d/rc进程管理脚本\r\n12.设置防火墙\r\n\r\n13.检测硬件变化\r\n14.启动网络服务\r\n15.启动三级别下允许启动的进程(比如 sshd)\r\n16.进入登录界面',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(102,'服务器优化技术','102',1470549900,1479289903,'<!--markdown-->1.dns 负载均衡\r\n2.lvs 负载均衡器\r\n3.集群服务器\r\n4.web服务器 nginx\r\n5.php 静态缓存(tp smarty)\r\n6.文件数据缓存(tp)\r\n7.内存数据缓存(memcache redis)\r\n8.数据库索引\r\n9.主从风流\r\n10.分表分区\r\n11.磁盘阵列',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(103,'如何进行防sql 注入','103',1470550500,1479289876,'<!--markdown-->1.表单尽量用post，表单判断控制走get\r\nget post速度快\r\nget 1-2M \r\nget 明文\r\n\r\n\r\n2.$_SERVER[HTTP_PEFERER]判断提交者的源头\r\n$path=$_SERVER[HTTP_PERFERER];\r\n$arr = parse_url($path);\r\n$arr[host]\r\n$arr[path]\r\n\r\n\r\n$ip =$_server[http]\r\n\r\n3.开启addslashes.在‘ . ’.\\头加入\\\r\n\r\n4.密码设置md5\r\n\r\n5.服务器本身安全',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(104,'防止盗链','104',1470552780,1479289871,'<!--markdown-->1.服务器防止\r\napache nginx 做rewrite 基于源来做判断阻止盗链\r\n\r\n2.代码防止\r\n$_SERVER[HTTP_PERFERER]',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(105,'url 提取','105',1470554100,1479289861,'<!--markdown-->```\r\n$arr=parse_url(\'http://127.0.0.1/hoyin/1.php?id=1\');\r\n\r\n$arr =basename($arr[\'path\']);\r\n\r\n$arr =explode(\'.\',$arr);\r\n\r\necho \'<pre>\';\r\nprint_r($arr);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(106,'请简述数据库设计的范式及应用。','106',1470554820,1479289855,'<!--markdown-->一般第3范式就足以，用于表结构的优化，这样做既可以避免应用程序过于复杂同时也避免了SQL语句过于庞大所造成系统效率低下。\r\nANSWER：\r\n第一范式：若关系模式R的每一个属性是不可再分解的，再属于第一范式。\r\n第二范式：若R属于第一范式，且所有的非码属性都完全函数依赖于码属性，则为第二范式。\r\n第三范式：若R属于第二范式，且所有的非码属性没有一个是传递函数依赖于候选码，则属于第三范式。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(316,'webstorm 新增代码块','@316',1479286200,1479304801,'<!--markdown-->```\r\nsetting  -->  editor  -->  Live Templates\r\n右上角的加号，Live Templates\r\n\r\nAbbreviation：代码缩写\r\nDescription:  内容描述\r\nTemplate Text：\r\n代码块\r\n\r\n\r\nAbbreviation：if\r\nDescription:  if\r\nTemplate Text：\r\nif($PARAM$){\r\n\r\n}\r\n\r\n$PARAM$:代码补全后光标所在位置\r\nExpand with:补全键\r\nNo applicable contexts yer. Define  点击 Define ，关联到文件类型\r\n',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',309),(317,'Linux 查看端口占用情况','317',1479817164,1479817277,'<!--markdown-->```\r\n使用命令：netstat –apn\r\n\r\n查看所有的进程和端口使用情况。发现下面的进程列表，其中最后一栏是PID/Program name  \r\n\r\n进一步使用命令：ps -aux | grep java，或者直接：ps -aux | grep pid 查看 \r\n\r\n\r\n直接使用         netstat   -anp   |   grep  portno\r\n即：            netstat   –apn   |   grep  8080',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(108,'冒泡','108',1470571320,1479289848,'<!--markdown-->```\r\n\r\n\r\nfunction mysort($arr){\r\n	for ($i=0; $i < count($arr)-1 ; $i++) { \r\n		# code...\r\n		for($j=0;$j<count($arr)-1-$i;$j++)\r\n\r\n			if($arr[$j] > $arr[$j + 1]){\r\n\r\n				$tmp = $arr[$j];\r\n				$arr[$j]=$arr[$j+1];\r\n				$arr[$j+1]=$tmp;\r\n\r\n			}\r\n\r\n	}\r\n\r\n	return $arr;\r\n}\r\n$arr=array(1,2,3,555,44,5554,55555);\r\n\r\n$arr =mysort($arr);\r\necho \'<pre>\';\r\nprint_r($arr);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(110,'目录遍历','110',1470574620,1479289831,'<!--markdown-->```\r\n$dir =\'html\';\r\n\r\nfunction dirlist($dir){\r\n\r\n	$arr=scandir($dir);\r\n	foreach ($arr as $val) {\r\n\r\n		if($val != \'.\' && $val !=\'..\'){\r\n			$path=$dir.\'/\'.$val;\r\n			if(is_dir($path)){\r\n				dirlist($path);\r\n			}else{\r\n				echo $path.\'<br>\';\r\n			}\r\n		}		\r\n	}\r\n\r\n}\r\n\r\ndirlist($dir);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(111,'目录遍历','111',1470574620,1479289841,'<!--markdown-->```\r\n$dir =\'html\';\r\n\r\nfunction dirlist($dir){\r\n\r\n	$arr=scandir($dir);\r\n	foreach ($arr as $val) {\r\n\r\n		if($val != \'.\' && $val !=\'..\'){\r\n			$path=$dir.\'/\'.$val;\r\n			if(is_dir($path)){\r\n				dirlist($path);\r\n			}else{\r\n				echo $path.\'<br>\';\r\n			}\r\n		}		\r\n	}\r\n\r\n}\r\n\r\ndirlist($dir);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(114,'node.js','114',1470972420,1479289181,'<!--markdown-->```\r\n当前版本\r\n$node -v  vision\r\n``` \r\n```\r\nvim hello.js\r\nconsole.log(\'hello world\');\r\n```\r\n```\r\nnode \r\nconsole.log(\'hello world\');\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(115,'javascript假值','115',1470986640,1479289176,'<!--markdown-->```\r\n1.false\r\n2.null\r\n3.undefined\r\n4.空字符串 \' \'\r\n5.数字0\r\n6.数字 NsN\r\n```\r\n**其他所有的值都被当作真，包括 true 字符串 \"false\",以及所有对象。**\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(117,'javascript 运算符','117',1470987120,1479289172,'<!--markdown-->**优先级：**\r\n```\r\n.  []  ()                属性存取及函数调用\r\ndelete new  typeof  +  -  ！    一元运算符\r\n*   /  %                 乘法 除法取模\r\n+  1                     加法/连接 减法\r\n>=  <= ><                不等式运算\r\n=== !==                  等式运算符\r\n&&                       逻辑与\r\n||                       逻辑或\r\n？：                      三元\r\n\r\n\r\n\r\n2 + 3 * 5 === 17\r\n( 2 + 3 ) * 5 === 25\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(118,'javaScript 类型','118',1470987900,1479289167,'<!--markdown-->数字\r\n字符串\r\n布尔值 true false\r\nnull\r\nundefined\r\nobject\r\n\r\njavascript中的是可变的键控集合(keyed collections)\r\n数组是对象，函数是对象，正则是对象。\r\n对象是属性的容器，其中的每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串，属性值可以是出undefined值之外的任何值。\r\njavascript的对象是无类别(class-free)的，对新属性的名字和值没有约束。对象适合用于收集和管理数据。对象可以包含其他对象。所有他们可以容易的表示成树形或图形结构。\r\njavascript包括一个原型链特性，允许对象继承另一个对象的属性。正确的使用它讷讷感减少对象初始化的时间和内存的消耗。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(113,'mysql 分区','113',1470587820,1479289823,'<!--markdown-->```\r\ncreate table t1(\r\nid int \r\n)\r\nPARTITION BY HASH(id)\r\nPARTITIONS  4;\r\n```\r\n```\r\ncreate table t2(\r\ndate int\r\n)\r\npartition by range(YEAR(date))(\r\npartiton p1 values less than (2011),\r\npartiton p2 values less than (2012),\r\npartiton p3 values less than (2013)\r\n);\r\n```\r\n```\r\ncreate table t2(\r\nid int\r\n)\r\npartition by list(id)(\r\npartiton p1 values,\r\npartiton p2 values in (1,2,3),\r\npartiton p3 values in(5,6,7)\r\n);\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(119,'javascript 对象字面量','119',1470988500,1479289163,'<!--markdown-->**在{} 里的json，逗号分隔**\r\n```\r\nvar empty_object={};\r\nvar stoge={\r\n    \"first-name\":\"hoyin\",\r\n    \"last-name\":\"haoran\"\r\n};\r\n```\r\n```\r\nvar stoge={\r\n    first-name:\"hoyin\",\r\n    last-name:\"shen\",\r\n    info:{\r\n        age:\"27\",\r\n        six:\"man\",\r\n        addr:\"xxxxxxxxxxxxxxxxxx\"\r\n    }\r\n};\r\n```\r\n\r\n**检索**\r\n```\r\nstoge[\"first-name\"]  //\"hoyin\"\r\n\r\nstoge.info.six       //\"man\"\r\n```\r\n\r\n**不存在 返回值 undefined**\r\n```\r\nstoge[\"middle-name\"] //undefined\r\nstoge.status         //undefined\r\n```\r\n\r\n**运算符 填充 默认值**\r\n```\r\nvar middle = stoge[\"middle-name\"] ||\"(none)\";\r\nvar status = stoge.status || \"unknown\";\r\n```\r\n\r\n**&& 避免错误**\r\n```\r\nstoge.status                               //undefined\r\nstoge.stats.model                          //throw \"typeError\"\r\nstoge.status && stoge.status.model         //undefined\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(120,'javascript 引用','120',1470989520,1479289158,'<!--markdown-->**对象通过引用来传递。它们永远不会被拷贝**\r\n```\r\nvar x = stooge;\r\nx.nickname = \'hoyin\';\r\nvar nick = stooge.nickname;\r\n        //因为 x 和 stooge 是指向同一个对象的引用\r\n\r\nvar a ={}, b={},c={};\r\n        //abc每个都引用一个不同的空对象\r\na = b =c {};\r\n        //abc引用同一个空对象\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(121,'javascript 反射','121',1470990000,1479289138,'<!--markdown-->```\r\ntypeof  stooge.number  //number\r\ntypeof  stooge.status  //string\r\ntypeof  stooge.arrival //object\r\ntypeof  stooge.min     //undefined\r\n```\r\n\r\n**任何属性都会产生一个值 包括函数**\r\n```\r\ntypeof  stooge.toString    //function\r\ntypeof  stooge.constructor //\'function\'\r\n```\r\n\r\nhasOwnproperty 如果对象拥有独有的属性 将返回true\r\nhasOwnProperty 方法不会检查原型链。\r\n```\r\nstooge.hasOwnProperty(\'number\') //true\r\nstooge.hasOwnProperty(\'constructor\') //false\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(122,'javascript 原型','122',1470990540,1479289132,'<!--markdown-->每个对象都链接到一个对象原型，并且它可以从中继承属性，所有通过对象字面量创建的对象都链接到 Object.prototype 这个javascript中的标准对象。\r\n当你创建一个新对象是，你可以选择某个对象作为它的原型，\r\n添加一个beget方法。这个方法创建一个使用原对象作为其原型的新对象\r\n```\r\nif(typeof Object.beget !== \'function\'){\r\n    Object.beget = functuin(o){\r\n        var F = function(){};\r\n        return new F();\r\n    };\r\n};\r\n\r\nvar another_stooge = Object.beget(stooge);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(123,'javascript 枚举for  &amp; for in','123',1470991260,1479289126,'<!--markdown-->**for  in**\r\n```\r\nvar name;\r\nfor (name in another_stooge){\r\n    if(typeof another_stooge[name] !== \'function\'){\r\n        document.writeln(name + \': \' + another_stooge[name]);\r\n    }\r\n}\r\n```\r\n\r\n\r\n**for**\r\n```\r\nvar i=0;\r\nvar properties = [\r\n    \'first-name\',\r\n    \'middle-name\',\r\n    \'last-name\',\r\n    \'profession\'\r\n];    \r\n\r\nfor (i=0; i<properties.length; i +=1 ){\r\n    document.writeln(properties[i] + \': \' + another_stooge[properties[i]]);\r\n}\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(124,'javascript delete','124',1470991800,1479289120,'<!--markdown-->delete 运算符可以用来删除对象的属性，将移除对象中确定包含的属性，它不会触及原型链中的任何对象。\r\n\r\n**删除对象的属性可能会让来自原型链的属性浮现出来**：\r\n```\r\nanother_stooge.nickname  //\'moe\'\r\n\r\ndelete  another——stooge.nickname;\r\n\r\nanother_stooge.nickname //\'shen\'\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(125,'javascript 函数','125',1470992220,1479289116,'<!--markdown-->函数对象可以通过函数字面量来创建：\r\n```\r\nvar add = function(a,b){\r\n    return a + b;\r\n}\r\n```\r\n函数字面量包括四个部分\r\n\r\n保留字： function\r\n\r\n函数名： add 可以被省略。递归 没有函数名是匿名函数\r\n\r\n参数：  参数用逗号分隔，定义为函数变量\r\n\r\n语句结构： 函数主体 函数被调用时执行',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(126,'javascript 函数调用','126',1470992640,1479289111,'<!--markdown-->```\r\nthis\r\narguments\r\n```\r\n**调用模式**\r\n```\r\n方法调用模式\r\n函数调用模式\r\n构造器调用模式\r\napply调用模式\r\n```\r\n\r\n方法调用模式：\r\n```\r\nvar myObject = {\r\n    value = 0;\r\n    increment:functiom(inc){\r\n        this.value += typeof inc === \'number\' ? inc :1;\r\n    }\r\n};\r\n\r\nmyObject.increment();\r\ndocument.writeln(myObject.value);  //1\r\n\r\nmyObject.increment(2);\r\ndocument.writeln(myObject.value);  //3\r\n```\r\n\r\n函数调用模式\r\n```\r\nvar sum = add(3,4); //7\r\n```\r\n**this 没有权限 通过其他变量访问**\r\n```\r\nmyObject.double = function(){\r\n    \r\n    var that = this;\r\n    var helper = function(){\r\n        that.value = add(that.value,that.value);\r\n    };\r\n    helper();\r\n}\r\n\r\n\r\nmyObject.double();\r\ndocument.writeln(myObject.getValue); //6\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(127,'javascript  参数','127',1470994380,1479289106,'<!--markdown-->**arguments**\r\n```\r\nvar sum = function(){\r\n    var i,sun = 0;\r\n    for(i = 0; i < arguments.length; i += 1){\r\n        sum += arguments[i];\r\n    }\r\n    return sum;\r\n};\r\n\r\ndocument.writeln(sun(1,2,3)); //6\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(128,'javascript 返回','128',1470994620,1479289100,'<!--markdown-->return\r\n一个函数总会返回一个值 如果没有指定返回值 返回undefined。\r\nnew 前缀的方式来调用，且返回值不是一个对象 则返回this',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(129,'javascript  异常','129',1470995040,1479289096,'<!--markdown-->```\r\nvar add= function (a,b){\r\n    if(typeof a !==\'number\' || typeof b !==\'number\'){\r\n        throw{\r\n            name:\'typeError\',\r\n            message:\'add needs numbers\'\r\n        };\r\n    }\r\n    return  a+b;\r\n}\r\n```\r\n\r\n````\r\nvar try_it = function(){\r\n    try{\r\n        add(\'seven\');\r\n    }catch(e){\r\n        document.writeln(e.name + \': \' + e.message)\r\n    }\r\n}\r\n\r\ntry_it();\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(130,'javascript 类型增加方法','130',1470995400,1479289092,'<!--markdown-->Object.prototype 添加方法\r\n\r\nfunction。prototype添加 method方法\r\nfunction.prototype.method = function(name.func){\r\n    this.prototype[name] =func;\r\n    return this;\r\n}\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(131,'javascript 递归','131',1470996000,1479289088,'<!--markdown-->汉诺塔\r\n```\r\nvar hanoi = functio(disc,src,aux,dst){\r\n    if(disc > 0){\r\n        hanoi(dis -1,src,dst,aux);\r\n        document.writeln(\'move disc\' + disc + \'from\' + src + \'to\' + dst);\r\n        haooi(disc -1, aux, src ,dst);\r\n    }\r\n}\r\n\r\nhanoi(3,\'src\',\'aux\',\'dst\');\r\n```\r\n\r\n\r\n尾递归\r\n\r\n```\r\nvar factorial = function factorial(i,a){\r\n    a= a||1;\r\n    if(i<2){\r\n        return a;\r\n    }\r\n    return factorial(i-1,a*i);\r\n}\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(132,'javascript 闭包','132',1470997320,1479289083,'<!--markdown-->```\r\nvar myObject = function(){\r\n    var value=0;\r\n    return{\r\n        increment:function(inc){\r\n            value += typeof inc ===\'number\' ? inc:1;\r\n        },\r\n        getValue:function(){\r\n            return value;\r\n        }\r\n    }\r\n}();\r\n```\r\n\r\n当status为私有\r\n构造 get_status 函数 调用私有\r\n```\r\nvar quo=function(status){\r\n     return{\r\n        get_status:function(){\r\n            return status;\r\n        }\r\n     } \r\n};\r\n\r\nvar myQuo = quo(\"amaed\");\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(133,'javascript 模块 module ','133',1470998700,1479289078,'<!--markdown-->//返回一个用来产生唯一字符串的对象\r\n//唯一字符串有个两个部分组成：前缀+序列号\r\n//该对象包含一个设置前缀的方法，一个设置序列号的方法\r\n```\r\nvar serial_maker =function(){\r\n    \r\n    var prefix = \'\';\r\n    var seq = 0;\r\n    return{\r\n        set_prefix:function(p){\r\n            prefix=String(p);\r\n        },\r\n        set_seq:function(s){\r\n            seq = s;\r\n        }    \r\n        gensym:function(){\r\n            var result = prefix +seq;\r\n            seq += 1;\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvar seqer = serial_maker();\r\nseqer.set_prefix(\'Q\');\r\nseqer.set_seq(1000);\r\nvar unique = seqer.gensym(); //Q1000\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(135,'javascript  数组','135',1471009860,1479289074,'<!--markdown-->数组字面量提供了一个非常方便的创建新数组的表示法。一个数组字面量时在一个对方括号中包围零个或多个用逗号分隔的值的表达式。数组字面量可以出现在任何表达式可以出现的地方。数组的第一个值将获得属性名‘0’，第二个值将获得属性名‘1’，依次类推：\r\n```\r\n**数组**\r\n1.数组的下标必须是大于等于0并小于2的32次方-1的整数；\r\n2.在使用数组字面量表示法时，是不会调用Array构造函数的(Firefox3及更早版本除外)；\r\n3.js允许数组包含任意混合类型的值。\r\nvar empty = [];\r\nvar numbers = [\r\n    \'zero\',\'one\',\'two\',\'three\',\'four\',\'five\',\'six\',\'seven\',\'eight\',\'nine\'\r\n];\r\n\r\nempty[1] //undefined\r\nnumbers[1] // \'one\'\r\n\r\nempty.length   //0\r\nnumbers.length  //10\r\n\r\n```\r\n```\r\n**对象字面量**\r\n\r\nvar numbers_object={\r\n    \'0\':\'zero\',\'1\':\'one\',\'2\':\'two\',\r\n    \'3\':\'three\',\'4\':\'four\',\'5\':\'five\',\r\n    \'6\':\'six\',\'7\':\'seven\',\'8\':\'eight\',\r\n    \'9\':\'nine\'\r\n};\r\n\r\n```\r\n```\r\nvar misc =[\r\n    \'string\',98.6,true,false,null,undefined,\r\n    [\'nested\',\'array\'],{object:ture},NaN,\r\n    Infinity\r\n];\r\n\r\nmisc.length  //10\r\n\r\n```\r\n\r\n**length**\r\njavascript数组的length 没有上界。如果你用大于或者等于当前length的数字作为下标来保存一个元素，那么length将增大来容纳新元素，不会发生数组边界错误。\r\n\r\n**length属性的值时这个数组最大整数属性名加上1，它不一定等于数组里属性的个数：**\r\n```\r\nvar myArray =[];\r\nmyArray.length // 0\r\nmyArray[1000000] =true;\r\n\r\nmyArray.length  //1000001\r\n\r\n```\r\n\r\n你可以直接设置length的值。设置更多的length无须给数组分配更多的空间。而把length设小将导致所有下标大于等于新length的属性被删除；\r\n```\r\nnumber.length =3;\r\n//numbers 是 [\'zero\',\'one\',\'two\']\r\n```\r\n添加\r\n\r\n通过把下标指定为一个数组当前的length，可以附加一个新元素到该数组的尾部。\r\n```\r\nnumbers[numbers.length] = \'shi\';\r\n//numbers 是 [\'zero\',\'one\',\'two\',\'shi\']\r\n\r\npush 方法同上\r\nnumbers.push(\'go\');\r\n//numbers 是 [\'zero\',\'one\',\'two\',\'shi\',\'go\']\r\n```\r\n\r\n**删除 delete** \r\n```\r\ndelete numbers[2];\r\n//numbers [\'zero\',\'one\',undefined,\'shi\',\'go\']\r\n```\r\n**这样数组中会遗留一个空洞。这是因为排在被删除元素之后的元素保留可它们最初的名字（下标）。而你通常想要的时递减后面每个元素的名字（下标）**\r\n\r\n**splice** \r\n方法：删除一些元素并将他们替换为其他的元素。第一个参数是数组中的一个序号。第二个参数是要删除的元素个数。任何额外的参数会在序号那个点的位置被插入到数组中：\r\n```\r\nnumbers.splice(2,1);\r\n//numbers  [\'zero\',\'one\',\'shi\',\'go\']\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(161,'javascript number.toExponential','161',1471256160,1479288955,'<!--markdown-->toExponential 方法把这个number转换成一个指数形式的字符串\r\n可选参数 fractionDigits控制其小数点后的数字位数 [0,20]\r\n```\r\ndocument.writeln(Math.PI.toExponential(0));//3e+0\r\ndocument.writeln(Math.PI.toExponential(2));//3.14e+0\r\ndocument.writeln(Math.PI.toExponential(7));//3.1415927e+0\r\ndocument.writeln(Math.PI.toExponential(16));//3.14159265857930e+0\r\ndocument.writeln(Math.PI.toExponential(0)); //3.1415926585793e+0',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(157,'javascript function.apply','157',1471254180,1479288974,'<!--markdown-->apply 方法调用函数function ，传递一个将被绑定到this 上的对象和一个可选的参数数组\r\napply 方法被用在apply调用模式 (apply invocation pattern)\r\n```\r\nFunction.method(\'bind\',function(that){\r\n    var method = this,\r\n        slice = Array.prototype.slice,\r\n        args = slice.apply(argumnets,[1]);\r\n    return function(){\r\n        return method.apply(that,\r\n            args.concat(slice.apply(arguments,[0])));\r\n    };\r\n});\r\n\r\nvar x = function(){\r\n    return this.value;\r\n}.bind({value:666});\r\n\r\nalert(x());\r\n//666',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(158,'javascript number.tostring','158',1471255140,1479288969,'<!--markdown-->toString 方法把这个number转换成一个字符串。\r\n可选参数radix 控制基数  默认 10  [2,36]  进制数\r\n```\r\ndocument.writeln(Math.PI.toString(2)); //11.00100100000001111111011101010100001000010000001001\r\ndocument.writeln(Math.PI.toString(8)); //3.11103755242102653\r\ndocument.writeln(Math.PI.toString(16));//3.243f6a8885a3\r\ndocument.writeln(Math.PI.toString());  //3.141592653589793',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(159,'javascript number.toPrecision','159',1471255500,1479288964,'<!--markdown-->toPercision 方法把这个number 转换成为一个 十进制数形式的字符串。\r\n可选参数precision 控制有效数字的位数 [0,21]之间\r\n```\r\ndocument.writeln(Math.PI.toPrecision(2)); //3.1\r\ndocument.writeln(Math.PI.toPrecision(7)); //3.141593\r\ndocument.writeln(Math.PI.toPrecision(16)); //3.141592653589793\r\ndocument.writeln(Math.PI.toPrecision());   //3.141592653589793\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(160,'javascript number.toFixed','160',1471255920,1479288959,'<!--markdown-->tofixed 方法 把这个number 转换成一个十进制数形式的字符串\r\n可算参数 fractionDigits控制其小数点后的数字位数 [0,20]之间 ，默认 0；\r\n```\r\ndocument.writeln(Math.PI.toFixed(0)); //3 \r\ndocument.writeln(Math.PI.toFixed(2)); //3.14\r\ndocument.writeln(Math.PI.toFixed(7)); //3.1415927\r\ndocument.writeln(Math.PI.toFixed(16));//3.1415926535897930\r\ndocument.writeln(Math.PI.toFixed());  //3 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(138,'javascript 判断数组','138',1471057920,1479289069,'<!--markdown-->```\r\nvaris_array= function(value){\r\n    return  value &&\r\n            typeof value === \'object\' &&\r\n            typeof value.length === \'number\' &&\r\n            typeof value.splice === \'function\' &&\r\n            !(value.propertuIsEnumerable(\'length\'));\r\n};\r\n```\r\n1. 判断这个值是否为真 不接受null  和其他假值\r\n2. tyoeof 是否object，对于对象，数组（古怪的） null 来说  true\r\n3. 判断值是否有一个值为数字的length属性  对于数组时 true\r\n4. 判断值是否包含一个splice方法         对于数组   true\r\n5. 判断length属性是否是可枚举的         对于数组   false',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(139,'javascript 数组方法 methods','139',1471058700,1479289060,'<!--markdown-->javascript提供了一套作用于数组的方法。这些方法是被存储早 Array.prototype(可扩充) 中的函数 \r\n```\r\nArray。method(\'reduce\',function(f,value){\r\n    var i;\r\n    for( i =0; i<this.length; i+=1){\r\n        value = f(this[i],value);\r\n    }\r\n    return value;\r\n});\r\n\r\n//创建一个数字数组\r\nvar data = [4,8,15,16,23,42];\r\n\r\n//定义连个简单的函数 一个 是将两个数字相机， 一个是将两个数字相乘\r\n\r\nvar add = function(a,b){\r\n    return a + b;\r\n};\r\n\r\nvar mult = function(a,b){\r\n    return a * b;\r\n};\r\n\r\n//调用data 的reduce方法 传入 add函数\r\n\r\nvar sum = data.reduce(add,0); //sum  is 108\r\n\r\nvar product = data.reduce(mult,1); //product 7418800   4*8*15*16*23*42\r\n\r\n```\r\n\r\n直接给一个单独的数组添加方法：\r\n```\r\ndata.total= function(){\r\n    return this.reduce(add,0);\r\n};\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(140,'javascript 维度','140',1471065780,1479289056,'<!--markdown-->javascript数组通常不会初始化，如果你是用[]得到一个新数组，它将是空的。如果你访问一个不存在的元素，将得到undefined。\r\n```\r\nArray.dim = function(dimension,initial){\r\n    var a=[], i;\r\n    for ( i = 0 ; i < dimension; i += 1){\r\n        a[i] = initial;\r\n    }\r\n    return a;\r\n}\r\n//创建10个 0 的数组\r\nvar myArray = Array.dim(10,0);\r\n```\r\n\r\n**javascript 没有多维数组，但支持元素为数组。**\r\n```\r\nvar matrix = [\r\n    [0,1,2],\r\n    [3,4,5],\r\n    [6,7,8]\r\n];\r\n\r\nmatrix[2][1]  //7\r\n```\r\n\r\n**创建二维数组**\r\n```\r\nfor( i = 0; i < n ; i += 1){\r\n    my_array[i] = [];\r\n}\r\n```\r\n\r\n**空矩阵 //** \r\n```\r\nArray.matrix = function (m,n,initial){\r\n    var a,i,j,mat=[];\r\n    for(i = 0; i < m; i += 1){\r\n        a = [];\r\n        for(j = 0; j < n; j+=1 ){\r\n            a[j] = 0;\r\n        }\r\n        mat[i] = a;\r\n    }\r\n    return mat;\r\n}\r\n\r\narray myarray = Array.mitrix(4,4,0);\r\ndocument.writeln(myarray[3][3]) // 0\r\n```\r\n\r\n**恒等矩阵**\r\n```\r\nArray.identity = function(n){\r\n    var i , mat = Array.matrix(n,n,0);\r\n    for( i = 0; i < n; i += 1){\r\n        mat[i][i] = 1;\r\n    }\r\n    return mat;\r\n}\r\n\r\nmyMatrix =Array.identity(4);\r\ndocument。writeln(myMatrix[3][3]); //1\r\n```\r\n\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(143,'javascript 正则','143',1471228260,1479289050,'<!--markdown-->```\r\n? ： 重复 0 次 或者  1次\r\n+ ： 表示匹配一次或多次\r\n{0，3} ： 1到3次之间\r\n* ： 表示 0 次 或者  多次\r\n^ :  以什么开头\r\n[^]: 不以什么开头\r\n$ :  结尾\r\n. :  匹配除行结束符以外的所有字符\r\n\\d: [0-9]\r\n\r\n\r\nvar parse_number = /^-?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?$/i;\r\nvar test = function (num){\r\n    document.writeln(parse_number.test(num));\r\n};\r\n\r\ntest(\'1\'); //ture\r\ntest(\'number\') //false\r\ntest(\'98.6\')  // true\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(144,'javascript 正则结构','144',1471235460,1479289045,'<!--markdown-->```\r\nG:全局的(匹配多次；准确含义随方法而变)\r\nI：大小写不明哥(忽略字符大小写)\r\nM:多行(^和$能匹配行结束符)\r\n\r\nvat my_regexp= /\"(?:\\\\.|[^\\\\\\\"])*\"/g;\r\n```\r\n\r\nRegExp 构造器\r\n```\r\n//创建一个匹配javascript字符串的正则表达式\r\nvar my_regexp= new RegExp(\"\\\"(?:\\\\.\\[^\\\\\\\\\\\\\\\"])*\\\"\",\'g\');\r\n```\r\nRegExp 对象属性\r\n```\r\nglobal： 如果标志g被使用，true\r\nignoreCase ： 如果i被使用，true\r\nlastIndex ： 下一次exec匹配开始的索引 初始值 0\r\nmultiline ： 如果m 被使用 ，true\r\nsource ： 正则表达式源代码文本 \r\n```\r\n**正则单例**\r\n正则表达式字面量创建的RegExp对象来共享同一个单实例：\r\n```\r\nfunction make_a_matcher(){\r\n    return /a/gi;\r\n}\r\n\r\nvar x = make_a_matcher();\r\nvar y = make_a_matcher();\r\n\r\n// x 和 y 是相同的对象\r\nx.lastIndex= 10；\r\ndocument.writeln(y.lastIndex); //10\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(145,'javascript 正则 元素','145',1471240860,1479289039,'<!--markdown-->一个正则表达式选择包含一个或者多个正则表达式序列。被 | (竖线)字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序依次匹配。\r\n\"into\".match(/in|int/)\r\n\r\n将在 into 中匹配in 但不会匹配int 因为i你已经被匹配成功了\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(146,'javascript  array.concat','146',1471241460,1479289033,'<!--markdown-->**array.concat(item...)**\r\n\r\nconcat 方法返回一个新数组，它包含array 的浅复制(shallow copy) 并将一个或者对各参数item 附加在其后，如果参数item 是一个数组，那么它的每个元素会被分别添加，array.push\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar b = [\'x\',\'y\',\'z\'];\r\nvar c = a.concat(b,true);\r\n// [\'a\',\'b\',\'c\',\'x\',\'y\',\'z\',true]\r\n\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(152,'javascript array.shift','152',1471247400,1479288997,'<!--markdown-->shift 方法移除数组array中的第一个元素并返回该元素，\r\n如果这个数组array是空的，返回undefined \r\nshift 通常比 pop 慢的多\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar c = a.shift();\r\n//c = [\'a\'];\r\n//a = [\'b\',\'c\'];\r\n\r\nArray.method(\'shift\',function(){\r\n      return this.splice(0,1)[0];    \r\n});\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(153,'javascript array.slice','153',1471248480,1479288993,'<!--markdown-->slice 方法对array中的一段做浅复制，\r\n第一个被复制的元素是array[start],它将一直复制到array[end]为止 \r\nend参数是可选的。并且默认值是该数组的长度 array.length\r\n如果两个参数中的任何一个是负数，array.length将和它们相加来试图使他们成为非负数\r\nstart、大于等于array.length的到的结果将是一个新的空数组\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar b = a.slice(0,1); // b = [\'a\']\r\nvar c = a.slice(1); // c = [\'b\',\'c\'] \r\nvar d = a.slice(1,2)// d = [\'b\']\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(154,'javascript array.sort','154',1471249860,1479288989,'<!--markdown-->sort 方法对 array 中的内容进行适当的排序。它不能正确的给出一组数字排序\r\n```\r\nvar n = [4,8,15,16,23,43]\r\n\r\nn.sort\r\n// 15,16,23,4,43,8\r\n```\r\njavascript 的默认比较函数假定所有要被排序的元素都是字符串，\r\n**比较数字时会将它转换成字符串**\r\n```\r\nn.sort(function(a,b){\r\n    return a-b;\r\n});\r\n// 4,8,15,16,23,43\r\n```\r\n```\r\nvar m = [\'aa\',\'bb\',\'a\',4,8,15,16,23,42];\r\nm.sort(function(a,b){\r\n\r\n    if(a === b){\r\n        return 0;\r\n    }\r\n    if(tyoeof a === typeof b){\r\n        return a<b ? -1:1;\r\n    }\r\n    return typeof a < typeof b ? -1 : 1;\r\n});\r\n\r\n[4,8,15,16,23,42,\'a\',\'aa\',\'bb\']\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(155,'javascript array.splice','155',1471251600,1479288984,'<!--markdown-->splice 方法 从array中移除一个或者多个元素，并用新item 替换它们。\r\n参数start 是从数组array中移除元素的开始位置\r\n参数deletecount 是要移除的元素个数\r\n如果有额外的参数，那些item都将插入到所移除元素的位置上\r\n它返回一个包含被移除元素的数组\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar r = a.splice(1,1,\'ache\',\'bug\');\r\n//a = [\'a\',\'ache\',\'bug\',\'c\']\r\n//r = [\'b\']\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(149,'javascript array.pop','149',1471245960,1479289018,'<!--markdown-->**array.pop()**\r\n\r\npop 和push方法使数组array像堆栈(stack)一样工作。\r\npop 移除array中最后一个元素并返回该元素。如果array是空。返回undefined\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar c = a.pop(); //c\r\n\r\nArray.method(\'pop\',function(){\r\n    return this.splice(this.length -1,1)[0];\r\n});\r\n```\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(147,'javascript array.jion','147',1471245900,1479289028,'<!--markdown-->**array.jion(separator)**\r\n\r\njion方法是把一个array构造成一个字符串。它将array中的每个元素构造成一个字符串。\r\n并用separator为分隔符把他们链接到一起。默认separator 是‘，’。 \r\n为了实现无间链接，可以使用空字符串作为separator\r\n\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\na.push(\'d\');\r\nvar c = a.jion(\'\'); //c是\'abcd\';\r\n```\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(148,'javascript array.jion','148',1471245900,1479289023,'<!--markdown-->**array.jion(separator)**\r\n\r\njion方法是把一个array构造成一个字符串。它将array中的每个元素构造成一个字符串。\r\n并用separator为分隔符把他们链接到一起。默认separator 是‘，’。 \r\n为了实现无间链接，可以使用空字符串作为separator\r\n\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\na.push(\'d\');\r\nvar c = a.jion(\'\'); //c是\'abcd\';\r\n```\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(151,'javascript array.reverse','151',1471247100,1479289008,'<!--markdown-->reverse 方法反转 array中的元素顺序， 返回当前的array\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar b =a.reverse();\r\n// a 和 b 都是 [\'c\',\'b\',\'a\'] \r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(150,'javascript array.push','150',1471246020,1479289013,'<!--markdown-->push 方法将一个或多个参数 item 附加到一个数组的尾部。不像concat 方法那样，它会修改该数组array，如果参数item 使一个数组，它会将参数数组作为单个元素整个添加到数组中。它返回这个数组array的新的长度值\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar b = [\'x\',\'y\',\'z\'];\r\nvar c = a.push(b,true);\r\n//a [\'a\',\'b\',\'c\',[\'x\',\'y\',\'z\'],true]\r\n//c 5\r\n\r\nArray.method(\'push\',function(){\r\n    this.splice.apply(\r\n        this,\r\n        [this.length,0].\r\n            concat(Array.prototype.slice.apply(argumenys)));\r\n    return this.length;    \r\n});\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(156,'javascript array.unshift','156',1471253340,1479288979,'<!--markdown-->unshift 方法像push 方法一样用于将元素添加到数组中，但它是把item插入到array的开始部分\r\n它返回array的新的长度值\r\n```\r\nvar a = [\'a\',\'b\',\'c\'];\r\nvar r = a.unshift(\'?\',\'@\');\r\n\r\n//a = [\'?\',\'@\',\'a\',\'b\',\'c\']\r\n//r = 5\r\n\r\nArray.method(\'unshift\',function(){\r\n    this.splice.apply(this,\r\n        [0,0].concat(Array.prototype.slice.apply(arguments)));\r\n});\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(162,'javascript object.hasOwnProperty','162',1471258440,1479288951,'<!--markdown-->如果这个object 包含了一个名为name 的属性，那么hasOwnProperty 返回 true\r\n原型链中的同名属性是不或变检查的，\r\n这个方法对name就是hasOwnOrioerty时不起作用 返回false\r\n```\r\nvar a = {member：ture};\r\nvar b = Object.beget(a);\r\nvar t = a.hasOwnProperty(\'mumber\');    //t  true\r\nvar u = b.hasOwnProperty(\'mumber\');    //u  false\r\nvar v = b.mumber                       //v  true',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(163,'javascript string.charAt','163',1471259820,1479288947,'<!--markdown-->charAt 方法返回在string 中 pos 位置处的字符。\r\n如果pos小于0或者大于等于字符串的长度 string.length 将返回空字符串\r\n```\r\nvar name = \'Curly\';\r\nvar initial = name.charAt(0); //C\r\n\r\nString.method(\'charAt\',function(){\r\n    return this.slice(0,1);\r\n});',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(164,'javascript string.charCodeAt','164',1471260180,1479288934,'<!--markdown-->charCodeAt 和charAt一样 pos位置处的字符的字符码位\r\n如果pos 小于0 或者大于等于string.length返回 NaN\r\n```\r\nvar name = \'Curly\';\r\nvar initial = name.charCodeAt(0);  //67\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(170,'javascript string.match','170',1471262580,1479288905,'<!--markdown-->match 方法 匹配一个字符串和一个正则表达式\r\n```\r\nvar text =\'<html><body bgcolor=linen><p>\' +\r\n    \'this is <b>blod<\\/b>!<\\/p><\\/body><\\/html>\';\r\n\r\nvar tags = /[^<>]+|<(\\/?)([A-Za-z]+)([^<>]*)>/g;\r\n\r\nvar a,i;\r\n\r\na = text.match(tags);\r\nfor(i = 0 ; i < a.length; i += 1){\r\n    document.writeln((\'// [\' + i + \']\' + a[i]).entityify());\r\n}\r\n\r\n//[0] <html>\r\n//[1] <body bgcolor=linen>\r\n//[2] <p>\r\n//[3] this is\r\n.\r\n.\r\n.\r\n.',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(166,'javascript string.concat','166',1471260960,1479288929,'<!--markdown-->concat 通过将其他的字符串链接在一起来构造一个新的字符串\r\n很少用  一般用 + 更方便\r\n```\r\nvar s = \'C\'.concat(\'a\',\'t\'); // Cat',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(167,'javascript string.indexOf','167',1471261200,1479288921,'<!--markdown-->string.indexOf(searchString，position)\r\nindexOf ：在string内查找另一个字符串 searchString、\r\n如果被找到则返回第一个匹配字符的位置 否则返回 -1；\r\n可选参数position可设置从string 的摸个指定的位置开始查找\r\n```\r\nvar text = \'Mississippi\';\r\nvar p = text.indexOf(\'ss\'); //2\r\np = text.indexOf(\'ss\',3);   //5\r\np = text.indexOf(\'ss\',6);   //-1\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(168,'javascript string.lastIndexOf','168',1471261740,1479288916,'<!--markdown-->lastIndexOf(\'searchstring\',position);\r\n从该字符串的末尾开始查找\r\n```\r\nvar text = \'Mississippi\' ;\r\nvar p = text.lastIndexOf(\'ss\')  //5\r\np = text.lastIndexOf(\'ss\',3)    //2\r\np = text.lastIndexOf(\'ss\',6)    //5',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(169,'javascript string.localeCompare','169',1471262040,1479288909,'<!--markdown-->string.localeCompare(that) \r\nlocaleCompare 比较两个字符串\r\n如果string 比字符串 that 小 那么结果为负数\r\n相等       为 0\r\n```\r\nvar m = [\'AAA\',\'A\',\'aa\',\'a\',\'Aa\',\'aaa\'];\r\n\r\nm.sort(function(a,b){\r\n    return a.localeCompare(b);\r\n});\r\n\r\n// [\'a\',\'A\',\'aa\',\'Aa\',\'aaa\',\'AAA\']\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(171,'javascript string.replace','171',1471263360,1479288899,'<!--markdown-->string.replace(searchValue,replaceValue)\r\n\r\nreplace 对string 进行查找和替换操作并返回一个新的字符串\r\nsearchvalue 可以是一个字符串或者正则表达式对象\r\n如果是一个字符串 只会 匹配一处\r\n```\r\nvar result = \'mother_in_law\'.replace(\'_\',\'-\')\r\n\r\n//mother-in_law \r\n\r\n$$ \r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(172,'javascript string.search','172',1471263960,1479288893,'<!--markdown-->search  he indexOf 方法类似 接受一个正则表达式\r\n如果找到匹配返回第一个匹配的首字符位置\r\n没有匹配 返回  -1\r\n\r\n```\r\nvar text = \'and in it he says \"any damn fool could\';\r\nvar pos = text.search(/[\"\']/); // pos = 18',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(173,'javascript string.slice','173',1471264260,1479288888,'<!--markdown-->slice 方法复制string的一部分来构造一个新的字符串\r\n如果start参数是负数,于string.length 相加 \r\nend 可选 默认是 string.length,如果end是负数 与string.length相加\r\nend参数是一个比最末一个字符的位置还大的数\r\n```\r\nstring.slice(p,p+n)\r\n\r\nvar text = \'and in it he says \"any damn fool could\';\r\nvar a = text.slice(18);\r\n//any damn fool could\r\nvar b = text.slice(0,3);\r\n//and\r\nvar c = text.slice(-5);\r\n//could\r\nvar d = text.slice(19,32)\r\n//any damn fool',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(174,'javascript string.split','174',1471265640,1479288883,'<!--markdown-->string.split(sepatator,limit)\r\nsplit 把string 分割成片段来创建一个字符串数组\r\n可选参数limit可以限制分隔片段数量 \r\nseparator参数 一个字符串或者一个正则\r\n如果separator 为空字符串 将返回单个字符的数组\r\n```\r\nvar digits = \'0123456789\';\r\n\r\nvar a = digits.split(\'\',5);\r\n//[\'0\',\'1\',\'2\',\'3\',\'456789\']\r\n\r\n\r\nvar ip = \'192.168.1.1\';\r\nvar b = ip.split(\'.\');\r\n//[\'192\',\'168\',\'1\',\'1\']\r\n\r\nvar c =\'|a|b|c|\'.split(\'|\');\r\n//[\' \',\'a\',\'b\',\'c\',\' \']\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(175,'javascript string.substring','175',1471266420,1479288878,'<!--markdown-->```\r\nstring.substring(start,end)\r\n和slice 方法一样 但不能处理负数参数',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(176,'javascript string.toLocaleLowerCase','176',1471266660,1479288873,'<!--markdown-->toLocaleLowerCase 返回一个新的字符串 把所有字母转换小写格式',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(177,'javascript string.toLocaleUpperCase','177',1471266720,1479288869,'<!--markdown-->把字母转换大写格式',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(180,'javascript string.toUpperCase','180',1471267020,1479288859,'<!--markdown-->返回一个新的字符串，这个string中的所有字母都被转化为大写格式',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(179,'javascript string.toLowerCase','179',1471266960,1479288865,'<!--markdown-->返回一个新的字符串，这个string中的所有字母都被转化为小写格式',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(183,'node.js .第一个node.js','183',1471319400,1479288608,'<!--markdown-->```\r\nnode -v  //查看node 版本\r\n\r\nnode.js程序\r\nvim helloworld.js\r\nconsole.log(\'hello world\');\r\n\r\n通过 node调用\r\nnode node.js',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(181,'javascript string.toUpperCase','181',1471267020,1479288852,'<!--markdown-->返回一个新的字符串，这个string中的所有字母都被转化为大写格式',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(182,'javascript String.fromCharCode','182',1471267080,1479288847,'<!--markdown-->```\r\nString.fromCharCode 函数从一串数字中返回一个字符串\r\n\r\nvar a = String.fromCharCode(67,97,116);\r\n\r\n//Cat',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(184,'node.js 创建服务器','184',1471319640,1479288602,'<!--markdown-->1. 引入 requried 模块：我们可以使用 require 指令来载入 Node.js 模块。\r\n2. 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。\r\n3. 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。\r\n\r\n1.引入 requried 模块\r\n```\r\nvar http = requrie(\"http\");\r\n```\r\n2.创建服务器\r\nhttp.createSerer() 创建服务器\r\nlisten 绑定端口\r\nrequest  response\r\n```\r\nvim server.js\r\n\r\nvar http = requrie(\"http\");\r\n\r\nhttp.createServer(function(request,response){\r\n        \r\n    //发送 HTTP 头部\r\n    //http 状态值：200 ：ok\r\n    //内容类型：text/plain\r\n    response.writeHead(200,{\'Content-Type\':\'text/plain\'});\r\n    \r\n    //发送响应数据 “hello world”\r\n    response.end(\'hello world\\n\');\r\n}).listen(8888);\r\n\r\nconsole.log(\'sever running at http://127.0.0.1:8888\')\r\n\r\nnode server.js\r\n```\r\n![请输入图片描述][1]\r\n\r\n\r\n  [1]: http://www.runoob.com/wp-content/uploads/2014/03/node-hello.gif',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(185,'node.js NPM','185',1471328880,1479288585,'<!--markdown-->npm版本\r\n```\r\nnpm -v\r\n2.3.0\r\n```\r\nnpm 升级\r\n```\r\n$ sudo npm install npm -g\r\n/usr/local/bin/npm -> /usr/local/lib/node_modules/npm/bin/npm-cli.js\r\nnpm@2.14.2 /usr/local/lib/node_modules/npm\r\n\r\nwindow\r\n\r\nnpm install npm -g\r\n```\r\nnpm  安装 模块\r\n```\r\nnpm install <model name>\r\n\r\nnpm install express\r\n\r\nvar express =  requrie(\'express\');\r\n\r\n全局安装 与本地安装\r\nlocal\r\nglobal\r\n\r\nnpm install express       //local    \r\nnpm install express -g    //global\r\n\r\n本地安装包 \r\n1.放在 ./node_modules(运行npm命令时所在的目录)，如果没有node_mudules目录会在当前执行npm命令的目录下生成node_modules目录\r\n2.requrie()引入本地安装包\r\n全局安装\r\n1.将安装包放在/usr/local 或者node的安装目录\r\n2.可以直接在命令行里使用\r\n```\r\n卸载模块\r\n```\r\nnpm uninstall express\r\n\r\nnpm ls //查看 /node_modlules/目录下查看包是否存在\r\n\r\n```\r\n更新模块\r\n```\r\nnpm update express\r\n```\r\n搜索模块\r\n```\r\nnpm search express\r\n```\r\n\r\nNPM 常用命令\r\n```\r\n除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。\r\n\r\n除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。\r\n\r\nNPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\r\n\r\n使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\r\n\r\n在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\r\n\r\n使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\r\n\r\n使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\r\n\r\n使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\r\n\r\n使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(186,'node.js REPL','186',1471333200,1479288579,'<!--markdown-->Node 自带了交互式解释器，可以执行以下任务：\r\n\r\n    读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\r\n\r\n    执行 - 执行输入的数据结构\r\n\r\n    打印 - 输出结果\r\n\r\n    循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。\r\n\r\nNode 的交互式解释器可以很好的调试 Javascript 代码。\r\n\r\n\r\n我们可以输入以下命令来启动 Node 的终端：\r\n```\r\n$ node\r\n> \r\n```\r\n这时我们就可以在 > 后输入简单的表达式，并按下回车键来计算结果。\r\n简单的表达式运算\r\n\r\n接下来让我们在 Node.js REPL 的命令行窗口中执行简单的数学运算：\r\n```\r\n$ node\r\n> 1 +4\r\n5\r\n> 5 / 2\r\n2.5\r\n> 3 * 6\r\n18\r\n> 4 - 1\r\n3\r\n> 1 + ( 2 * 3 ) - 4\r\n3\r\n>\r\n```\r\n使用变量\r\n\r\n你可以将数据存储在变量中，并在你需要的使用它。\r\n\r\n变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。\r\n\r\n使用 var 关键字的变量可以使用 console.log() 来输出变量。\r\n```\r\n$ node\r\n> x = 10\r\n10\r\n> var y = 10\r\nundefined\r\n> x + y\r\n20\r\n> console.log(\"Hello World\")\r\nHello World\r\nundefined\r\n> console.log(\"www.runoob.com\")\r\nwww.runoob.com\r\nundefined\r\n```\r\n多行表达式\r\n\r\nNode REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：\r\n```\r\n$ node\r\n> var x = 0\r\nundefined\r\n> do {\r\n... x++;\r\n... console.log(\"x: \" + x);\r\n... } while ( x < 5 );\r\nx: 1\r\nx: 2\r\nx: 3\r\nx: 4\r\nx: 5\r\nundefined\r\n>\r\n```\r\n... 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。\r\n下划线(_)变量\r\n\r\n你可以使用下划线(_)获取表达式的运算结果：\r\n```\r\n$ node\r\n> var x = 10\r\nundefined\r\n> var y = 20\r\nundefined\r\n> x + y\r\n30\r\n> var sum = _\r\nundefined\r\n> console.log(sum)\r\n30\r\nundefined\r\n>\r\n```\r\n\r\n\r\nREPL 命令\r\n```\r\n    ctrl + c - 退出当前终端。\r\n\r\n    ctrl + c 按下两次 - 退出 Node REPL。\r\n\r\n    ctrl + d - 退出 Node REPL.\r\n\r\n    向上/向下 键 - 查看输入的历史命令\r\n\r\n    tab 键 - 列出当前命令\r\n\r\n    .help - 列出使用命令\r\n\r\n    .break - 退出多行表达式\r\n\r\n    .clear - 退出多行表达式\r\n\r\n    .save filename - 保存当前的 Node REPL 会话到指定文件\r\n\r\n    .load filename - 载入当前 Node REPL 会话的文件内容。\r\n```\r\n停止 REPL\r\n\r\n前面我们已经提到按下两次 ctrl + c 建就能退出 REPL:\r\n```\r\n$ node\r\n>\r\n(^C again to quit)\r\n>\r\n```\r\n\r\n![请输入图片描述][1]\r\n\r\n\r\n  [1]: http://www.runoob.com/wp-content/uploads/2015/09/nodejs-gif2.gif',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(189,'node.js 回掉函数 异步调用','189',1471335600,1479288573,'<!--markdown-->**阻塞代码实例**\r\n\r\n创建input.txt\r\n```\r\nhoyins.com\r\n```\r\n创建main.js文件\r\n```\r\nvar fs = require(\'fs\');\r\n\r\nvar data = fs.readFileSyn(\'input.txt\');\r\n\r\nconsole.log(data.toString());\r\nconsole.log(\'end!\')\r\n```\r\n\r\n**非阻塞代码实例**\r\n```\r\nvar fs = require(\'fs\');\r\n\r\nfs.readFile(\'input.txt\',function(err,data){\r\n\r\n	if(err) return console.error(err);\r\n	console.log(data.toString());\r\n});\r\n\r\nconsole.log(\'end!!!!!!!!\');',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(191,'node.js 事件循环','191',1471338540,1479288564,'<!--markdown-->**node.js 事件循环**\r\nNode.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。\r\n\r\nNode.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。\r\n\r\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\r\n\r\nNode.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\r\n\r\n**事件驱动程序**\r\n\r\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\r\n\r\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\r\n\r\n这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\r\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\r\n\r\n```\r\n//引入 events 模块\r\nvar events = require(\'events\');\r\n\r\n//创建 event对象\r\nvar eventEmitter = new events.EventEmitter(); \r\n\r\n//绑定事件事件处理程序\r\neventEmitter.on(\'eventName\',eventHandler)；\r\n\r\n//触发事件\r\neventEmitter.emit(\'eventName\');\r\n```\r\n************************************************************************\r\n\r\n```\r\nvar events = require(\'events\');\r\n\r\nvar eventEmitter = new events.EventEmitter();\r\n\r\nvar connectHandler = function connected(){\r\n    console.log(\'链接成功\');\r\n    \r\n    eventEmitter.emit(\'data_received\');\r\n}\r\n\r\neventEmitter.on(\'connection\',connectHandler);\r\n\r\neventEmitter.on(\'data_received\',function(){\r\n    console.log(\'数据接收成功\');\r\n});\r\n\r\neventEmitter.emit(\'connection\');\r\n\r\nconsole.log(\'end!!!!!!!!\');\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(192,'node.js EventEmitter','192',1471341780,1479288559,'<!--markdown-->Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\r\n\r\nNode.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 \r\n\r\n**EventEmitter类**\r\n\r\nevent 模块只是提供了一个对象：event.EventEmitter。EventEmitter的核心就是事件触发与事件监听功能的封装，\r\n\r\n```\r\n//引入 events 模块\r\nvar events= require(\'events\');\r\n\r\n//创建 eventREmitter 对象\r\nvar eventsEmitter = new events.EventEmitter();\r\n\r\n```\r\nEventEmitter 对象如果再在实例发生错误是，触发法error事件\r\n当添加新的监听器时，\'newListener\' 事件会触发\r\n当监听器被移除时,\'removeListener\' 事件触发\r\n```\r\n//event.js\r\nvar EventEmitter = require(\'events\').EventEmitter;\r\nvar event = new EventEmitter();\r\nevent.on(\'some_event\',function(){\r\n    console.log(\'some_event 事件触发\');\r\n});\r\n\r\nsettimeout(function(){\r\n    event.emit(\'some_event\');\r\n},1000);\r\n```\r\n EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\r\n\r\n当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\r\n\r\n```\r\n//event.js\r\nvar events = requrie(\'events\');\r\nvar emitter = new events.EventEmitter();\r\nemitter.on(\'someEvent\',function(arg1,arg2){\r\n    console.log(\'listen1\',arg1,arg2);\r\n});\r\n\r\nemitter.on(\'someEvent\',function(arg1,arg1){\r\n    console.log(\'listen2\',arg1,arg2);    \r\n});\r\n\r\nemitter.emit(\'someEvent\',\'arg1 参数\',\'arg2 参数\');\r\n\r\n$node event.js\r\nlisten1 arg1 参数 arg2 参数;\r\nlisten2 arg1 参数 arg2 参数;\r\n```\r\n以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。\r\n\r\n运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。\r\n\r\nEventEmitter 提供了多个属性，如 on 和 emit。\r\non 函数用于绑定事件函数，\r\nemit 属性用于触发一个事件。\r\n\r\n接下来我们来具体看下 EventEmitter 的属性介绍。\r\n```\r\n1.addListen(event,listener)\r\n为指定事件添加一个监听器到监听数组的尾部。\r\n\r\n2.on(event,listener)\r\n为指定事件注册一个监听器，接受一个字符串event 和 一个回掉函数\r\n\r\nserver.on(\'connection\',function(stream){\r\n    consol.log(\'ah , we have our first user\');\r\n});\r\n\r\n3.once(event,listener)\r\n为指定事件注册一个单次监听器,即监听器最多只会触发一次，触发后立刻解除该监听器。\r\n\r\nserver.once(\'connection\',function(stream){\r\n    console.log(\'ah , we have our first user\');\r\n});\r\n\r\n4.removeListener(event,listener)\r\n移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器\r\n\r\nvar callback = function(stream){\r\n    console.log(\'someone connected\');\r\n};\r\n\r\nserver.on(\'connection\',callback);\r\n//...\r\nserver.removeListener(\'connection\',callback);\r\n\r\n5.removeAllListener([event])\r\n移除所有事件的所有监听器，如果指定事件，则移除指定事件的所有监听器\r\n\r\n6.setMaxListener(n)\r\n默认情况下，eventemitter 如果你添加的监听器超过10个就会输出警告信息\r\nsetMaxListener函数用于提高监听器的默认限制的数量\r\n\r\n7.listeners(event)\r\n返回指定事件的监听器数组。\r\n\r\n8.emit(event, [arg1], [arg2], [...])\r\n按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。\r\n```\r\n\r\n类方法\r\n```\r\nlistener Count(emitter,event)\r\n返回指定事件的监听器数量\r\n```\r\n事件\r\n```\r\n1.newListener\r\nevent - 字符串，事件名称\r\nlistener 处理事件函数\r\n该事件在添加新监听器时备触发\r\n\r\n2.removeListener\r\nevent - 字符串，事件名称\r\nlistener 处理事件函数\r\n从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。\r\n```\r\n\r\n```\r\n/**\r\n * Created by hoyin on 2016/8/17.\r\n */\r\nvar events = require(\'events\');\r\nvar eventEmitter = new events.EventEmitter();\r\n// 监听器 #1\r\nvar listener1 = function(){\r\n        console.log(\'listener1 running\');\r\n\r\n};\r\n// 监听器 #2\r\nvar listener2 = function(){\r\n        console.log(\'listener2 running\');\r\n};\r\n\r\n// 绑定 connection 事件，处理函数为 listener1 \r\neventEmitter.addListener(\'connection\',listener1);\r\n\r\n// 绑定 connection 事件，处理函数为 listener2\r\neventEmitter.on(\'connection\',listener2);\r\n\r\nvar eventListeners = require(\'events\').EventEmitter.listenerCount(eventEmitter,\'connection\');\r\n\r\nconsole.log(eventListeners + \'个监听器事件\');\r\n\r\n// 处理 connection 事件 \r\neventEmitter.emit(\'connection\');\r\n\r\n// 移除监绑定的 listener1 函数\r\neventEmitter.removeListener(\'connection\',listener1);\r\n\r\nconsole.log(\'remove listener1\');\r\n\r\n// 触发连接事件\r\neventEmitter.emit(\'connection\');\r\n\r\neventListeners = require(\'events\').EventEmitter.listenerCount(eventEmitter,\'connection\');\r\n\r\nconsole.log(eventListeners + \'个监听器事件\');\r\n\r\nconsole.log(\'end!!!!!!!!!!!!!!!!!!!!!!!!!\');\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(194,'node.js error','194',1471414920,1479288552,'<!--markdown-->EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。\r\n\r\n当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。\r\n\r\n我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\r\n```\r\nvar events = require(\'events\');\r\nvar emitter = new event.EventEmitter();\r\nemitter.emit(\'error\');\r\n```\r\n 运行时会显示以下错误：\r\n```\r\nnode.js:201 \r\nthrow e; // process.nextTick error, or \'error\' event on first tick \r\n^ \r\nError: Uncaught, unspecified \'error\' event. \r\nat EventEmitter.emit (events.js:50:15) \r\nat Object.<anonymous> (/home/byvoid/error.js:5:9) \r\nat Module._compile (module.js:441:26) \r\nat Object..js (module.js:459:10) \r\nat Module.load (module.js:348:31) \r\nat Function._load (module.js:308:12) \r\nat Array.0 (module.js:479:10) \r\nat EventEmitter._tickCallback (node.js:192:40) ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(195,'node.js 继承EventEmitter','195',1471415100,1479288546,'<!--markdown--> 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\r\n\r\n为什么要这样做呢？原因有两点：\r\n\r\n首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。\r\n\r\n其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(196,'node.js buffer 创建','196',1471415700,1479288541,'<!--markdown-->JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\r\n\r\n但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\r\n\r\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\r\n\r\n创建 Buffer 类\r\n```\r\n1.创建长度为10 字节的Buffer 实例\r\n\r\nvar buf = new Buffer(10);\r\n\r\n2.通过给定的数组创建Buffer实例\r\n\r\nvar buf = new Buffer([10,20,30,40,50]);\r\n\r\n3.通过一个字符串来创建Buffer实例\r\n\r\nvar buf = new Buffer(\'www.hoyins.com\',\'utf-8\');\r\n\r\nutf-8 是默认的编码方式，此外它同样支持以下编码：\"ascii\", \"utf8\", \"utf16le\", \"ucs2\", \"base64\" 和 \"hex\"。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(197,'node.js buffer write','197',1471416060,1479288536,'<!--markdown-->写入缓冲区\r\n```\r\nbuf.write(string[,offset[,length][,encoding]])\r\n\r\nstring：写入缓冲区的字符串\r\noffset：缓冲区开始写入的索引值，默认 0\r\nlength：写入的字节数，默认buffer.length\r\nencoding：使用编码 默认 utf-8\r\n\r\n返回值\r\n返回实际写入的大小，如果buffer空间不足，则会写入部分字符串\r\n\r\nbuf = new Buffer(256);\r\nlen = buf.write(\'www.runoob.com\');\r\n\r\nconsole.log(\'写入字节数\' + len);\r\n\r\n$node main.js\r\n写入字节数 14\r\n```\r\n从缓冲区读取数据\r\n```\r\nbuf.toString([encoding[,start[,end]]])\r\n\r\nencoding: 使用的编码 默认 utf-8\r\nstart：指定开始读取的索引位置。默认 0\r\nebd：  结束位置，默认为缓存区的末尾\r\n\r\n返回值\r\n解码缓冲区数据并使用指定的编码返回字符串\r\n\r\nbuf = new Buffer(25);\r\nfor(var i=0; i < 26; i++){\r\n    buf[i] = i + 97;\r\n}\r\n\r\nconsole.log( buf.toString(\'ascii\'));       // 输出: abcdefghijklmnopqrstuvwxyz\r\nconsole.log( buf.toString(\'ascii\',0,5));   // 输出: abcde\r\nconsole.log( buf.toString(\'utf8\',0,5));    // 输出: abcde\r\nconsole.log( buf.toString(undefined,0,5)); // 使用 \'utf8\' 编码, 并输出: abcde\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(198,'node.js buffer tojson','198',1471417380,1479288529,'<!--markdown-->```\r\nbuf.toJSON\r\n\r\nvar buf = new Buffer(\'www.hoyins.com\');\r\nvar json =buf.toJSON(buf);\r\n\r\nconsole.log(json)\r\n\r\n{ type: \'Buffer\',\r\n  data: [ 119, 119, 119, 46, 104, 111, 121, 105, 110, 115, 46, 99, 111, 109 ] }',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(199,'node.js buffer 缓冲区合并 concat ','199',1471417740,1479288523,'<!--markdown-->```\r\nBuffer.concat(list[,totalLength])\r\n\r\nlist：用于合并的buffer对象数组列表\r\ntotollength： 指定合并后buffer对象的总长度\r\n\r\n返回值\r\n\r\n返回一个多个成员合并的新 Buffer 对象。\r\n\r\nvar buffer1 = new Buffer(\'www.hoyins.com\');\r\nvar buffer2 = new Buffer(\'hoyin的个人网站\');\r\n\r\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\r\nconsole.log(\'buffer3内容 ：\' + buffer3.toString());',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(200,'node.js buffer 缓冲区比较 compare ','200',1471419120,1479288513,'<!--markdown-->buf.compare(otherBuffer);\r\notherBuffer： 与buf对象比较的另外一个Buffer对象\r\n返回值\r\n返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同\r\n```\r\nvar buffer1 = new Buffer(\'ABC\');\r\nvar buffer2 = new Buffer(\'ABCD\');\r\nvar result = buffer1.compare(buffer2);\r\n\r\nif(result < 0) {\r\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\r\n}else if(result == 0){\r\n   console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\r\n}else {\r\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\r\n}\r\n\r\n\r\nABC在ABCD之前',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(201,'node.js buffer  拷贝缓冲区 copy','201',1471420020,1479288499,'<!--markdown-->```\r\nbuf.copy(targetBuffer[,targetstart[,sourcestart[,sourceend]]]);\r\n\r\ntargetbuffer:要拷贝的对象\r\ntargetstart：数字，可选 默认0\r\nsourcestart：数字，可选 默认0\r\nsourceend ： 数字，可选 默认：buffer.length\r\n```\r\n返回值\r\n没有返回值\r\n```\r\nvar buffer1 = new Buffer(\'abc\');\r\nvar buffer2 = new Buffer(3);\r\n\r\nbuffer1.copy(buffer2);\r\nconsole.log(buffer2.toString());\r\n\r\n\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(202,'node.js buffer 缓冲区裁剪 slice','202',1471420920,1479288494,'<!--markdown-->buf.slice([start[,end]])\r\n\r\nstart: 数字 可选 默认0\r\nend  ：数字 可选 默认0\r\n\r\n返回值\r\n返回一个新的缓冲区 他和旧缓冲区指向同一块内存 但是从索引start 到end 位置裁剪\r\n```\r\nvar buffer1 = new Buffer(\'runoob\');\r\n\r\nvar buffer2 = buffer1.slice(0,2);\r\n\r\nconsole.log(buffer2.toString());\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(203,'node.js buffer 缓冲区长度 length','203',1471423200,1479288487,'<!--markdown-->```\r\nbuf.length\r\n\r\nvar buffer = new Buffer(\'www.hoyins.com\');\r\nconsole.log(buffer.length);\r\n\r\n14',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(204,'node.js stream','204',1471426560,1479288470,'<!--markdown-->Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 \r\nNode.js，Stream 有四种流类型：\r\n\r\n    Readable - 可读操作。\r\n\r\n    Writable - 可写操作。\r\n\r\n    Duplex - 可读可写操作.\r\n\r\n    Transform - 操作被写入数据，然后读出结果。\r\n\r\n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\r\n\r\n    data - 当有数据可读时触发。\r\n\r\n    end - 没有更多的数据可读时触发。\r\n\r\n    error - 在接收和写入过程中发生错误时触发。\r\n\r\n    finish - 所有数据已被写入到底层系统时触发。\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(207,'node.js stream write','207',1471433100,1479288457,'<!--markdown-->```\r\nvar fs = require(\'fs\');\r\nvar data = \'www.hoyins.com\';\r\n\r\n//创建一个可以写入的流，写入outpt.txt中\r\nvar writeStream = fs.createWriteStream(\'outpt.txt\');\r\n\r\n//使用 utf8编码写入数据\r\nwriteStream.write(data,\'UTF8\');\r\n\r\n// 标记文件末尾\r\nwriteStream.end();\r\n\r\n// 处理流事件 --> data, end, and error\r\nwriteStream.on(\'finish\',function () {\r\n    console.log(\'写入完成\');\r\n});\r\n\r\nwriteStream.on(\'error\',function (err) {\r\n    console.log(err.stack);\r\n});\r\n\r\nconsole.log(\'end!!!!!!!!!!!!\');',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(208,'node.js 模块系统','208',1471434720,1479288452,'<!--markdown-->```\r\n//hello.js \r\nfunction Hello() { \r\n	var name; \r\n	this.setName = function(thyName) { \r\n		name = thyName; \r\n	}; \r\n	this.sayHello = function() { \r\n		console.log(\'Hello \' + name); \r\n	}; \r\n}; \r\nmodule.exports = Hello;\r\n```\r\n\r\n```\r\n//main.js \r\nvar Hello = require(\'./hello\'); \r\nhello = new Hello(); \r\nhello.setName(\'BYVoid\'); \r\nhello.sayHello(); ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(206,'node.js stream read','206',1471432920,1479288465,'<!--markdown-->```\r\nvar fs = require(\'fs\');\r\nvar data = \'\';\r\n\r\n//创建可读入流\r\nvar readerStream = fs.createReadStream(\'input.txt\');\r\n\r\n//设置编码\r\nreaderStream.setEncoding(\'UTF8\');\r\n\r\n//处理流事件 --> data ，end ，error\r\nreaderStream.on(\'data\',function (chunk) {\r\n    data += chunk;\r\n});\r\n\r\nreaderStream.on(\'end\',function () {\r\n        console.log(data);\r\n});\r\n\r\nreaderStream.on(\'error\',function (err) {\r\n    console.log(err.stack);\r\n});\r\n\r\nconsole.log(\'end!!!!!!!!!!!!!!!!\');',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(209,'node.js function','209',1471435680,1479288435,'<!--markdown-->在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\r\n\r\nNode.js中函数的使用与Javascript类似，举例来说，你可以这样做： \r\n```\r\nfunction say(word){\r\n    console.log(word);\r\n};\r\n\r\nfunction execute(someFunction,value){\r\n    someFunction(value);\r\n}\r\n\r\nexecute(say,\'hello\');\r\n```\r\n 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！\r\n\r\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\r\n\r\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(210,'node.js 匿名函数','210',1471435860,1479288428,'<!--markdown-->我们可以把一个函数作为变量传递。但是我们不一定要绕这个\"先定义，再传递\"的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\r\n```\r\nfunction execute(someFunction,value){\r\n    someFunction(value);\r\n};\r\n```\r\n```\r\nexecute(function(word){console.log(\'word\')},\'hello\');\r\n```\r\n我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。\r\n\r\n用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(211,'node.js 函数传递让http 服务器工作','211',1471436100,1479288423,'<!--markdown-->```\r\nvar http = require(\'http\');\r\n\r\nhttp.createServer(function(request,response){\r\n    response.writeHead(200,{\"Content-Type\":\"text/plain\"});\r\n    response.write(\"hello world\");\r\n    response.end();\r\n}).listen(8888);\r\n```\r\n```\r\n\r\nvar http = require(\'http\');\r\n\r\nfucntion onrequest(request,response){\r\n    response.writeHead(200,{\"Content-Type\":\"text/plain\"});\r\n    response.write(\'hellow world\');\r\n    response.end();\r\n};\r\n\r\nhttp.createServer(onrequest).listen(8888);\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(212,'node.js mysql','212',1471439340,1479288418,'<!--markdown-->[node.js mysql node 连接 mysql][1]\r\n\r\n\r\n  [1]: http://blog.csdn.net/gebitan505/article/details/46346917#',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(214,'node.js callback','214',1472286540,1479288403,'<!--markdown-->```\r\nvar doit = function(callback)\r\n{\r\n	var a = 1,\r\n	    b = 2,\r\n	    c = 3;\r\n	var t = callback(a,b,c);\r\n	return t + 10;\r\n};\r\nvar d = doit(function(x,y,z){\r\n	return (x+y+z);\r\n});\r\nconsole.log(d);\r\n```\r\n这里是把匿名函数\r\n```\r\nfunction(x,yzx){\r\n    return (x+y+z);\r\n}\r\n```\r\n当做变量传递 doit(callback); \r\n当doit执行到callback,执行传递的函数体 \r\n```\r\nt = function(a,b,c){\r\n    return (a+b+c);\r\n}\r\n```\r\n\r\n\r\n先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。\r\n\r\n下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。\r\n\r\n上述代码的执行过程是：\r\n\r\n调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(220,'Redis Hash','220',1472730540,1479289659,'<!--markdown-->Redis 哈希(Hash)\r\n\r\nRedis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。\r\n\r\nRedis 中每个 hash 可以存储 2​<sup>32</sup>-1 键值对（40多亿）。 \r\n\r\nRedis哈希是键值对的集合。 Redis哈希是字符串字段和字符串值之间的映射，所以它们用来表示对\r\n\r\n```\r\nredis 127.0.0.1:6379> HMSET user:1 username hoyin password hoyin points 200\r\nOK\r\nredis 127.0.0.1:6379> HGETALL user:1\r\n\r\n1) \"username\"\r\n2) \"hoyin\"\r\n3) \"password\"\r\n4) \"hoyin\"\r\n5) \"points\"\r\n6) \"200\"\r\n```\r\n\r\n在上面的例子中，哈希数据类型用于存储包含用户基本信息的用户对象。这里 HSET，HEXTALL 是 Redis 命令同时 user:1 也是一个键。 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(221,'mysql  存在更新，不存在插入','221',1473139920,1479289700,'<!--markdown-->a 为主键或者被定义为UNIQUE \r\n```\r\ninsert into test (a,b,c)values(1,2,3) on duplicate key update c= c+ 1;\r\n```\r\n\r\n```\r\nmysql> INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1; \r\nmysql> UPDATE table SET c=c+1 WHERE a=1; \r\n```\r\n```\r\n如有数据存在且 a = 1,  UPDATE table SET c=c+1 WHERE a=1;\r\n若无数据              INSERT INTO table (a,b,c) VALUES (1,2,3);\r\n```\r\n```\r\nnode mysql\r\nINSERT INTO test set a= ? ,b = ? ,c = ? ON DUPLICATE KEY UPDATE c = ?,[a,b,c,c];\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(217,'Redis ','217',1472727060,1479289691,'<!--markdown--> Redis 有三个主要使其有别于其它很多竞争对手的特点：\r\n\r\n    Redis是完全在内存中保存数据的数据库，使用磁盘只是为了持久性目的； \r\n    Redis相比许多键值数据存储系统有相对丰富的数据类型； \r\n    Redis可以将数据复制到任意数量的从服务器中； \r\n\r\nRedis优点\r\n\r\n    异常快速 : Redis是非常快的，每秒可以执行大约110000设置操作，81000个/每秒的读取操作。\r\n\r\n    支持丰富的数据类型 : Redis支持最大多数开发人员已经知道如列表，集合，可排序集合，哈希等数据类型。\r\n    这使得在应用中很容易解决的各种问题，因为我们知道哪些问题处理使用哪种数据类型更好解决。\r\n\r\n    操作都是原子的 : 所有 Redis 的操作都是原子，从而确保当两个客户同时访问 Redis 服务器得到的是更新后的值（最新值）。\r\n    MultiUtility工具：Redis是一个多功能实用工具，可以在很多如：缓存，消息传递队列中使用（Redis原生支持发布/订阅），在应用程序中，如：Web应用程序会话，网站页面点击数等任何短暂的数据；\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(218,'Redis install Ubuntu ','218',1472727120,1479289684,'<!--markdown--> 要在 Ubuntu 上安装 Redis，打开终端，然后输入以下命令：\r\n```\r\n$sudo apt-get update\r\n$sudo apt-get install redis-server\r\n```\r\n这将在您的计算机上安装Redis\r\n\r\n启动 Redis\r\n```\r\n$redis-server\r\n```\r\n查看 redis 是否还在运行\r\n```\r\n$redis-cli\r\n```\r\n这将打开一个 Redis 提示符，如下图所示：\r\n```\r\nredis 127.0.0.1:6379>\r\n```\r\n在上面的提示信息中：127.0.0.1 是本机的IP地址，6379是 Redis 服务器运行的端口。现在输入 PING 命令，如下图所示：\r\n```\r\nredis 127.0.0.1:6379> ping\r\nPONG\r\n```\r\n这说明现在你已经成功地在计算机上安装了 Redis。 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(219,'Redis String','219',1472730300,1479289676,'<!--markdown-->Redis 字符串是一个字节序列。在 Redis 中字符串是二进制安全的，这意味着它们没有任何特殊终端字符来确定长度，所以可以存储任何长度为 512 兆的字符串。 \r\n```\r\nredis 127.0.0.1:6379> SET name \"hoyin\"\r\nOK\r\nredis 127.0.0.1:6379> GET name\r\n\"hoyin\"\r\n```\r\n\r\n在上面的例子中，SET 和 GET 是 Redis 命令，name 和 \"hoyin\" 是存储在 Redis 的键和字符串值。 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(222,'MongoDb','222',1473250320,1479289802,'<!--markdown-->NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。\r\n\r\nNoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。\r\n\r\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\r\n\r\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\r\n\r\n    MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。\r\n    你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=\"Sameer\",Address=\"8 Gandhi Road\")来实现更快的排序。\r\n    你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。\r\n    如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。\r\n    Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。\r\n    MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。\r\n    Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。\r\n    Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。\r\n    Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。\r\n    GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。\r\n    MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。\r\n    MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。\r\n    MongoDB安装简单。\r\n\r\nNoSQL的优点/缺点\r\n\r\n优点:\r\n\r\n    - 高可扩展性\r\n    - 分布式计算\r\n    - 低成本\r\n    - 架构的灵活性，半结构化数据\r\n    - 没有复杂的关系 \r\n\r\n缺点:\r\n\r\n    - 没有标准化\r\n    - 有限的查询功能（到目前为止）\r\n    - 最终一致是不直观的程序',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(224,'MongoDB show dbs','224',1473250560,1479289796,'<!--markdown-->一个mongodb中可以建立多个数据库。\r\n\r\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\r\n\r\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\r\n\r\n\"show dbs\" 命令可以显示所有数据的列表。\r\n\r\n```\r\n$ ./mongo\r\nMongoDB shell version: 3.0.6\r\nconnecting to: test\r\n> show dbs\r\nlocal  0.078GB\r\ntest   0.078GB\r\n> \r\n```\r\n执行 \"db\" 命令可以显示当前数据库对象或集合。\r\n```\r\n$ ./mongo\r\nMongoDB shell version: 3.0.6\r\nconnecting to: test\r\n> db\r\ntest\r\n> \r\n```\r\n运行\"use\"命令，可以连接到一个指定的数据库。\r\n```\r\n> use local\r\nswitched to db local\r\n> db\r\nlocal\r\n> \r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(225,'MongoDB 数据类型','225',1473250680,1479289789,'<!--markdown-->```\r\n数据类型 	     描述\r\nString          字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。\r\nInteger	        整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。\r\nBoolean	        布尔值。用于存储布尔值（真/假）。\r\nDouble	        双精度浮点值。用于存储浮点值。\r\nMin/Max keys	将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。\r\nArrays	        用于将数组或列表或多个值存储为一个键。\r\nTimestamp	    时间戳。记录文档修改或添加的具体时间。\r\nObject	        用于内嵌文档。\r\nNull	        用于创建空值。\r\nSymbol	        符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。\r\nDate	        日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。\r\nObject ID	    对象 ID。用于创建文档的 ID。\r\nBinary Data	    二进制数据。用于存储二进制数据。\r\nCode	        代码类型。用于在文档中存储 JavaScript 代码。\r\nRegular expression	正则表达式类型。用于存储正则表达式。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(226,'MongoDB 连接命令格式','226',1473250920,1479289783,'<!--markdown-->使用用户名和密码连接到MongoDB服务器，你必须使用 \'username:password@hostname/dbname\' 格式，\'username\'为用户名，\'password\' 为密码。\r\n使用用户名和密码连接登陆到默认数据库：\r\n```\r\n$ ./mongo\r\nMongoDB shell version: 3.0.6\r\nconnecting to: test\r\nmongodb://admin:123456@localhost/\r\n```\r\n连接到指定数据库的格式如下：\r\n```\r\nmongodb://admin:123456@localhost/test\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(227,'MongoDB 创建数据库','227',1473251040,1479289778,'<!--markdown-->MongoDB 创建数据库\r\n语法\r\n\r\nMongoDB 创建数据库的语法格式如下：\r\n```\r\nuse DATABASE_NAME\r\n```\r\n如果数据库不存在，则创建数据库，否则切换到指定数据库。\r\n实例\r\n\r\n以下实例我们创建了数据库 runoob:\r\n```\r\n> use runoob\r\nswitched to db runoob\r\n> db\r\nrunoob\r\n> \r\n```\r\n如果你想查看所有数据库，可以使用 show dbs 命令：\r\n```\r\n> show dbs\r\nlocal  0.078GB\r\ntest   0.078GB\r\n> \r\n```\r\n可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中， 要显示它，我们需要向 runoob 数据库插入一些数据。\r\n```\r\n> db.runoob.insert({\"name\":\"hoyin\"})\r\nWriteResult({ \"nInserted\" : 1 })\r\n> show dbs\r\nlocal   0.078GB\r\nrunoob  0.078GB\r\ntest    0.078GB\r\n> \r\n```\r\nMongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(228,'MongoDB 删除数据库','228',1473251100,1479289774,'<!--markdown-->MongoDB 删除数据库\r\n语法\r\n\r\nMongoDB 删除数据库的语法格式如下：\r\n```\r\ndb.dropDatabase()\r\n```\r\n\r\n删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。\r\n实例\r\n\r\n以下实例我们删除了数据库 runoob。\r\n\r\n首先，查看所有数据库：\r\n```\r\n> show dbs\r\nlocal   0.078GB\r\nrunoob  0.078GB\r\ntest    0.078GB\r\n```\r\n接下来我们切换到数据库 runoob：\r\n```\r\n> use runoob\r\nswitched to db runoob\r\n> \r\n```\r\n执行删除命令：\r\n```\r\n> db.dropDatabase()\r\n{ \"dropped\" : \"runoob\", \"ok\" : 1 }\r\n```\r\n最后，我们再通过 show dbs 命令数据库是否删除成功：\r\n```\r\n> show dbs\r\nlocal  0.078GB\r\ntest   0.078GB\r\n> \r\n```\r\n删除集合\r\n\r\n集合删除语法格式如下：\r\n```\r\ndb.collection.drop()\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(229,'MongoDB 插入文档','229',1473251220,1479289769,'<!--markdown-->MongoDB 插入文档\r\n\r\n本章节中我们将向大家介绍如何将数据插入到MongoDB的集合中。\r\n\r\n文档的数据结构和JSON基本一样。\r\n\r\n所有存储在集合中的数据都是BSON格式。\r\n\r\nBSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。\r\n插入文档\r\n\r\nMongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：\r\n```\r\ndb.COLLECTION_NAME.insert(document)\r\n```\r\n实例\r\n\r\n以下文档可以存储在 MongoDB 的 runoob 数据库 的 col集合中：\r\n```\r\n>db.col.insert({\r\n    title: \'MongoDB 教程\', \r\n    description: \'MongoDB 是一个 Nosql 数据库\',\r\n    by: \'hoyin\',\r\n    url: \'http://www.hoyins.com\',\r\n    tags: [\'mongodb\', \'database\', \'NoSQL\'],\r\n    likes: 100\r\n})\r\n```\r\n以上实例中 col 是我们的集合名，前一章节我们已经创建过了，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。\r\n\r\n查看已插入文档：\r\n```\r\n> db.col.find()\r\n{ \"_id\" : ObjectId(\"56064886ade2f21f36b03134\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"hoyin\", \"url\" : \"http://www.hoyins.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100 }\r\n> \r\n```\r\n我们也可以将数据定义为一个变量，如下所示：\r\n```\r\n> document=({\r\n    title: \'MongoDB 教程\', \r\n    description: \'MongoDB 是一个 Nosql 数据库\',\r\n    by: \'hoyin\',\r\n    url: \'http://www.hoyins.com\',\r\n    tags: [\'mongodb\', \'database\', \'NoSQL\'],\r\n    likes: 100\r\n});\r\n```\r\n执行后显示结果如下：\r\n```\r\n{\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"菜鸟教程\",\r\n        \"url\" : \"http://www.runoob.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n```\r\n执行插入操作：\r\n```\r\n> db.col.insert(document)\r\nWriteResult({ \"nInserted\" : 1 })\r\n> \r\n```\r\n插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(230,'MongoDB 更新文档','230',1473252420,1479289764,'<!--markdown-->**MongoDB 更新文档**\r\n\r\nMongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。\r\n**update() 方法**\r\n\r\nupdate() 方法用于更新已存在的文档。语法格式如下：\r\n```\r\ndb.collection.update(\r\n   <query>,\r\n   <update>,\r\n   {\r\n     upsert: <boolean>,\r\n     multi: <boolean>,\r\n     writeConcern: <document>\r\n   }\r\n)\r\n```\r\n参数说明：\r\n\r\n    query : update的查询条件，类似sql update查询内where后面的。\r\n    update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\r\n    upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\r\n    multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\r\n    writeConcern :可选，抛出异常的级别。\r\n\r\n实例\r\n\r\n我们在集合 col 中插入如下数据：\r\n```\r\n>db.col.insert({\r\n    title: \'MongoDB 教程\', \r\n    description: \'MongoDB 是一个 Nosql 数据库\',\r\n    by: \'菜鸟教程\',\r\n    url: \'http://www.runoob.com\',\r\n    tags: [\'mongodb\', \'database\', \'NoSQL\'],\r\n    likes: 100\r\n})\r\n```\r\n接着我们通过 update() 方法来更新标题(title):\r\n```\r\n>db.col.update({\'title\':\'MongoDB 教程\'},{$set:{\'title\':\'MongoDB\'}})\r\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })   # 输出信息\r\n> db.col.find().pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\r\n        \"title\" : \"MongoDB\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"菜鸟教程\",\r\n        \"url\" : \"http://www.runoob.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n>\r\n```\r\n可以看到标题(title)由原来的 \"MongoDB 教程\" 更新为了 \"MongoDB\"。\r\n\r\n以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。\r\n```\r\n>db.col.update({\'title\':\'MongoDB 教程\'},{$set:{\'title\':\'MongoDB\'}},{multi:true})\r\n```\r\n**save() 方法**\r\n\r\nsave() 方法通过传入的文档来替换已有文档。语法格式如下：\r\n```\r\ndb.collection.save(\r\n   <document>,\r\n   {\r\n     writeConcern: <document>\r\n   }\r\n)\r\n```\r\n参数说明：\r\n\r\n    document : 文档数据。\r\n    writeConcern :可选，抛出异常的级别。\r\n\r\n实例\r\n\r\n以下实例中我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据：\r\n```\r\n>db.col.save({\r\n	\"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\r\n    \"title\" : \"MongoDB\",\r\n    \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n    \"by\" : \"Runoob\",\r\n    \"url\" : \"http://www.runoob.com\",\r\n    \"tags\" : [\r\n            \"mongodb\",\r\n            \"NoSQL\"\r\n    ],\r\n    \"likes\" : 110\r\n})\r\n```\r\n替换成功后，我们可以通过 find() 命令来查看替换后的数据\r\n```\r\n>db.col.find().pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\r\n        \"title\" : \"MongoDB\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"Runoob\",\r\n        \"url\" : \"http://www.runoob.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 110\r\n}\r\n> \r\n```\r\n更多实例\r\n\r\n只更新第一条记录：\r\n```\r\ndb.col.update( { \"count\" : { $gt : 1 } } , { $set : { \"test2\" : \"OK\"} } );\r\n```\r\n全部更新：\r\n```\r\ndb.col.update( { \"count\" : { $gt : 3 } } , { $set : { \"test2\" : \"OK\"} },false,true );\r\n```\r\n只添加第一条：\r\n```\r\ndb.col.update( { \"count\" : { $gt : 4 } } , { $set : { \"test5\" : \"OK\"} },true,false );\r\n```\r\n全部添加加进去:\r\n```\r\ndb.col.update( { \"count\" : { $gt : 5 } } , { $set : { \"test5\" : \"OK\"} },true,true );\r\n```\r\n全部更新：\r\n```\r\ndb.col.update( { \"count\" : { $gt : 15 } } , { $inc : { \"count\" : 1} },false,true );\r\n```\r\n只更新第一条记录：\r\n```\r\ndb.col.update( { \"count\" : { $gt : 10 } } , { $inc : { \"count\" : 1} },false,false );\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(235,'Linux Alias','235',1473305280,1479288391,'<!--markdown-->只需当前用户使用：\r\n```\r\nvim ~/.bashrc\r\n```\r\n所有用户使用：\r\n```\r\nvim /etc/bashrc\r\n```\r\n添加内容：\r\n```\r\nalias c=\'clear\'                          执行系统命令\r\nalias cdgs=\'cd /home/hoyin/gameServer\'   cd目录\r\nalias shell=\'/home/hoyin/test.sh\'        执行脚本\r\n在最底层添加即可\r\n```\r\n修改完毕后需要执行以下代码方可生效：\r\n```\r\nsource ~/.bashrc\r\n```\r\nor\r\n```\r\nsource /etc/bashrc',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(237,'git branch','237',1473672840,1479288373,'<!--markdown-->查看本地和远程分支  -a。前面带*号的代表你当前工作目录所处的分支\r\n**查看远程分支**\r\n```\r\ngit branch -a\r\n```\r\n**查看本地分支**\r\n```\r\ngit branch / git br\r\n```\r\n**创建分支**\r\n```\r\ngit branch test\r\n```\r\n**切换分支**\r\n```\r\ngit checkout test\r\n```\r\n**删除本地分支**\r\n```\r\ngit branch -d  test \r\n```\r\n[参考][1]\r\n\r\n\r\n  [1]: http://blog.csdn.net/arkblue/article/details/9568249/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(239,'git cherry','239',1473734100,1479288363,'<!--markdown-->显示在当前分支 origin/master 下的提交状态\r\n```\r\ngit cherry origin/master\r\n\r\n[vagrant@localhost dongyu-server]$ git cherry origin/master\r\n+ 2168e2dcd1f38439704ce60ee2b0477232aa337f\r\n+ 5155de924c1eb900e555d456930829109c440386\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(240,'Redis 订阅发布','240',1473739140,1479289648,'<!--markdown-->我们创建了订阅频道名为 redisChat:\r\n**subscribe**\r\n```\r\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\r\n\r\nReading messages... (press Ctrl-C to quit)\r\n1) \"subscribe\"\r\n2) \"redisChat\"\r\n3) (integer) 1\r\n```\r\n\r\n我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。\r\n**publish**\r\n```\r\nredis 127.0.0.1:6379> PUBLISH redisChat \"Redis is a great caching technique\"\r\n\r\n(integer) 1\r\n\r\nredis 127.0.0.1:6379> PUBLISH redisChat \"Learn redis by runoob.com\"\r\n\r\n(integer) 1\r\n\r\n# 订阅者的客户端会显示如下消息\r\n1) \"message\"\r\n2) \"redisChat\"\r\n3) \"Redis is a great caching technique\"\r\n1) \"message\"\r\n2) \"redisChat\"\r\n3) \"Learn redis by runoob.com\"\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(241,'Redis Pubsub 命令','241',1473739320,1479289639,'<!--markdown--> **Redis Pubsub 命令用于查看订阅与发布系统状态，它由数个不同格式的子命令组成**。\r\n语法\r\n\r\nredis Pubsub 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> PUBSUB <subcommand> [argument [argument ...]]\r\n```\r\n可用版本\r\n```\r\n>= 2.8.0\r\n```\r\n返回值\r\n```\r\n由活跃频道组成的列表。\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> PUBSUB CHANNELS\r\n(empty list or set)\r\n\r\n127.0.0.1:6379> pubsub channels\r\n1) \"Guild\"\r\n2) \"Friend\"\r\n3) \"World\"\r\n4) \"Notice\"\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(234,'MongoDB 查询文档','234',1473252780,1479289751,'<!--markdown-->MongoDB 查询文档\r\n语法\r\n\r\nMongoDB 查询数据的语法格式如下：\r\n```\r\n>db.COLLECTION_NAME.find()\r\n```\r\nfind() 方法以非结构化的方式来显示所有文档。\r\n\r\n如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：\r\n```\r\n>db.col.find().pretty()\r\n```\r\npretty() 方法以格式化的方式来显示所有文档。\r\n实例\r\n\r\n以下实例我们查询了集合 col 中的数据：\r\n```\r\n> db.col.find().pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"hoyin\",\r\n        \"url\" : \"http://www.hoyins.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n```\r\n除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。\r\nMongoDB 与 RDBMS Where 语句比较\r\n```\r\n如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：\r\n操作 	格式 	范例 	RDBMS中的类似语句\r\n等于 	        {<key>:<value>} 	db.col.find({\"by\":\"hoyin\"}).pretty() 	where by = \'hoyin\'\r\n小于 	        {<key>:{$lt:<value>}} 	db.col.find({\"likes\":{$lt:50}}).pretty() 	where likes < 50\r\n小于或等于 	  {<key>:{$lte:<value>}} 	db.col.find({\"likes\":{$lte:50}}).pretty() 	where likes <= 50\r\n大于 	        {<key>:{$gt:<value>}} 	db.col.find({\"likes\":{$gt:50}}).pretty() 	where likes > 50\r\n大于或等于 	  {<key>:{$gte:<value>}} 	db.col.find({\"likes\":{$gte:50}}).pretty() 	where likes >= 50\r\n不等于 	   {<key>:{$ne:<value>}} 	db.col.find({\"likes\":{$ne:50}}).pretty() 	where likes != 50\r\n```\r\n**MongoDB AND 条件**\r\n\r\nMongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。\r\n\r\n语法格式如下：\r\n```\r\n>db.col.find({key1:value1, key2:value2}).pretty()\r\n```\r\n实例\r\n\r\n以下实例通过 by 和 title 键来查询 菜鸟教程 中 MongoDB 教程 的数据\r\n```\r\n> db.col.find({\"by\":\"hoyin\", \"title\":\"MongoDB 教程\"}).pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"hoyin\",\r\n        \"url\" : \"http://www.hoyins.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n```\r\n以上实例中类似于 WHERE 语句：WHERE by=\'菜鸟教程\' AND title=\'MongoDB 教程\'\r\n**MongoDB OR 条件**\r\n\r\nMongoDB OR 条件语句使用了关键字 $or,语法格式如下：\r\n```\r\n>db.col.find(\r\n   {\r\n      $or: [\r\n	     {key1: value1}, {key2:value2}\r\n      ]\r\n   }\r\n).pretty()\r\n```\r\n实例\r\n\r\n以下实例中，我们演示了查询键 by 值为 hoyin或键 title 值为 MongoDB 教程 的文档。\r\n```\r\n>db.col.find({$or:[{\"by\":\"hoyin\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"hoyin\",\r\n        \"url\" : \"http://www.hoyins.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n>\r\n```\r\n**AND 和 OR 联合使用**\r\n\r\n以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： \'where likes>50 AND (by = \'hoyin\' OR title = \'MongoDB 教程\')\'\r\n```\r\n>db.col.find({\"likes\": {$gt:50}, $or: [{\"by\": \"hoyin\"},{\"title\": \"MongoDB 教程\"}]}).pretty()\r\n{\r\n        \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n        \"by\" : \"hoyin\",\r\n        \"url\" : \"http://www.hoyins.com\",\r\n        \"tags\" : [\r\n                \"mongodb\",\r\n                \"database\",\r\n                \"NoSQL\"\r\n        ],\r\n        \"likes\" : 100\r\n}\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(232,'MongoDB 删除文档','232',1473252600,1479289758,'<!--markdown-->**MongoDB 删除文档**\r\n\r\n在前面的几个章节中我们已经学习了MongoDB中如何为集合添加数据和更新数据。在本章节中我们将继续学习MongoDB集合的删除。\r\n\r\nMongoDB remove()函数是用来移除集合中的数据。\r\n\r\nMongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。\r\n语法\r\n\r\n**remove() 方法**\r\n基本语法格式如下所示：\r\n```\r\ndb.collection.remove(\r\n   <query>,\r\n   <justOne>\r\n)\r\n```\r\n如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：\r\n```\r\ndb.collection.remove(\r\n   <query>,\r\n   {\r\n     justOne: <boolean>,\r\n     writeConcern: <document>\r\n   }\r\n)\r\n```\r\n参数说明：\r\n\r\n    query :（可选）删除的文档的条件。\r\n    justOne : （可选）如果设为 true 或 1，则只删除一个文档。\r\n    writeConcern :（可选）抛出异常的级别。\r\n\r\n实例\r\n\r\n以下文档我们执行两次插入操作：\r\n```\r\n>db.col.insert({title: \'MongoDB 教程\', \r\n    description: \'MongoDB 是一个 Nosql 数据库\',\r\n    by: \'hoyin\',\r\n    url: \'http://www.hoyins.com\',\r\n    tags: [\'mongodb\', \'database\', \'NoSQL\'],\r\n    likes: 100\r\n})\r\n```\r\n使用 find() 函数查询数据：\r\n```\r\n> db.col.find()\r\n{ \"_id\" : ObjectId(\"56066169ade2f21f36b03137\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"hoyin\", \"url\" : \"http://www.hoyins.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100 }\r\n{ \"_id\" : ObjectId(\"5606616dade2f21f36b03138\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"hoyin\", \"url\" : \"http://www.hoyins.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100 }\r\n```\r\n接下来我们移除 title 为 \'MongoDB 教程\' 的文档：\r\n```\r\n>db.col.remove({\'title\':\'MongoDB 教程\'})\r\nWriteResult({ \"nRemoved\" : 2 })           # 删除了两条数据\r\n>db.col.find()\r\n……                                        # 没有数据\r\n```\r\n如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：\r\n```\r\n>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\r\n```\r\n如果你想删除所有数据，可以使用以下方式（类似常规 SQL 的 truncate 命令）：\r\n```\r\n>db.col.remove({})\r\n>db.col.find()\r\n>\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(242,'Redis Publish','242',1473739380,1479289633,'<!--markdown--> **Redis Publish 命令用于将信息发送到指定的频道**。\r\n语法\r\n\r\nredis Publish 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> PUBLISH channel message\r\n```\r\n可用版本\r\n```\r\n>= 2.0.0\r\n```\r\n返回值\r\n```\r\n接收到信息的订阅者数量。\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> PUBLISH mychannel \"hello, i m here\"\r\n(integer) 1',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(244,'Redis Punsubscribe 退订','244',1473739500,1479289627,'<!--markdown--> **Redis Punsubscribe 命令用于退订所有给定模式的频道**\r\n语法\r\n\r\nredis Punsubscribe 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> PUNSUBSCRIBE [pattern [pattern ...]]\r\n```\r\n可用版本\r\n```\r\n>= 2.0.0\r\n```\r\n返回值\r\n```\r\n这个命令在不同的客户端中有不同的表现。\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> PUNSUBSCRIBE mychannel \r\n1) \"punsubscribe\"\r\n2) \"a\"\r\n3) (integer) 1',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(318,'tcping','318',1480426308,1480426355,'<!--markdown-->```\r\n服务器所在的机房禁ping ，我如何监控服务器的情况 ？下面和大家介绍一个软件tcping，这个软件是针对TCP监控的，也可以看到ping 值，即使机房禁PING，服务器禁PING了，也可以通过它来监控服务器的情况。除了ping ，它还有一个功能，监听端口的状态。\r\n\r\n接下来介绍一下这个软件的用途，这个软件\r\n\r\n一可以监听服务器的端口状态，默认是80端口的，也可以指定其它端口。\r\n\r\n二可以看到ping 返回的时间，这样可以知道服务器是否有延时或者端口不通的状态。\r\n3\r\n\r\n软件的使用非常简单：\r\n\r\n一、将下载的文件放在C:\\WINDOWS\\system32  目录下，就可以直接使用了。\r\n\r\n二、在windows命令提示符里可以直接使用这个命令了，相关的参数可以自己查询一下，查询的命令是：tcping  /?\r\n\r\n三、简单地举两个例子的使用\r\n\r\ntcping  www.baidu.com\r\n\r\ntcping  -t  www.baidu.com     【参数-t 是让命令一直运行ping 】\r\n\r\ntcping   -d  -t  www.baidu.com   【参数  -d  是显示时间，这样就可以更清楚了】\r\n\r\ntcping  -d  -t  www.baidu.com   21   【这里只是举例，21是您所需要监听的端口，这个可以行定义。】\r\n\r\n软件的使用还有很多的参数，常用的就上面两个参数，大家也可以在使用的过程中打个问号看一下就知道了\r\n\r\nC:\\>tcping--------------------------------------------------------------\r\n\r\ntcping.exe by Eli FulkersonPlease see for updates.--------------------------------------------------------------\r\n\r\nUsage: tcping [-flags] server-address [server-port]Usage (full): tcping [-t] [-d] [-i interval] [-n times] [-w ms] [-b n] [-r times] [-s] [-v] [-j] [--tee filename] [-h] [-u] [--post] [--head] [-f] server-address [server-port]\r\n\r\n-t     : ping continuously until stopped via control-c\r\n\r\n -n 5   : for instance, send 5 pings\r\n\r\n-i 5   : for instance, ping every 5 seconds\r\n\r\n-w 0.5 : for instance, wait 0.5 seconds for a response\r\n\r\n-d     : include date and time on each line\r\n\r\n-b 1   : enable beeps (1 for on-down, 2 for on-up,                        3 for on-change, 4 for always)\r\n\r\n-r 5   : for instance, relookup the hostname every 5 pings\r\n\r\n-s     : automatically exit on a successful ping\r\n\r\n -v     : print version and exit -j [5] : include jitter.  Optional argument controls rolling average size.\r\n\r\n--tee  : mirror output to a filename specified after \'--tee\'\r\n\r\n-4     : prefer ipv4\r\n\r\n-6     : prefer ipv6HTTP Options:\r\n\r\n-h     : HTTP mode (use url without http:// for server-address)\r\n\r\n-u     : include target URL on each line\r\n\r\n --post : use POST rather than GET (may avoid caching) --head : use HEAD rather than GET --proxy-server : specify a proxy server --proxy-port   : specify a proxy portDebug Options:\r\n\r\n-f     : force tcping to send at least one byte        If you don\'t pass server-port, it defaults to 80.C:\\>\r\n\r\n常用的几个参数都已经加粗了，各位有兴趣的网友可以再深入了解下的。蛮有用的一个小软件。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(246,'Redis Subscribe 命令','246',1473739800,1479289622,'<!--markdown--> **Redis Subscribe 命令用于订阅给定的一个或多个频道的信息**\r\n语法\r\n\r\nredis Subscribe 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> SUBSCRIBE channel [channel ...]\r\n```\r\n可用版本\r\n```\r\n>= 2.0.0\r\n```\r\n返回值\r\n```\r\n接收到的信息\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> SUBSCRIBE mychannel \r\nReading messages... (press Ctrl-C to quit)\r\n1) \"subscribe\"\r\n2) \"mychannel\"\r\n3) (integer) 1\r\n1) \"message\"\r\n2) \"mychannel\"\r\n3) \"a\"',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(247,'Redis Unsubscribe 命令','247',1473739860,1479289615,'<!--markdown--> **Redis Unsubscribe 命令用于退订给定的一个或多个频道的信息**\r\n语法\r\n\r\nredis Unsubscribe 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> UNSUBSCRIBE channel [channel ...]\r\n```\r\n可用版本\r\n```\r\n>= 2.0.0\r\n```\r\n返回值\r\n```\r\n这个命令在不同的客户端中有不同的表现。\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> UNSUBSCRIBE mychannel \r\n1) \"unsubscribe\"\r\n2) \"a\"\r\n3) (integer) 0',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(249,'Redis Psubscribe 命令','249',1473739980,1479289608,'<!--markdown--> **Redis Psubscribe 命令订阅一个或多个符合给定模式的频道**\r\n\r\n每个模式以 * 作为匹配符，比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。\r\n语法\r\n\r\nredis Psubscribe 命令基本语法如下：\r\n```\r\nredis 127.0.0.1:6379> PSUBSCRIBE pattern [pattern ...]\r\n```\r\n可用版本\r\n```\r\n>= 2.0.0\r\n```\r\n返回值\r\n```\r\n接收到的信息。\r\n```\r\n实例\r\n```\r\nredis 127.0.0.1:6379> PSUBSCRIBE mychannel\r\nReading messages... (press Ctrl-C to quit)\r\n1) \"psubscribe\"\r\n2) \"mychannel\"\r\n3) (integer) 1',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(252,' Linux里如何查找文件内容 ','252',1474858620,1479288810,'<!--markdown-->\r\nLinux查找文件内容的常用命令方法。  \r\n\r\n从文件内容查找匹配指定字符串的行：\r\n```\r\n$ grep \"被查找的字符串\" 文件名\r\n```\r\n例子：\r\n在当前目录里第一级文件夹中寻找包含指定字符串的.in文件\r\n```\r\ngrep \"thermcontact\" */*.in\r\n```\r\n从文件内容查找与正则表达式匹配的行：\r\n```\r\n$ grep –e “正则表达式” 文件名\r\n```\r\n查找时不区分大小写：\r\n```\r\n$ grep –i \"被查找的字符串\" 文件名\r\n```\r\n查找匹配的行数：\r\n```\r\n$ grep -c \"被查找的字符串\" 文件名\r\n```\r\n\r\n从文件内容查找不匹配指定字符串的行：\r\n```\r\n$ grep –v \"被查找的字符串\" 文件名\r\n```\r\n\r\n从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行\r\n```\r\nfind / -type f -name \"*.log\" | xargs grep \"ERROR\"\r\n```\r\n从根目录开始查找所有扩展名以 Game_error 开头文本文件，并找出包含”ERROR”的行\r\n```\r\nfind / -type f -name \"Game_error*\" | xargs grep \"ERROR\"\r\n```\r\n例子：\r\n从当前目录开始查找所有扩展名为.in的文本文件，并找出包含”thermcontact”的行\r\n```\r\nfind . -name \"*.in\" | xargs grep \"thermcontact\" ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(251,'Linux 基本命令','251',1474204380,1479288344,'<!--markdown-->linux 相关命令\r\n显示日期的指令： date\r\n显示日历的指令：cal\r\n显示当前所在目录：pwd\r\n建立新目录：mkdir\r\n删除『空』的目录：rmdir\r\n档案与目录的显示：ls\r\n复制档案或目录：cp\r\n移除档案或目录：rm\r\n移动档案与目录，或更名：mv\r\n取得路径的文件名与目录名：basename，dirname\r\n由第一行开始显示档案内容：cat\r\n从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）\r\n显示的时候，顺道输出行号：nl\r\n\r\n重要的几个热键[Tab],[ctrl]-c, [ctrl]-d \r\n改变文件的所属群组：chgrp\r\n改变文件拥有者：chown\r\n改变文件的权限：chmod',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(253,'修改linux终端显示目录和主机名称 ','253',1474876320,1479288335,'<!--markdown--> 工作路径太长，一行都挤不下了，怎么办？\r\n修改环境变量PS1（命令行提示符），可以使用vi编辑~/.bashrc文件，在最后加上：\r\n```\r\nvim ~/.bashrc\r\n\r\nexport PS1=\'[\\u@\\h \\W]\\$ \'\r\n\r\nsource ~/.bashrc\r\n```\r\n其中\r\n```\r\n\\u显示当前用户账号，\r\n\\h显示当前主机名，\r\n\\w显示当前完整工作路径（\\W显示当前工作路径），\r\n\\$显示\'$\'符号。 \r\n```\r\n使用方法：\r\n# PS1=\'自定义内容\'\r\n\r\n注意两边的单引号\r\n```\r\n示例： PS1=\'(\\u@\\H \\d \\t)\\$\'\r\n\r\n\\d ：代表日期，格式为weekday month date，例如：\"Mon Aug 1\"\r\n\r\n\\H ：完整的主机名称。例如：我的机器名称为：no.linux，则这个名称就是no.linux\r\n\r\n\\h ：仅取主机的第一个名字，如上例，则为no，.linux则被省略\r\n\r\n\\t ：显示时间为24小时格式，如：HH：MM：SS\r\n\r\n\\T ：显示时间为12小时格式\r\n\r\n\\A ：显示时间为24小时格式：HH：MM\r\n\r\n\\u ：当前用户的账号名称\r\n\r\n\\v ：BASH的版本信息\r\n\r\n\\w ：完整的工作目录名称。家目录会以 ~代替\r\n\r\n\\W ：利用basename取得工作目录名称，所以只会列出最后一个目录\r\n\r\n\\# ：下达的第几个命令\r\n\r\n\\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$\r\n```\r\n==================================================\r\n\r\n我们可以通过设置PS1变量使提示符成为彩色。在PS1中设置字符序列颜色的格式为：\r\n```\r\n\\[\\e[F;Bm\\]\r\n```\r\n其中``F\'\'为字体颜色，编号30~37；``B\'\'为背景色，编号40~47。\r\n可通过``\\e[0m\'\'关闭颜色输出；特别的，当B为1时，将显示加亮加粗的文字，详细请看下面的颜色表与代码表。\r\n\r\n颜色表\r\n\r\n前景 背景 颜色\r\n---------------------------------------\r\n30 40 黑色\r\n31 41 紅色\r\n32 42 綠色\r\n33 43 黃色\r\n34 44 藍色\r\n35 45 紫紅色\r\n36 46 青藍色\r\n37 47 白色\r\n\r\n-------------------------\r\n\r\n如果想要设置终端提示符的样式只要把$PS1在~/.bahrc指定即可比，比如我的设置如下：\r\n```\r\nexport PS1=\"[\\[\\033[01;31m\\]\\u\\[\\033[00m\\]@\\[\\033[01;32m\\]\\H\\[\\033[00m\\] \\[\\033[01;33m\\]\\w\\[\\033[00m\\]]\\[\\033[01;34m\\]$\\[\\033[00m\\]\"\r\n```\r\n```\r\nsource /etc/bashrc',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(319,'Redis ZADD','319',1480753845,1480753973,'<!--markdown-->ZADD key score member [[score member] [score member] ...]\r\n将一个或多个 member 元素及其 score 值加入到有序集 key 当中。\r\n\r\n如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。\r\n\r\nscore 值可以是整数值或双精度浮点数。\r\n\r\n如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。\r\n\r\n当 key 存在但不是有序集类型时，返回一个错误。\r\n```\r\n# 添加单个元素\r\n\r\nredis> ZADD page_rank 10 google.com\r\n(integer) 1\r\n\r\n\r\n# 添加多个元素\r\n\r\nredis> ZADD page_rank 9 baidu.com 8 bing.com\r\n(integer) 2\r\n\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n\r\n\r\n# 添加已存在元素，且 score 值不变\r\n\r\nredis> ZADD page_rank 10 google.com\r\n(integer) 0\r\n\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n\r\n\r\n# 添加已存在元素，但是改变 score 值\r\n\r\nredis> ZADD page_rank 6 bing.com\r\n(integer) 0\r\n\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变\r\n1) \"bing.com\"\r\n2) \"6\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(257,'mysql 结果集 竖行显示','257',1474879860,1479289572,'<!--markdown-->由于Console的宽度有限，因此在查询数据库记录时，就会出现不能在一行完全显示全部字段内容的情况，于是为查询带了很大不便。现在只需在查询语句后面加一个“|G”，就可以实现记录的竖行显示。如下： \r\n\r\n    select * from data_account \\G\r\n\r\n使用这个参数，可以省去后面的分号（;），否则加上分号会出现错误提示，不过可以忽略这个提示 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(259,'Linux 常用查找','259',1474974480,1479288318,'<!--markdown-->**1.vim 中的搜索**\r\n\r\nLinux 下 vim搜索文件内容时加上 \\c 参数可以忽略搜索字符的大小写.\r\n\r\n比如用vim 搜索文件中的 China 时\r\n```\r\n可用 :/china\\c\r\n```\r\n**2. find 搜索**\r\n\r\nLinux使用find命令搜索文件时如果不清楚文件的名称中是否包含的大写，你可以使用 -iname参数来忽略大小写.\r\n```\r\n[root@Blinux test]# ll\r\n\r\n总用量 0\r\n\r\n-rw-rw-r-- 1 Blinux root 0 12月 16 07:42 China\r\n\r\n[root@Blinux test]# find ./ -name china\r\n\r\n[root@Blinux test]# find ./ -iname china\r\n\r\n./China\r\n```\r\n**3.grep 搜索**\r\n\r\n使用管道grep 匹配关键词时如果需要忽略大小写，你可以使用 -i 参数.\r\n```\r\n[root@Blinux test]# rpm -qa|grep virtualbox\r\n\r\n[root@Blinux test]# rpm -qa|grep virtualbox -i\r\n\r\nVirtualBox-3.1-3.1.0_55467_fedora12-1.i686',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(262,'Linux SCP','262',1475047860,1479288302,'<!--markdown-->拷贝远端/root/a文件 到当前目录下\r\n```\r\nscp root@188.166.191.85:/root/a ./\r\n```\r\n拷贝本地文件robot.sh 到远端/root 目录下\r\n```\r\nscp robot.sh root@188.166.191.85:/root\r\n```\r\n-P port  注意是大写的P, port是指定数据传输用到的端口号   \r\n```\r\nscp -P 2222  root@188.166.191.85:/root/a ./\r\nscp -P 2222  robot.sh root@188.166.191.85:/root\r\n```\r\n\r\n*******************************************************************************************\r\n\r\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。\r\n\r\n1．命令格式：\r\n```\r\nscp [参数] [原路径] [目标路径]\r\n```\r\n2．命令功能：\r\n\r\nscp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。\r\n\r\n3．命令参数：\r\n```\r\n-1  强制scp命令使用协议ssh1  \r\n\r\n-2  强制scp命令使用协议ssh2  \r\n\r\n-4  强制scp命令只使用IPv4寻址  \r\n\r\n-6  强制scp命令只使用IPv6寻址  \r\n\r\n-B  使用批处理模式（传输过程中不询问传输口令或短语）  \r\n\r\n-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  \r\n\r\n-p 保留原文件的修改时间，访问时间和访问权限。  \r\n\r\n-q  不显示传输进度条。  \r\n\r\n-r  递归复制整个目录。  \r\n\r\n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   \r\n\r\n-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   \r\n\r\n-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  \r\n\r\n-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    \r\n\r\n-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     \r\n\r\n-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   \r\n\r\n-P port  注意是大写的P, port是指定数据传输用到的端口号   \r\n\r\n-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\r\n```\r\n4．使用实例：\r\n\r\nscp命令的实际应用概述：  \r\n\r\n从本地服务器复制到远程服务器： \r\n\r\n(1) 复制文件：  \r\n\r\n命令格式：  \r\n```\r\nscp local_file remote_username@remote_ip:remote_folder  \r\n```\r\n或者  \r\n```\r\nscp local_file remote_username@remote_ip:remote_file  \r\n```\r\n或者  \r\n```\r\nscp local_file remote_ip:remote_folder  \r\n```\r\n或者  \r\n```\r\nscp local_file remote_ip:remote_file  \r\n```\r\n第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名  \r\n\r\n第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名   \r\n\r\n(2) 复制目录：  \r\n\r\n命令格式：  \r\n```\r\nscp -r local_folder remote_username@remote_ip:remote_folder  \r\n```\r\n或者  \r\n```\r\nscp -r local_folder remote_ip:remote_folder  \r\n```\r\n第1个指定了用户名，命令执行后需要输入用户密码；  \r\n\r\n第2个没有指定用户名，命令执行后需要输入用户名和密码；\r\n\r\n  \r\n\r\n从远程服务器复制到本地服务器： \r\n\r\n从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。\r\n\r\n实例1：从远处复制文件到本地目录\r\n\r\n命令：\r\n```\r\nscp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/\r\n```\r\n输出：\r\n\r\n复制代码\r\n```\r\n[root@localhost ~]# cd /opt/soft/\r\n[root@localhost soft]# ll\r\n总计 80072\r\ndrwxr-xr-x 12 root root     4096 09-21 18:40 fms3.5\r\ndrwxr-xr-x  3 root root     4096 09-21 17:58 fms4.5\r\ndrwxr-xr-x 10 root root     4096 10-30 17:15 jdk1.6.0_16\r\ndrwxr-xr-x 10 root root     4096 09-17 19:27 jdk1.6.0_16.bak\r\n-rwxr-xr-x  1 root root 81871260 2009-12-21 jdk-6u16-linux-x64.bin\r\ndrwxrwxrwx  2 root root     4096 09-21 01:16 mysql\r\ndrwxr-xr-x  3 root root     4096 09-21 18:40 setup_file\r\ndrwxr-xr-x  9 root root     4096 09-17 19:23 tomcat6.0.32\r\ndrwxr-xr-x  9 root root     4096 2012-08-14 tomcat_7.0\r\n\r\n[root@localhost soft]# scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/\r\nroot@192.168.120.204\'s password: \r\nnginx-0.5.38.tar.gz                                                                               100%  479KB 478.7KB/s   00:00    \r\n\r\n[root@localhost soft]# ll\r\n总计 80556\r\ndrwxr-xr-x 12 root root     4096 09-21 18:40 fms3.5\r\ndrwxr-xr-x  3 root root     4096 09-21 17:58 fms4.5\r\ndrwxr-xr-x 10 root root     4096 10-30 17:15 jdk1.6.0_16\r\ndrwxr-xr-x 10 root root     4096 09-17 19:27 jdk1.6.0_16.bak\r\n-rwxr-xr-x  1 root root 81871260 2009-12-21 jdk-6u16-linux-x64.bin\r\ndrwxrwxrwx  2 root root     4096 09-21 01:16 mysql\r\n-rw-r--r--  1 root root   490220 03-15 09:11 nginx-0.5.38.tar.gz\r\ndrwxr-xr-x  3 root root     4096 09-21 18:40 setup_file\r\ndrwxr-xr-x  9 root root     4096 09-17 19:23 tomcat6.0.32\r\ndrwxr-xr-x  9 root root     4096 2012-08-14 tomcat_7.0\r\n[root@localhost soft]# \r\n```\r\n说明：\r\n\r\n从192.168.120.204机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中\r\n\r\n实例2：从远处复制到本地\r\n\r\n命令：\r\n```\r\nscp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/\r\n```\r\n输出：\r\n```\r\n[root@localhost soft]# ll\r\n总计 80556\r\ndrwxr-xr-x 12 root root     4096 09-21 18:40 fms3.5\r\ndrwxr-xr-x  3 root root     4096 09-21 17:58 fms4.5\r\ndrwxr-xr-x 10 root root     4096 10-30 17:15 jdk1.6.0_16\r\ndrwxr-xr-x 10 root root     4096 09-17 19:27 jdk1.6.0_16.bak\r\n-rwxr-xr-x  1 root root 81871260 2009-12-21 jdk-6u16-linux-x64.bin\r\ndrwxrwxrwx  2 root root     4096 09-21 01:16 mysql\r\n-rw-r--r--  1 root root   490220 03-15 09:11 nginx-0.5.38.tar.gz\r\ndrwxr-xr-x  3 root root     4096 09-21 18:40 setup_file\r\ndrwxr-xr-x  9 root root     4096 09-17 19:23 tomcat6.0.32\r\ndrwxr-xr-x  9 root root     4096 2012-08-14 tomcat_7.0\r\n\r\n[root@localhost soft]# scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/\r\nroot@192.168.120.204\'s password: \r\nmongodb-linux-i686-static-1.8.5.tgz                                                               100%   28MB  28.3MB/s   00:01    \r\nREADME                                                                                            100%  731     0.7KB/s   00:00    \r\nTHIRD-PARTY-NOTICES                                                                               100% 7866     7.7KB/s   00:00    \r\nmongorestore                                                                                      100% 7753KB   7.6MB/s   00:00    \r\nmongod                                                                                            100% 7760KB   7.6MB/s   00:01    \r\nmongoexport                                                                                       100% 7744KB   7.6MB/s   00:00    \r\nbsondump                                                                                          100% 7737KB   7.6MB/s   00:00    \r\nmongofiles                                                                                        100% 7748KB   7.6MB/s   00:01    \r\nmongostat                                                                                         100% 7808KB   7.6MB/s   00:00    \r\nmongos                                                                                            100% 5262KB   5.1MB/s   00:01    \r\nmongo                                                                                             100% 3707KB   3.6MB/s   00:00    \r\nmongoimport                                                                                       100% 7754KB   7.6MB/s   00:00    \r\nmongodump                                                                                         100% 7773KB   7.6MB/s   00:00    \r\nGNU-AGPL-3.0                                                                                      100%   34KB  33.7KB/s   00:00    \r\n\r\n[root@localhost soft]# ll\r\n总计 80560\r\ndrwxr-xr-x 12 root root     4096 09-21 18:40 fms3.5\r\ndrwxr-xr-x  3 root root     4096 09-21 17:58 fms4.5\r\ndrwxr-xr-x 10 root root     4096 10-30 17:15 jdk1.6.0_16\r\ndrwxr-xr-x 10 root root     4096 09-17 19:27 jdk1.6.0_16.bak\r\n-rwxr-xr-x  1 root root 81871260 2009-12-21 jdk-6u16-linux-x64.bin\r\ndrwxr-xr-x  3 root root     4096 03-15 09:18 mongodb\r\ndrwxrwxrwx  2 root root     4096 09-21 01:16 mysql\r\n-rw-r--r--  1 root root   490220 03-15 09:11 nginx-0.5.38.tar.gz\r\ndrwxr-xr-x  3 root root     4096 09-21 18:40 setup_file\r\ndrwxr-xr-x  9 root root     4096 09-17 19:23 tomcat6.0.32\r\ndrwxr-xr-x  9 root root     4096 2012-08-14 tomcat_7.0\r\n[root@localhost soft]# \r\n```\r\n说明：\r\n从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。\r\n\r\n实例3：上传本地文件到远程机器指定目录\r\n\r\n命令：\r\n```\r\nscp /opt/soft/nginx-0.5.38.tar.gz root@192.168.120.204:/opt/soft/scptest\r\n```\r\n输出：\r\n\r\n上传前目标机器的目标目录：\r\n```\r\n[root@localhost soft]# cd scptest/\r\n[root@localhost scptest]# ll\r\n总计 0\r\n[root@localhost scptest]# ll\r\n\r\n本地机器上传：\r\n[root@localhost soft]# scp /opt/soft/nginx-0.5.38.tar.gz root@192.168.120.204:/opt/soft/scptest\r\nroot@192.168.120.204\'s password: \r\nnginx-0.5.38.tar.gz                                                                               100%  479KB 478.7KB/s   00:00    \r\n[root@localhost soft]# \r\n\r\n上传后目标机器的目标目录：\r\n[root@localhost scptest]# ll\r\n总计 484\r\n-rw-r--r-- 1 root root 490220 03-15 09:25 nginx-0.5.38.tar.gz\r\n[root@localhost scptest]#\r\n```\r\n\r\n说明：\r\n\r\n复制本地opt/soft/目录下的文件nginx-0.5.38.tar.gz 到远程机器192.168.120.204的opt/soft/scptest目录\r\n\r\n实例4：上传本地目录到远程机器指定目录\r\n\r\n命令：\r\n```\r\nscp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest\r\n```\r\n输出：\r\n```\r\n上传前目标机器的目标目录：\r\n[root@localhost ~]# cd /opt/soft/scptest/\r\n[root@localhost scptest]# ll\r\n总计 484\r\n-rw-r--r-- 1 root root 490220 03-15 09:25 nginx-0.5.38.tar.gz\r\n[root@localhost scptest]# \r\n本地机器上传：\r\n[root@localhost ~]# scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest\r\nroot@192.168.120.204\'s password: \r\nmongodb-linux-i686-static-1.8.5.tgz                                                               100%   28MB  28.3MB/s   00:01    \r\nREADME                                                                                            100%  731     0.7KB/s   00:00    \r\nTHIRD-PARTY-NOTICES                                                                               100% 7866     7.7KB/s   00:00    \r\nmongorestore                                                                                      100% 7753KB   7.6MB/s   00:00    \r\nmongod                                                                                            100% 7760KB   7.6MB/s   00:01    \r\nmongoexport                                                                                       100% 7744KB   7.6MB/s   00:00    \r\nbsondump                                                                                          100% 7737KB   7.6MB/s   00:00    \r\nmongofiles                                                                                        100% 7748KB   7.6MB/s   00:00    \r\nmongostat                                                                                         100% 7808KB   7.6MB/s   00:01    \r\nmongos                                                                                            100% 5262KB   5.1MB/s   00:00    \r\nmongo                                                                                             100% 3707KB   3.6MB/s   00:00    \r\nmongoimport                                                                                       100% 7754KB   7.6MB/s   00:01    \r\nmongodump                                                                                         100% 7773KB   7.6MB/s   00:00    \r\nGNU-AGPL-3.0                                                                                      100%   34KB  33.7KB/s   00:00    \r\n[root@localhost ~]# \r\n\r\n上传后目标机器的目标目录：\r\n[root@localhost scptest]# ll\r\n总计 488\r\ndrwxr-xr-x 3 root root   4096 03-15 09:33 mongodb\r\n-rw-r--r-- 1 root root 490220 03-15 09:25 nginx-0.5.38.tar.gz\r\n[root@localhost scptest]# \r\n说明：\r\n\r\n	    上传本地目录 /opt/soft/mongodb到远程机器192.168.120.204上/opt/soft/scptest的目录中去',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(261,'Win10 开机启动','261',1475041140,1479289565,'<!--markdown-->如果想要实现应用程序在所有的用户登录系统后都能自动启动，就把该应用程序的快捷方式放到“系统启动文件夹”里；\r\n```\r\nC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(265,'Mysql date_format ','265',1475139900,1479289558,'<!--markdown-->DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。\r\n语法\r\n\r\n**DATE_FORMAT(date,format)**\r\n```\r\ndate 参数是合法的日期。\r\nformat 规定日期/时间的输出格式。\r\n\r\nmysql> select date_format(\'2001.01.01\',\'%b %d %Y %h:%i %p\');\r\n+-----------------------------------------------+\r\n| date_format(\'2001.01.01\',\'%b %d %Y %h:%i %p\') |\r\n+-----------------------------------------------+\r\n| Jan 01 2001 12:00 AM                          |\r\n+-----------------------------------------------+\r\n1 row in set (0.00 sec)\r\n\r\nmysql> select date_format(\'2001-01-01\',\'%b %d %Y %h:%i %p\');\r\n+-----------------------------------------------+\r\n| date_format(\'2001-01-01\',\'%b %d %Y %h:%i %p\') |\r\n+-----------------------------------------------+\r\n| Jan 01 2001 12:00 AM                          |\r\n+-----------------------------------------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n```\r\ndate 参数是合法的日期。format 规定日期/时间的输出格式。\r\n\r\n可以使用的格式有：\r\n格式 	描述\r\n%a	缩写星期名\r\n%b	缩写月名\r\n%c	月，数值\r\n%D	带有英文前缀的月中的天\r\n%d	月的天，数值(00-31)\r\n%e	月的天，数值(0-31)\r\n%f	微秒\r\n%H	小时 (00-23)\r\n%h	小时 (01-12)\r\n%I	小时 (01-12)\r\n%i	分钟，数值(00-59)\r\n%j	年的天 (001-366)\r\n%k	小时 (0-23)\r\n%l	小时 (1-12)\r\n%M	月名\r\n%m	月，数值(00-12)\r\n%p	AM 或 PM\r\n%r	时间，12-小时（hh:mm:ss AM 或 PM）\r\n%S	秒(00-59)\r\n%s	秒(00-59)\r\n%T	时间, 24-小时 (hh:mm:ss)\r\n%U	周 (00-53) 星期日是一周的第一天\r\n%u	周 (00-53) 星期一是一周的第一天\r\n%V	周 (01-53) 星期日是一周的第一天，与 %X 使用\r\n%v	周 (01-53) 星期一是一周的第一天，与 %x 使用\r\n%W	星期名\r\n%w	周的天 （0=星期日, 6=星期六）\r\n%X	年，其中的星期日是周的第一天，4 位，与 %V 使用\r\n%x	年，其中的星期一是周的第一天，4 位，与 %v 使用\r\n%Y	年，4 位\r\n%y	年，2 位\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(266,'Mysql from_unixtime','266',1475140140,1479289553,'<!--markdown-->**函数：FROM_UNIXTIME**\r\n作用：将MYSQL中以INT(11)存储的时间以\"YYYY-MM-DD\"格式来显示。\r\n语法：FROM_UNIXTIME(unix_timestamp,format)\r\n\r\n返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。\r\n\r\n根据format字符串格式化date值。\r\n下列修饰符可以被用在format字符串中：\r\n```\r\n%M 月名字(January……December)\r\n%W 星期名字(Sunday……Saturday)\r\n%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）\r\n%Y 年, 数字, 4 位\r\n%y 年, 数字, 2 位\r\n%a 缩写的星期名字(Sun……Sat)\r\n%d 月份中的天数, 数字(00……31)\r\n%e 月份中的天数, 数字(0……31)\r\n%m 月, 数字(01……12)\r\n%c 月, 数字(1……12)\r\n%b 缩写的月份名字(Jan……Dec)\r\n%j 一年中的天数(001……366)\r\n%H 小时(00……23)\r\n%k 小时(0……23)\r\n%h 小时(01……12)\r\n%I 小时(01……12)\r\n%l 小时(1……12)\r\n%i 分钟, 数字(00……59)\r\n%r 时间,12 小时(hh:mm:ss [AP]M)\r\n%T 时间,24 小时(hh:mm:ss)\r\n%S 秒(00……59)\r\n%s 秒(00……59)\r\n%p AM或PM\r\n%w 一个星期中的天数(0=Sunday ……6=Saturday ）\r\n%U 星期(0……52), 这里星期天是星期的第一天\r\n%u 星期(0……52), 这里星期一是星期的第一天\r\n%% 一个文字“%”。\r\n\r\n例子：\r\n\r\nmysql> SELECT FROM_UNIXTIME(1234567890, \'%Y-%m-%d %H:%i:%S\');\r\n+------------------------------------------------+\r\n| FROM_UNIXTIME(1234567890, \'%Y-%m-%d %H:%i:%S\') |\r\n+------------------------------------------------+\r\n| 2009-02-14 07:31:30                            |\r\n+------------------------------------------------+\r\n1 row in set (0.00 sec)\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(267,'Mysql_unix_timestamp','267',1475140380,1479289547,'<!--markdown-->**UNIX_TIMESTAMP(date )**\r\n```\r\ndate 为合法的日期。\r\ndate 转换时间戳\r\n\r\nmysql> select unix_timestamp(\'2001.1.1\');\r\n+----------------------------+\r\n| unix_timestamp(\'2001.1.1\') |\r\n+----------------------------+\r\n|                  978278400 |\r\n+----------------------------+\r\n1 row in set (0.00 sec)\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(269,'Mysql date_format from_unixtime unix_timestamp','269',1475140920,1479289524,'<!--markdown-->```\r\ndate_format        格式化标准日期\r\n\r\nmysql> select date_format(\'2001.01.01\',\'%b %d %Y %h:%i %p\');\r\n+-----------------------------------------------+\r\n| date_format(\'2001.01.01\',\'%b %d %Y %h:%i %p\') |\r\n+-----------------------------------------------+\r\n| Jan 01 2001 12:00 AM                          |\r\n+-----------------------------------------------+\r\n1 row in set (0.00 sec)\r\n```\r\n```\r\nfrom_unixtime      格式化时间戳\r\n\r\nmysql> SELECT FROM_UNIXTIME(1234567890, \'%Y-%m-%d %H:%i:%S\');\r\n+------------------------------------------------+\r\n| FROM_UNIXTIME(1234567890, \'%Y-%m-%d %H:%i:%S\') |\r\n+------------------------------------------------+\r\n| 2009-02-14 07:31:30                            |\r\n+------------------------------------------------+\r\n1 row in set (0.00 sec)\r\n```\r\n```\r\nunix_timestamp     获取日期时间戳\r\n\r\nmysql> select unix_timestamp(\'2001.1.1\');\r\n+----------------------------+\r\n| unix_timestamp(\'2001.1.1\') |\r\n+----------------------------+\r\n|                  978278400 |\r\n+----------------------------+\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(271,'git merge 冲突解决','271',1475897160,1479288291,'<!--markdown-->Git merge 用来做分支合并，将其他分支中的内容合并到当前分支中。比如分支结构如下：\r\n```\r\n                        master\r\n                         /\r\nC0 ---- C1 ---- C2 ---- C4\r\n                         \\\r\n                         C3 ---- C5\r\n                                  \\\r\n                                issueFix\r\n```\r\n当前分支是master\r\n```\r\n$ git checkout master\r\n```\r\n把issueFix中的内容Merge进来：\r\n```\r\n$ git merge issueFix\r\n```\r\n如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：\r\n```\r\n<<<<<<< HEAD:test.c\r\n\r\nprintf (“test1″);\r\n\r\n=======\r\n\r\nprintf (“test2″);\r\n\r\n>>>>>>> issueFix:test.c\r\n```\r\n可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在 issueFix 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：\r\n```\r\nprintf (“test2″);\r\n```\r\n这个解决方案各采纳了两个分支中的一部分内容，而且删除了 <<<<<<<，=======，和>>>>>>> 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决（resolved）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：\r\n```\r\n$ git mergetool\r\nmerge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff\r\nMerging the files: index.html\r\n\r\nNormal merge conflict for ‘test.c’:\r\n{local}: modified\r\n{remote}: modified\r\nHit return to start merge resolution tool (kdiff3):\r\n```\r\n合并后的分支图如下：\r\n\r\n```                               \r\n                                    master\r\n                                 /\r\nC0 ---- C1 ---- C2 ---- C4 ---- C6\r\n                        \\       /\r\n                        C3 ----C5\r\n                                \\\r\n                              issueFix\r\n```\r\n注意，这次合并的实现，由于当前 master 分支所指向的 commit (C4)并非想要并入分支（issueFix）的直接祖先，Git 不得不进行一些处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）和它们的共同祖先（C2）进行一次简单的三方合并。对三方合并的结果作一新的快照，并自动创建一个指向它的 commit（C6）\r\n\r\n退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。然后可以用 git commit 来完成这次合并提交。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(273,'webstorm 设置','273',1475996880,1479288286,'<!--markdown-->webstorm/phpstorm默认会使用空格缩进，只是会检测和使用文件原本的缩进方式，取消勾选即可\r\n```\r\nsettings -> Editor -> Code Style \r\nDetect and use existing file indents for editing\r\n```\r\n\r\n**tab 设置**\r\n```\r\nsettings -> Editor -> Code Style \r\n下对应的 file type\r\nJavaScript 勾选 use tab character\r\n\r\n```\r\n[让webstorm全副武装！][1]\r\n\r\n\r\n  [1]: https://segmentfault.com/a/1190000006729475',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(275,'让webstorm全副武装！','275',1475997840,1479288278,'<!--markdown--># 一、改变先从脸开始\r\n\r\n**1. 更换主题，这个看脸的世界啊！**\r\n\r\n    \r\n    file=>settings=>appearance&behavior=>appearance,阿狸现在用的Dracula,经典黑色，这样才霸气\r\n\r\n**2. 更换快捷键**\r\n```\r\n   webstorm可以快速选择其他软件的默认快捷方式，用惯了eclipse的朋友，这简直就是福音啊\r\n    file=>settings=>keymap=>eclipse\r\n```\r\n![请输入图片描述][1]\r\n# 二、进阶\r\n\r\n**1. 插件类--markdown**\r\n```\r\n    打开file=>settings=>plugins=>Browse Repositories,查找插件，安装，重启使用，这里经常遇到webstorm无法联网的情况。选择如下配置下代理，就可以了。\r\n```\r\n![请输入图片描述][2]\r\n**2. 版本控制**\r\n```\r\n打开file => settings => plugins => version control，webstorm集成了svn和git，这里可以简单配置完成使用。\r\n```\r\n![请输入图片描述][3]\r\n需要注意的是：本机安装的svn必须是可以执行command的，如果不行，请重装svn，安装时选择command line client tools.svn默认是不安装command的\r\n![请输入图片描述][4]\r\n**3.文件模板**\r\n```\r\n打开file=>settings=>Editor=>file and code templates,这里是当新建文件时，默认显示的信息，比如写上作者啦，use strict啦\r\n```\r\n**4.项目代码检查**\r\n\r\n    Settings => language & frameworks => JavaScript => Code Quality Tolls => JSHint\r\n    阿狸一般用jshint，这里可以选择可以容忍（tolerate）的语法，防止jslint控制太严格喽\r\n![请输入图片描述][5]\r\n\r\n**5.构建工具**\r\n\r\n    webstorm 可以完成gulp的构建哦，gulpfile右键，选择show gulp tasks,就可以读取任务，双击可以执行\r\n\r\n![请输入图片描述][6]\r\n\r\n\r\n  [1]: https://segmentfault.com/img/bVCoov\r\n  [2]: https://segmentfault.com/img/bVCoJX\r\n  [3]: https://segmentfault.com/img/bVCoKI\r\n  [4]: https://segmentfault.com/img/bVCoLB\r\n  [5]: https://segmentfault.com/img/bVCoMq\r\n  [6]: https://segmentfault.com/img/bVCoW6',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(277,'Web性能压力测试工具之ApacheBench（ab）详解','277',1476007500,1479288781,'<!--markdown-->**PS：网站性能压力测试是性能调优过程中必不可少的一环。只有让服务器处在高压情况下才能真正体现出各种设置所暴露的问题。Apache中有个自带的，名为ab的程序，可以对Apache或其它类型的服务器进行网站访问压力测试。**\r\n\r\n**ApacheBench命令原理：**\r\nab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。\r\n\r\nab命令对发出负载的计算机要求很低，既不会占用很高CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。\r\n```\r\ncentos 安装ab：\r\nyum install httpd-tools\r\n```\r\n**ApacheBench参数说明**\r\n\r\n    格式：ab [options] [http://]hostname[:port]/path\r\n    参数说明：\r\n    -n requests Number of requests to perform\r\n    //在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。\r\n    -c concurrency Number of multiple requests to make\r\n    //一次产生的请求个数（并发数）。默认是一次一个。\r\n    -t timelimit Seconds to max. wait for responses\r\n    //测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。\r\n    -p postfile File containing data to POST\r\n    //包含了需要POST的数据的文件，文件格式如“p1=1&p2=2”.使用方法是 -p 111.txt 。 （配合-T）\r\n    -T content-type Content-type header for POSTing\r\n    //POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）\r\n    -v verbosity How much troubleshooting info to print\r\n    //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。\r\n    -w Print out results in HTML tables\r\n    //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。\r\n    -i Use HEAD instead of GET\r\n    // 执行HEAD请求，而不是GET。\r\n    -x attributes String to insert as table attributes\r\n    -y attributes String to insert as tr attributes\r\n    -z attributes String to insert as td or th attributes\r\n    -C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)\r\n    //-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。\r\n    提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如\r\n    -C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。\r\n    -H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)\r\n    -A attribute Add Basic WWW Authentication, the attributes\r\n    are a colon separated username and password.\r\n    -P attribute Add Basic Proxy Authentication, the attributes\r\n    are a colon separated username and password.\r\n    //-P proxy-auth-username:password 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。\r\n    -X proxy:port Proxyserver and port number to use\r\n    -V Print version number and exit\r\n    -k Use HTTP KeepAlive feature\r\n    -d Do not show percentiles served table.\r\n    -S Do not show confidence estimators and warnings.\r\n    -g filename Output collected data to gnuplot format file.\r\n    -e filename Output CSV file with percentages served\r\n    -h Display usage information (this message)\r\n    //-attributes 设置属性的字符串. 缺陷程序中有各种静态声明的固定长度的缓冲区。另外，对命令行参数、服务器的响应头和其他外部输入的解析也很简单，这可能会有不良后果。它没有完整地实现 HTTP/1.x; 仅接受某些’预想’的响应格式。 strstr(3)的频繁使用可能会带来性能问题，即你可能是在测试ab而不是服务器的性能。\r\n\r\n    参数很多，一般我们用 -c 和 -n 参数就可以了。例如:\r\n\r\n    # ab -c 5000 -n 600 http://127.0.0.1/index.php\r\n\r\n\r\n**ApacheBench用法详解：**\r\n在Linux系统，一般安装好Apache后可以直接执行；\r\n```\r\n# ab -n 4000 -c 1000 http://www.ha97.com/\r\n```\r\n如果是Win系统下，打开cmd命令行窗口，cd到apache安装目录的bin目录下；\r\n```\r\n-n后面的4000代表总共发出4000个请求；-c后面的1000表示采用1000个并发（模拟1000个人同时访问），后面的网址表示测试的目标URL。\r\n```\r\n**结果分析：**\r\n\r\n    This is ApacheBench, Version 2.3\r\n    Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\r\n    Licensed to The Apache Software Foundation, http://www.apache.org/\r\n\r\n    Benchmarking 192.168.80.157 (be patient)\r\n    Completed 400 requests\r\n    Completed 800 requests\r\n    Completed 1200 requests\r\n    Completed 1600 requests\r\n    Completed 2000 requests\r\n    Completed 2400 requests\r\n    Completed 2800 requests\r\n    Completed 3200 requests\r\n    Completed 3600 requests\r\n    Completed 4000 requests\r\n    Finished 4000 requests\r\n\r\n    Server Software: Apache/2.2.15\r\n    Server Hostname: 192.168.80.157\r\n    Server Port: 80\r\n\r\n    Document Path: /phpinfo.php\r\n    #测试的页面\r\n    Document Length: 50797 bytes\r\n    #页面大小\r\n\r\n    Concurrency Level: 1000\r\n    #测试的并发数\r\n    Time taken for tests: 11.846 seconds\r\n    #整个测试持续的时间\r\n    Complete requests: 4000\r\n    #完成的请求数量\r\n    Failed requests: 0\r\n    #失败的请求数量\r\n    Write errors: 0\r\n    Total transferred: 204586997 bytes\r\n    #整个过程中的网络传输量\r\n    HTML transferred: 203479961 bytes\r\n    #整个过程中的HTML内容传输量\r\n    Requests per second: 337.67 [#/sec] (mean)\r\n    #最重要的指标之一，相当于LR中的每秒事务数，后面括号中的mean表示这是一个平均值\r\n    Time per request: 2961.449 [ms] (mean)\r\n    #最重要的指标之二，相当于LR中的平均事务响应时间，后面括号中的mean表示这是一个平均值\r\n    Time per request: 2.961 [ms] (mean, across all concurrent requests)\r\n    #每个连接请求实际运行时间的平均值\r\n    Transfer rate: 16866.07 [Kbytes/sec] received\r\n    #平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\r\n    Connection Times (ms)\r\n    min mean[+/-sd] median max\r\n    Connect: 0 483 1773.5 11 9052\r\n    Processing: 2 556 1459.1 255 11763\r\n    Waiting: 1 515 1459.8 220 11756\r\n    Total: 139 1039 2296.6 275 11843\r\n    #网络上消耗的时间的分解，各项数据的具体算法还不是很清楚\r\n\r\n    Percentage of the requests served within a certain time (ms)\r\n    50% 275\r\n    66% 298\r\n    75% 328\r\n    80% 373\r\n    90% 3260\r\n    95% 9075\r\n    98% 9267\r\n    99% 11713\r\n    100% 11843 (longest request)\r\n    #整个场景中所有请求的响应情况。在场景中每个请求都有一个响应时间，其中50％的用户响应时间小于275毫秒，66％的用户响应时间小于298毫秒，最大的响应时间小于11843毫秒。对于并发请求，cpu实际上并不是同时处理的，而是按照每个请求获得的时间片逐个轮转处理的，所以基本上第一个Time per request时间约等于第二个Time per request时间乘以并发请求数。\r\n\r\n**总结：在远程对web服务器进行压力测试，往往效果不理想（因为网络延时过大），建议使用内网的另一台或者多台服务器通过内网进行测试，这样得出的数据，准确度会高很多。如果只有单独的一台服务器，可以直接本地测试，比远程测试效果要准确。**',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(322,'git 修改提交信息 git commit --amend','322',1481101539,1481101604,'<!--markdown--> 对于已经修改提交过的注释，如果需要修改，可以借助 \r\n```\r\ngit commit --amend\r\n```\r\n 来进行。\r\n  例如 在framework/base 里最新的提交就是 resolving the roaming problem，我现在需要将其改为 resolving the roaming problem for fixing bug 7732\r\n  在 framework/base 下 输入 git commit --amend,就会进入一个文本编辑界面（如下），在注释的地方修改 ，保存然后退出，这样注释就修改了，再重新push.',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(283,'md5 加密 openssl','283',1476072120,1479288770,'<!--markdown-->```\r\n[vagrant: ~]$ openssl md5 1.php \r\nMD5(1.php)= d41d8cd98f00b204e9800998ecf8427e\r\n[vagrant: ~]$ md5sum 1.php \r\nd41d8cd98f00b204e9800998ecf8427e  1.php\r\n\r\n\r\n\r\n    1. oppnssl md5  加密字符串的方法\r\n\r\n    a.手动输入命令及过程如下：\r\n\r\n    #openssl        //在终端中输入openssl后回车。\r\n\r\n    OpenSSL> md5        //输入md5后回车\r\n\r\n    123456      //接着输入123456，不要输入回车。然后按3次ctrl+d。\r\n\r\n    123456e10adc3949ba59abbe56e057f20f883e    //123456后面的就是密文了\r\n\r\n    解释：为何在输入123456后不回车呢？\r\n\r\n    是因为openssl默认会把回车符当做要加密的字符串中的一个字符，所以得到的结果不同。如果你输入123456后回车，在按3次ctrl+d。得到的结果是：\r\n\r\n    OpenSSL> md5\r\n\r\n    123456\r\n\r\n    f447b20a7fcbf53a5d5be013ea0b15af    //因为openssl不忽略回车符导致的\r\n\r\n    b.或者直接用管道命令\r\n\r\n    # echo -n  123456  | openssl md5   //必须要有-n参数，否则就不是这个结果了。\r\n\r\n    e10adc3949ba59abbe56e057f20f883e\r\n\r\n    解释：为何要加-n这个参数？\r\n\r\n    -n就表示不输入回车符，这样才能得到正确的结果。如果你不加-n，那么结果和前面说的一样为：\r\n\r\n    f447b20a7fcbf53a5d5be013ea0b15af    //因为openssl不忽略回车符导致的\r\n\r\n    2.用openssl加密文件。\r\n\r\n    #openssl   md5   -in   1.txt\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(284,'md5sum','284',1476080520,1479288764,'<!--markdown-->md5sum是一种计算机程序，用于计算与校验RFC 1321所描述的128位MD5哈希值，此处MD5散列值（或校验和）作一个文件的数字指纹使用。\r\n\r\n**功能**\r\n理论上看，正如其他散列算法一样，一个MD5哈希值可对应无限个文件，但从现实的角度看，两个不同的文件几乎不可能有相同的MD5哈希值，除非其创建便是刻意为之。一般来说，任何对一个文件的非恶意变更都会导致其MD5哈希值改变，因此md5sum一般用于检查文件完整性，尤其常用于检测在文件传输、磁盘错误或其他无恶意涉入的情况下文件的正确性。\r\n**隐患**\r\nmd5sum虽适用于没有安全隐患下的文件校验，但由于原始的MD5算法安全性已遭质疑（参见MD5算法弱点），所以当文件可能遭恶意改动的时候，就不应使用md5sum，而应以sha256sum等求哈希值的工具代之。\r\n**分布**\r\n在多数Unix、Linux与其他类Unix操作系统或兼容层都默认安装了md5sum工具，而其他操作系统（包括Microsoft Windows与BSD的变体Mac OS X）也有相似的工具。在FreeBSD上，有同样功用的工具名为md5，但其亦带有额外的特性。\r\n**示例**\r\n以linux下shell为环境示例，以下文件皆于同一目录下。\r\n计算校验值并输出至hash.md5\r\n```\r\n$ md5sum filetohashA.txt filetohashB.txt filetohashC.txt > hash.md5\r\n```\r\n所得文件\r\n文件内包括了哈希值和对应的文件名。\r\n```\r\n$ cat hash.md5\r\n595f44fec1e92a71d3e9e77456ba80d1  filetohashA.txt\r\n71f920fa275127a7b60fa4d4d41432a3  filetohashB.txt\r\n43c191bf6d6c3f263a8cd0efd4a058ab  filetohashC.txt\r\n```\r\n以MD5值校验文件\r\n```\r\n$ md5sum -c hash.md5\r\nfiletohashA.txt: OK\r\nfiletohashB.txt: OK\r\nfiletohashC.txt: OK\r\n```\r\n注：在校验文件内，各个md5校验值与需比较的文件名间必须有两个空格，文件内换行也应为UNIX换行符（LF），否则无法进行。\r\n检查单个MD5值\r\n```\r\n$ echo \"595f44fec1e92a71d3e9e77456ba80d1  filetohashA.txt\" | md5sum -c\r\nfiletohashA.txt: OK\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(285,'win 10 输入法惯用设置','285',1476155100,1479289461,'<!--markdown-->Win10输入法修改成Win7样式\r\n“控制面板”-“语言”-“高级设置”-“替代默认输入法”-“英语（美国）美式键盘\"-”保存“\r\n\r\nWin10输入法切换更改为“Ctrl+Shift”\r\n“控制面板”-“语言”-“高级设置”-“更改语言栏热键”-“高级键设置”-“在输入语言之间”-“更改按键设置”-“切换输入语言”-“Ctrl+Shift”-“确定”-“保存”',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(286,'git 撤销','286',1476676020,1479288264,'<!--markdown--># 撤销add\r\n```\r\ngit reset 撤销所有add\r\ngit reset filename 撤销单文件\r\n```\r\n# 撤销commit\r\n```\r\ngit log    查看  commit_id\r\ngit reset --hard commit_id',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(287,'git config','287',1476683220,1479288258,'<!--markdown--> Git有一个工具被称为git config，它允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。\r\n一. 配置文件的存储位置\r\n\r\n这些变量可以被存储在三个不同的位置：\r\n```\r\n1./etc/gitconfig 文件：包含了适用于系统所有用户和所有库的值。如果你传递参数选项’--system’ 给 git config，它将明确的读和写这个文件。 \r\n\r\n2.~/.gitconfig 文件 ：具体到你的用户。你可以通过传递--global 选项使Git 读或写这个特定的文件。\r\n\r\n3.位于git目录的config文件 (也就是 .git/config) ：无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。因此，在.git/config中的值覆盖了在/etc/gitconfig中的同一个值。\r\n二.配置你的用户名和密码\r\n```\r\n当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：\r\n\r\n　　\r\n[html] view plain copy\r\n\r\n    $ git config --global user.name \"wirelessqa\"  \r\n    $ git config --global user.email wirelessqa.me@gmail.com  \r\n\r\n\r\n 　　重申一遍，你只需要做一次这个设置。如果你传递了 --global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。\r\n三.配置你的编缉器\r\n\r\n你的标识已经设置，你可以配置你的缺省文本编辑器，Git在需要你输入一些消息时会使用该文本编辑器。缺省情况下，Git使用你的系统的缺省编辑器，这通常可能是vi 或者 vim。如果你想使用一个不同的文本编辑器，例如Emacs，你可以做如下操作：\r\n\r\n　　\r\n[html] view plain copy\r\n\r\n    $ git config --global core.editor emacs  \r\n\r\n四.配置你的比较工具\r\n\r\n另外一个你可能需要配置的有用的选项是缺省的比较工具它用来解决合并时的冲突。例如，你想使用vimdiff:\r\n\r\n　　\r\n[html] view plain copy\r\n\r\n    $ git config --global merge.tool vimdiff  \r\n\r\n\r\n 　　Git可以接受kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, ecmerge, 和 opendiff作为有效的合并工具。你也可以设置一个客户化的工具；\r\n五.检查你的配置\r\n\r\n如果你想检查你的设置，你可以使用 git config --list 命令来列出Git可以在该处找到的所有的设置:\r\n\r\n　　\r\n[html] view plain copy\r\n\r\n    $ git config --list  \r\n    　　user.name=wirelessqa  \r\n    　　user.email=wirelessqa.me@gmail.com  \r\n    　　color.status=auto  \r\n    　　color.branch=auto  \r\n    　　color.interactive=auto  \r\n    　　color.diff=auto  \r\n    　　...  \r\n\r\n\r\n你可能会看到一个关键字出现多次，这是因为Git从不同的文件中(例如：/etc/gitconfig以及~/.gitconfig)读取相同的关键字。 在这种情况下，对每个唯一的关键字，Git使用最后的那个值。 \r\n\r\n　　你也可以查看Git认为的一个特定的关键字目前的值，使用如下命令 git config {key}:\r\n\r\n[html] view plain copy\r\n\r\n    $ git config user.name  \r\n    wirelessqa  \r\n\r\n\r\n六.获取帮助\r\n\r\n　如果当你在使用Git时需要帮助，有三种方法可以获得任何git命令的手册页(manpage)帮助信息:\r\n\r\n　\r\n[html] view plain copy\r\n\r\n    $ git help <verb>  \r\n    $ git <verb> --help  \r\n    $ man git-<verb>  \r\n\r\n\r\n 　　例如，你可以运行如下命令获取对config命令的手册页帮助:\r\n\r\n[html] view plain copy\r\n\r\n    $ git help config  ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(323,'webstorm 2016 激活破解 ','323',1481510280,1481510316,'<!--markdown-->    2016.2.2 版本的破解方式：\r\n    安装以后，打开软件会弹出一个对话框；选择“license server” 输入：http://114.215.133.70:41017\r\n    2016.2.3 版本的破解方式：\r\n    目前最新的就是2.3版本，在打开的License Activation窗口中选择“activation code”，在输入框输入下面的注册码\r\n\r\n\r\n```\r\n43B4A73YYJ-eyJsaWNlbnNlSWQiOiI0M0I0QTczWVlKIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9XSwiaGFzaCI6IjMzOTgyOTkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-keaxIkRgXPKE4BR/ZTs7s7UkP92LBxRe57HvWamu1EHVXTcV1B4f/KNQIrpOpN6dgpjig5eMVMPmo7yMPl+bmwQ8pTZaCGFuLqCHD1ngo6ywHKIQy0nR249sAUVaCl2wGJwaO4JeOh1opUx8chzSBVRZBMz0/MGyygi7duYAff9JQqfH3p/BhDTNM8eKl6z5tnneZ8ZG5bG1XvqFTqWk4FhGsEWdK7B+He44hPjBxKQl2gmZAodb6g9YxfTHhVRKQY5hQ7KPXNvh3ikerHkoaL5apgsVBZJOTDE2KdYTnGLmqxghFx6L0ofqKI6hMr48ergMyflDk6wLNGWJvYHLWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(289,'git 修改仓库地址','289',1476693780,1479288234,'<!--markdown-->修改config 文件\r\n```\r\n$ cd .git\r\n$ vim config\r\n然后将 [remote \"origin\"] 标签下的 url 值改为：\r\ngit@github.com:[your_id]/[repo_name].git \r\n```\r\n修改命令\r\n```\r\ngit remote set-url origin [url]\r\n例如：Git remote set-url origin git@github.com:shoyin/blog.git\r\n```\r\n先删后加\r\n```\r\ngit remote rm origin\r\ngit remote add origin [url]\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(298,'git log 查看分支历史','298',1476950520,1479288138,'<!--markdown-->查看分支历史\r\n```\r\n$ git log --graph --pretty=oneline --abbrev-commit',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(291,'git 初始化配置','291',1476694020,1479288229,'<!--markdown-->```\r\n#配置使用git仓库的人员姓名\r\ngit config --global user.name \"Your Name Comes Here\"\r\n\r\n#配置使用git仓库的人员email\r\ngit config --global user.email you@yourdomain.example.com\r\n\r\n#配置到缓存 默认15分钟\r\ngit config --global credential.helper cache \r\n\r\n#修改缓存时间\r\ngit config --global credential.helper \'cache --timeout=3600\'  \r\n\r\ngit config --global color.ui true\r\ngit config --global alias.co checkout\r\ngit config --global alias.ci commit\r\ngit config --global alias.st status\r\ngit config --global alias.br branch\r\ngit config --global core.editor \"mate -w\"    # 设置Editor使用textmate\r\ngit config -1 #列举所有配置\r\n\r\n#用户的git配置文件~/.gitconfig\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(297,'git --no-ff','297',1476950460,1479288187,'<!--markdown-->```\r\n$ git merge --no-ff -m \"merge with no-ff\" dev\r\n\r\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\r\n\r\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(293,'git reset','293',1476788520,1479288210,'<!--markdown-->**git reset**\r\n```\r\ngit log\r\ngit reset --hard commit_id 推到指定commit_id版本\r\n```\r\n**HEAD 表示当前版本**\r\n```\r\ngit reset --hard HEAD^     退回上一版本\r\ngit reset --hard HEAD^^    退回上上版本\r\ngit reset --hard HEAD~100  上100个版本\r\n```\r\n**git reflog 查看历史版本**\r\n```\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git reflog\r\n8a16eca HEAD@{0}: commit: test\r\n7d79462 HEAD@{1}: commit: test\r\n93c8900 HEAD@{2}: commit: typecho 配置文件\r\n1240f9d HEAD@{3}: reset: moving to 1240f9dac920dfd7894e3f9521d191eb126c62d0\r\n19e50c2 HEAD@{4}: reset: moving to 19e50c26cde5360bc81340d7e5ac0962d028682e\r\nf61e796 HEAD@{5}: commit: test\r\n```\r\n```\r\ngit reset --hard 93c8900 \r\n```\r\n\r\n    HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\r\n\r\n    穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\r\n\r\n    要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(295,'git reset commit ','295',1476789480,1479288200,'<!--markdown-->```\r\ngit reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：\r\n```\r\n```\r\ngit checkout -- file 文件在工作区的修改全部撤销\r\n```\r\n```\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git add 1.php \r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git status\r\nOn branch master\r\nYour branch is up-to-date with \'origin/master\'.\r\n\r\nChanges to be committed:\r\n  (use \"git reset HEAD <file>...\" to unstage)\r\n\r\n	modified:   1.php\r\n\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git reset HEAD 1.php\r\nUnstaged changes after reset:\r\nM	1.php\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git status\r\nOn branch master\r\nYour branch is up-to-date with \'origin/master\'.\r\n\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\r\n\r\n	modified:   1.php\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git checkout -- 1.php\r\nroot@ubuntu-512mb-sgp1-01:/var/www/html/blog# git status\r\nOn branch master\r\nYour branch is up-to-date with \'origin/master\'.\r\n\r\nnothing to commit, working directory clean\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(296,'git 关联','296',1476949080,1479288194,'<!--markdown-->```\r\n要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\r\n\r\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\r\n\r\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(299,'git stash','299',1476950640,1479288132,'<!--markdown-->Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，\r\n```\r\n$ git stash list\r\n$ git stash pop\r\n```\r\n\r\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\r\n\r\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\r\n\r\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\r\n\r\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(300,'git branch 删除','300',1476951060,1479288127,'<!--markdown-->删除分支\r\n```\r\n$ git branch -d feature-vulcan\r\n```\r\n强行删除分支\r\n```\r\n$ git branch -D feature-vulcan\r\n\r\ngit branch -D <name>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(301,'Ubuntu 14.04 VPS安装配置Shadowsocks的方法','301',1477276980,1479289429,'<!--markdown-->**安装Shadowsocks**\r\n```\r\n$ sudo apt-get update\r\n$ sudo apt-get install python-gevent python-pip\r\n$ sudo pip install shadowsocks\r\n$ apt-get install python-m2crypto\r\n```\r\n**配置Shadowsocks**\r\n\r\n创建config.json配置文件：\r\n```\r\n$ vi /etc/shadowsocks.json\r\n```\r\n修改config.json\r\n```	\r\n\r\n{\r\n    \"server\":\"0.0.0.0\",\r\n    \"server_port\":8388,\r\n    \"local_port\":1080,\r\n    \"password\":\"password\",\r\n    \"timeout\":600,\r\n    \"method\":\"aes-256-cfb\"\r\n}\r\n```\r\n配置一下你的服务器IP和密码就可以了。\r\n运行Shadowsocks\r\n```\r\n$ su -\r\n# ssserver -c /etc/shadowsocks.json -d start\r\n# ssserver -c /etc/shadowsocks.json -d stop\r\n```\r\n注意要切换到root用户下才能运行。\r\n\r\n至此，服务端安装配置完毕，客户端的运行可以参考：科学上网利器 Shadowsocks 使用方法\r\n[Ubuntu 14.04 VPS安装配置Shadowsocks的方法][1]\r\n\r\n\r\n  [1]: http://www.ihunter.me/Ubuntu%2014.04%20VPS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEShadowsocks%E7%9A%84%E6%96%B9%E6%B3%95.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(303,'vagrant virtualbox VM inaccessible解决办法','303',1477307220,1479288791,'<!--markdown-->Please open VirtualBox and clear out your inaccessible virtual machines or find a way to fix them.看到这句话，于是打开virtualbox界面，virtualbox也提示该虚拟机无法启动，是因为\r\n```\r\nC:\\Users\\hoyin\\VirtualBox VMs\\vagrant_default_1471513314079_84177.vbox文件不存在。\r\n```\r\n于是进入该文件的目录，发现并没有后缀为.vbox文件，而是多了一个.vbox-tmp的文件。\r\n将该文件后缀中的-tmp去掉，在执行vagrant up命令',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(305,'git branch 推送远程分支','305',1478249160,1479288115,'<!--markdown-->git push origin  branchName:branchName\r\n远程没有分支，自动创建',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(307,'node.js 权重随机','307',1478612160,1479288101,'<!--markdown-->```\r\nexports.action = function(WW, MF, req, resp, queryInfoDic) {\r\n\r\n\r\n	var randomConfig = [{id:1,weight:50,count:2,price:100},{id:2,weight:5,count:30,price:200}];\r\n	var randomList = [];\r\n	for (var i in randomConfig) {\r\n		for (var j = 0; j < randomConfig[i].weight; j++) {\r\n			randomList.push({id:randomConfig[i].id,count:randomConfig[i].count,price:randomConfig[i].price});\r\n		}\r\n	}\r\n	var randomValue = randomList[Math.floor(Math.random() * randomList.length)];\r\n	var orderList = [];\r\n	console.log(randomValue);\r\n	console.log(randomList.length);\r\n\r\n	while(true){\r\n		randomValue = randomList[Math.floor(Math.random() * randomList.length)];\r\n		orderList.push(randomValue);\r\n		if(orderList.length === 3){\r\n			break;\r\n		}\r\n		i ++;\r\n	}\r\n	console.log(orderList);\r\n	// if (curVal != 0) {\r\n	// 	while (randomValue == curVal ) {\r\n	// 		randomValue  = randomList[Math.floor(Math.random() * randomList.length)];\r\n	// 	}\r\n	// }\r\n	return randomValue ;\r\n}',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(309,'webstorm 新增代码块','309',1479286200,1479304801,'<!--markdown-->```\r\nsetting  -->  editor  -->  Live Templates\r\n右上角的加号，Live Templates\r\n\r\nAbbreviation：代码缩写\r\nDescription:  内容描述\r\nTemplate Text：\r\n代码块\r\n\r\n\r\nAbbreviation：if\r\nDescription:  if\r\nTemplate Text：\r\nif($PARAM$){\r\n\r\n}\r\n\r\n$PARAM$:代码补全后光标所在位置\r\nExpand with:补全键\r\nNo applicable contexts yer. Define  点击 Define ，关联到文件类型\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(321,'git 远程分支','321',1481101320,1481101468,'<!--markdown-->这篇文章记录我在使用git的过程中碰到远程分支和tag的相关内容，提纲：\r\n\r\n    查看远程分支\r\n    删除远程分支和tag\r\n    删除不存在对应远程分支的本地分支\r\n    重命名远程分支\r\n    把本地tag推送到远程\r\n    获取远程tag\r\n\r\n查看远程分支\r\n\r\n加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）：\r\n```\r\n$ git branch -a\r\n  master\r\n  remote\r\n  tungway\r\n  v1.52\r\n* zrong\r\n  remotes/origin/master\r\n  remotes/origin/tungway\r\n  remotes/origin/v1.52\r\n  remotes/origin/zrong\r\n```\r\n删除远程分支和tag\r\n\r\n在Git v1.7.0 之后，可以使用这种语法删除远程分支：\r\n```\r\n$ git push origin --delete <branchName>\r\n```\r\n删除tag这么用：\r\n```\r\ngit push origin --delete tag <tagname>\r\n```\r\n否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支：\r\n```\r\ngit push origin :<branchName>\r\n```\r\n这是删除tag的方法，推送一个空tag到远程tag：\r\n```\r\ngit tag -d <tagname>\r\ngit push origin :refs/tags/<tagname>\r\n```\r\n两种语法作用完全相同。\r\n删除不存在对应远程分支的本地分支\r\n\r\n假设这样一种情况：\r\n\r\n    我创建了本地分支b1并pull到远程分支 origin/b1；\r\n    其他人在本地使用fetch或pull创建了本地的b1分支；\r\n    我删除了 origin/b1 远程分支；\r\n    其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？\r\n\r\n使用下面的代码查看b1的状态：\r\n```\r\n$ git remote show origin\r\n* remote origin\r\n  Fetch URL: git@github.com:xxx/xxx.git\r\n  Push  URL: git@github.com:xxx/xxx.git\r\n  HEAD branch: master\r\n  Remote branches:\r\n    master                 tracked\r\n    refs/remotes/origin/b1 stale (use \'git remote prune\' to remove)\r\n  Local branch configured for \'git pull\':\r\n    master merges with remote master\r\n  Local ref configured for \'git push\':\r\n    master pushes to master (up to date)\r\n```\r\n这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。\r\n\r\n更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支：\r\n```\r\ngit fetch -p\r\n```\r\n重命名远程分支\r\n\r\n在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。\r\n\r\n例如下面的例子中，我需要把 devel 分支重命名为 develop 分支：\r\n```\r\n$ git branch -av\r\n* devel                             752bb84 Merge pull request #158 from Gwill/devel\r\n  master                            53b27b8 Merge pull request #138 from tdlrobin/master\r\n  zrong                             2ae98d8 modify CCFileUtils, export getFileData\r\n  remotes/origin/HEAD               -> origin/master\r\n  remotes/origin/add_build_script   d4a8c4f Merge branch \'master\' into add_build_script\r\n  remotes/origin/devel              752bb84 Merge pull request #158 from Gwill/devel\r\n  remotes/origin/devel_qt51         62208f1 update .gitignore\r\n  remotes/origin/master             53b27b8 Merge pull request #138 from tdlrobin/master\r\n  remotes/origin/zrong              2ae98d8 modify CCFileUtils, export getFileData\r\n```\r\n删除远程分支：\r\n```\r\n$ git push --delete origin devel\r\nTo git@github.com:zrong/quick-cocos2d-x.git\r\n - [deleted]         devel\r\n```\r\n重命名本地分支：\r\n```\r\ngit branch -m devel develop\r\n```\r\n推送本地分支：\r\n```\r\n$ git push origin develop\r\nCounting objects: 92, done.\r\nDelta compression using up to 4 threads.\r\nCompressing objects: 100% (48/48), done.\r\nWriting objects: 100% (58/58), 1.38 MiB, done.\r\nTotal 58 (delta 34), reused 12 (delta 5)\r\nTo git@github.com:zrong/quick-cocos2d-x.git\r\n * [new branch]      develop -> develop\r\n```\r\n然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误：\r\n```\r\n$ git push --delete origin devel\r\nremote: error: refusing to delete the current branch: refs/heads/devel\r\nTo git@github.com:zrong/quick-cocos2d-x.git\r\n ! [remote rejected] devel (deletion of the current branch prohibited)\r\nerror: failed to push some refs to \'git@github.com:zrong/quick-cocos2d-x.git\'\r\n```\r\n这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作：\r\n\r\n    进入 github 中该项目的 Settings 页面；\r\n    设置 Default Branch 为其他的分支（例如 master）；\r\n    重新执行删除远程分支命令。\r\n\r\n把本地tag推送到远程\r\n```\r\ngit push --tags\r\n```\r\n获取远程tag\r\n```\r\ngit fetch origin tag <tagname>\r\n```\r\n参考文章\r\n\r\n    https://makandracards.com/makandra/621-git-delete-a-branch-local-or-remote\r\n    http://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-both-locally-and-in-github\r\n    http://www.cnblogs.com/deepnighttwo/archive/2011/06/18/2084438.html\r\n    http://stackoverflow.com/questions/14040754/deleting-remote-master-branch-refused-due-to-being-current-branch\r\n    http://weli.iteye.com/blog/1441582\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(320,'git  删除远程分支','320',1481101020,1481101461,'<!--markdown-->git push origin :{branchName}\r\n\r\ngit push [远程名] [本地分支]:[远程分支] 语法，\r\n如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。\r\n\r\n在Git v1.7.0 之后，可以使用这种语法删除远程分支：\r\n\r\n$ git push origin --delete <branchName>\r\n$ git push origin --delete tag <tagname>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(324,'webstorm 2016 激活破解 ','@324',1481510280,1481510316,'<!--markdown-->    2016.2.2 版本的破解方式：\r\n    安装以后，打开软件会弹出一个对话框；选择“license server” 输入：http://114.215.133.70:41017\r\n    2016.2.3 版本的破解方式：\r\n    目前最新的就是2.3版本，在打开的License Activation窗口中选择“activation code”，在输入框输入下面的注册码\r\n\r\n\r\n```\r\n43B4A73YYJ-eyJsaWNlbnNlSWQiOiI0M0I0QTczWVlKIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9XSwiaGFzaCI6IjMzOTgyOTkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-keaxIkRgXPKE4BR/ZTs7s7UkP92LBxRe57HvWamu1EHVXTcV1B4f/KNQIrpOpN6dgpjig5eMVMPmo7yMPl+bmwQ8pTZaCGFuLqCHD1ngo6ywHKIQy0nR249sAUVaCl2wGJwaO4JeOh1opUx8chzSBVRZBMz0/MGyygi7duYAff9JQqfH3p/BhDTNM8eKl6z5tnneZ8ZG5bG1XvqFTqWk4FhGsEWdK7B+He44hPjBxKQl2gmZAodb6g9YxfTHhVRKQY5hQ7KPXNvh3ikerHkoaL5apgsVBZJOTDE2KdYTnGLmqxghFx6L0ofqKI6hMr48ergMyflDk6wLNGWJvYHLWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',323),(325,'算法：排行区间奖励','325',1481797980,1481799248,'<!--markdown-->```\r\n\r\n\"RankRewards\":[\r\n{\"TargetNumber\":1,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":5000}},\r\n{\"TargetNumber\":2,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":4000}},\r\n{\"TargetNumber\":3,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":3000}},\r\n{\"TargetNumber\":10,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":2000}},\r\n{\"TargetNumber\":50,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":1000}},\r\n{\"TargetNumber\":100,\"Reward\":{\"IntID\":1,\"RefID\":\"Coin\",\"Amount\":500}}\r\n]\r\n\r\nvar num = 100;\r\nvar fleetIds = [];\r\nfor (var i = 0; i < fleetLeaderBoard.length; i++) {\r\n	if (i >= num) {\r\n		break;\r\n	}\r\n	fleetIds.push(fleetLeaderBoard[i][0]);\r\n\r\n	var rewardList = [];\r\n	for (var j in rankRewards) {\r\n	    if (i < 3) {\r\n		rewardList.push({id: rankRewards[i].Reward.IntID, count: rankRewards[i].Reward.Amount});\r\n		break;\r\n	    }\r\n\r\n	    if (rankRewards[j].TargetNumber > i) {\r\n		rewardList.push({id: rankRewards[j].Reward.IntID, count: rankRewards[j].Reward.Amount});\r\n		break;\r\n	    }\r\n	}\r\n\r\n	SendRankReward(fleetLeaderBoard[i][0], rewardList);\r\n}\r\n\r\n\r\n```\r\n=====================================================================\r\n```\r\nvar revenue  = new Array([350],[450],[550],[650],[850],[1000],[1100],[1250],[1500]); \r\nvar reward	 = new Array([30],[40],[50],[100],[200],[240],[300],[400]); \r\n\r\n如果收入大于350 小于 450 那么就奖励30\r\n如果收入大于450小于550，就奖励50\r\n\r\nvar score = 500;\r\nfor(var i = 0; i < revenue.length; i++){\r\n    if(revenue[i] > score && i > 0){\r\n        alert(reward[i - 1]);\r\n        break;\r\n    } \r\n}',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(328,'redis 连接','328',1482993540,1483075759,'<!--markdown-->redis-cli -h 127.0.0.1 -p 6379 -a doraemonkart\r\nredis-cli -h 服务器地址 -p 端口号 -a 密码\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(329,'git 配置','329',1483534800,1484210240,'<!--markdown-->```\r\n vi ~/.gitconfig\r\n\r\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。\r\n\r\ngithub的SSH配置如下：\r\n\r\n一 、\r\n\r\n设置Git的user name和email：\r\n\r\n$ git config --global user.name \"xuhaiyan\"\r\n\r\n$ git config --global user.email \"haiyan.xu.vip@gmail.com\"\r\n\r\n\r\n二、生成SSH密钥过程：\r\n1.查看是否已经有了ssh密钥：cd ~/.ssh\r\n如果没有密钥则不会有此文件夹，有则备份删除\r\n2.生存密钥：\r\n\r\n    $ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”\r\n    按3个回车，密码为空。\r\n\r\n\r\n    Your identification has been saved in /home/tekkub/.ssh/id_rsa.\r\n    Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.\r\n    The key fingerprint is:\r\n    ………………\r\n\r\n\r\n最后得到了两个文件：id_rsa和id_rsa.pub\r\n\r\n\r\n3.添加密钥到ssh：ssh-add 文件名\r\n需要之前输入密码。\r\n4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。\r\n\r\n打开https://github.com/ ，登陆xuhaiyan825，然后添加ssh。\r\n\r\n\r\n5.测试：ssh git@github.com\r\n\r\n    The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.\r\n    RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.\r\n    ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell access\r\n    Connection to github.com closed.\r\n\r\n\r\n三、 开始使用github\r\n1.获取源码：\r\n\r\n$ git clone git@github.com:billyanyteen/github-services.git\r\n\r\n2.这样你的机器上就有一个repo了。\r\n3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo\r\n仓库初始化：\r\n\r\ngit init\r\n\r\n生成快照并存入项目索引：\r\n\r\ngit add\r\n\r\n文件,还有git rm,git mv等等…\r\n项目索引提交：\r\n\r\ngit commit\r\n\r\n4.协作编程：\r\n将本地repo于远程的origin的repo合并，\r\n推送本地更新到远程：\r\n\r\ngit push origin master\r\n\r\n更新远程更新到本地：\r\n\r\ngit pull origin master\r\n\r\n补充：\r\n添加远端repo：\r\n\r\n$ git remote add upstream git://github.com/pjhyett/github-services.git\r\n\r\n重命名远端repo：\r\n\r\n$ git://github.com/pjhyett/github-services.git为“upstream”\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(330,'git  私钥','330',1484209860,1484362720,'<!--markdown-->一般存储在 用户 HOME 目录下\r\n```\r\ncd                至home 目录\r\nll -a             查看隐藏目录\r\ncd .ssh    \r\n```\r\n\r\n如果出现 Permissions 0644 for ‘/root/.ssh/id_rsa’ are too open. 等错误显示了，原来只要把权限降到0600就ok了\r\n输入命令\r\nchmod 600 /root/.ssh/id_rsa\r\n然后就可以密钥登陆了',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(333,'MySQL模糊查询（like）时区分大小写 ','333',1484726460,1484726643,'<!--markdown-->![请输入图片描述][1]\r\n\r\n\r\n问题说明：通过上面的语句，你会发现MySQL的like查询是不区分大小写的，因为我的失误，把Joe写成了joe才发现了这个东东吧。但是，有时候，我们需要区分大小写的是，该怎么办呢？解决方法如下：\r\n\r\n方法一（查询时，指定区分大小写）\r\n\r\n很简单，在like的后面加个binary就可以了，适用于表的结构不易改变的情况下。大多数人发现这个问题的时候，往往表的结构是不能改变的，所以，这种方法还是很好的。\r\n\r\n![请输入图片描述][2]\r\n![请输入图片描述][3]\r\n\r\n接下来还有其他的方法，是在建表的时候，设置好区分大小的。\r\n\r\n也可以在建表时，加以标识 \r\n```\r\ncreate  table  table_name(  \r\n\r\n     a varchar (20) binary\r\n\r\n) \r\n```\r\n深入了解：\r\n\r\n首先，你要了解的是：在MySQL中，对于Column Collate其约定的命名方法如下：\r\n\r\n*_bin: 表示的是binary case sensitive collation，也就是说是区分大小写的\r\n\r\n*_cs: case sensitive collation，区分大小写\r\n\r\n*_ci: case insensitive collation，不区分大小写\r\n\r\n\r\n[参考][4]\r\n\r\n\r\n  [1]: http://images.cnitblog.com/blog/635602/201502/241442247053817.png\r\n  [2]: http://images.cnitblog.com/blog/635602/201502/241442261584573.png\r\n  [3]: http://images.cnitblog.com/blog/635602/201502/241442272529372.png\r\n  [4]: http://www.cnblogs.com/zi-xing/p/4298697.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0);
/*!40000 ALTER TABLE `typecho_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_fields`
--

DROP TABLE IF EXISTS `typecho_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_fields`
--

LOCK TABLES `typecho_fields` WRITE;
/*!40000 ALTER TABLE `typecho_fields` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_links`
--

DROP TABLE IF EXISTS `typecho_links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_links` (
  `lid` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'links表主键',
  `name` varchar(200) DEFAULT NULL COMMENT 'links名称',
  `url` varchar(200) DEFAULT NULL COMMENT 'links网址',
  `sort` varchar(200) DEFAULT NULL COMMENT 'links分类',
  `image` varchar(200) DEFAULT NULL COMMENT 'links图片',
  `description` varchar(200) DEFAULT NULL COMMENT 'links描述',
  `user` varchar(200) DEFAULT NULL COMMENT '自定义',
  `order` int(10) unsigned DEFAULT '0' COMMENT 'links排序',
  PRIMARY KEY (`lid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_links`
--

LOCK TABLES `typecho_links` WRITE;
/*!40000 ALTER TABLE `typecho_links` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_links` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_metas`
--

DROP TABLE IF EXISTS `typecho_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_metas`
--

LOCK TABLES `typecho_metas` WRITE;
/*!40000 ALTER TABLE `typecho_metas` DISABLE KEYS */;
INSERT INTO `typecho_metas` VALUES (1,'涟漪','default','category','只是一个默认分类',232,1,0),(2,'PHP','php','tag',NULL,0,0,0),(20,'算法','算法','category',NULL,1,16,0),(7,'WebStorm','WebStorm','category','WebStorm',4,3,0),(5,'Node','node','tag',NULL,0,0,0),(8,'Linux','Linux','category',NULL,22,4,0),(9,'Node','Node','category','Node',29,5,0),(10,'Git','Git','category','Git',20,6,0),(11,'JavaScript','JavaScript','category','JavaScript',60,7,0),(12,'VirtualBox','VirtualBox','category','VirtualBox',1,8,0),(13,'PHP','PHP','category','PHP',33,9,0),(14,'Mysql','Mysql','category','Mysql',16,10,0),(15,'Shell','Shell','category','Shell',22,11,0),(16,'Ubuntu','Ubuntu','category','Ubuntu',1,12,0),(17,'window','window','category','window',3,13,0),(18,'Redis','Redis','category','Redis',14,14,0),(19,'MongoDB','MongoDB','category','MongoDB',10,15,0);
/*!40000 ALTER TABLE `typecho_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_options`
--

DROP TABLE IF EXISTS `typecho_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_options`
--

LOCK TABLES `typecho_options` WRITE;
/*!40000 ALTER TABLE `typecho_options` DISABLE KEYS */;
INSERT INTO `typecho_options` VALUES ('theme',0,'next'),('theme:next',0,'a:7:{s:9:\"next_name\";s:0:\"\";s:13:\"next_gravatar\";s:0:\"\";s:9:\"next_tips\";s:36:\"一个高端大气上档次的网站\";s:8:\"next_cdn\";s:23:\"http://blog.hoyins.com/\";s:7:\"sidebar\";i:1;s:13:\"next_comments\";s:0:\"\";s:11:\"search_form\";a:3:{i:0;s:10:\"ShowSearch\";i:1;s:8:\"ShowFeed\";i:2;s:6:\"Motion\";}}'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.0/14.10.10'),('title',0,'Hoyin‘s Blog'),('description',0,'◢╳╲ .巅峰诞生一群虚伪的拥护者.黄昏见证一批真信徒...'),('keywords',0,'typecho,php,blog'),('rewrite',0,'0'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'1'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:2:{s:9:\"activated\";a:1:{s:5:\"Links\";a:1:{s:7:\"handles\";a:3:{s:34:\"Widget_Abstract_Contents:contentEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}s:34:\"Widget_Abstract_Contents:excerptEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}s:34:\"Widget_Abstract_Comments:contentEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}}}}s:7:\"handles\";a:3:{s:34:\"Widget_Abstract_Contents:contentEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}s:34:\"Widget_Abstract_Contents:excerptEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}s:34:\"Widget_Abstract_Comments:contentEx\";a:1:{i:0;a:2:{i:0;s:12:\"Links_Plugin\";i:1;s:5:\"parse\";}}}}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'http://www.hoyins.com'),('defaultCategory',0,'1'),('allowRegister',0,'0'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'5'),('postsListSize',0,'10'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'1'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:26:{i:0;a:25:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:26:\"|^/archives/([0-9]+)[/]?$|\";s:6:\"format\";s:13:\"/archives/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}}'),('actionTable',0,'a:1:{s:10:\"links-edit\";s:12:\"Links_Action\";}'),('panelTable',0,'a:2:{s:5:\"child\";a:1:{i:3;a:1:{i:0;a:6:{i:0;s:12:\"友情链接\";i:1;s:18:\"管理友情链接\";i:2;s:44:\"extending.php?panel=Links%2Fmanage-links.php\";i:3;s:13:\"administrator\";i:4;b:0;i:5;s:0:\"\";}}}s:4:\"file\";a:1:{i:0;s:24:\"Links%2Fmanage-links.php\";}}'),('attachmentTypes',0,'@image@'),('secret',0,'ItkdGNS9vo7@hcFZ@DU9Gw!uIzpOVKbj'),('autoSave',1,'1'),('markdown',1,'1'),('defaultAllowComment',1,'1'),('defaultAllowPing',1,'1'),('defaultAllowFeed',1,'1');
/*!40000 ALTER TABLE `typecho_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_relationships`
--

DROP TABLE IF EXISTS `typecho_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_relationships`
--

LOCK TABLES `typecho_relationships` WRITE;
/*!40000 ALTER TABLE `typecho_relationships` DISABLE KEYS */;
INSERT INTO `typecho_relationships` VALUES (9,1),(12,1),(13,1),(14,1),(14,2),(14,13),(16,1),(16,13),(18,1),(18,13),(20,1),(20,13),(22,1),(22,13),(23,1),(23,13),(24,1),(24,13),(25,1),(25,13),(26,1),(26,13),(27,1),(27,13),(28,1),(28,13),(29,1),(29,13),(30,1),(30,13),(31,1),(31,13),(32,1),(32,13),(33,1),(33,13),(34,1),(34,13),(35,1),(35,13),(36,1),(36,13),(37,1),(37,13),(39,1),(39,13),(40,1),(40,13),(41,1),(41,13),(42,1),(42,13),(43,1),(43,13),(44,1),(44,13),(45,1),(45,13),(46,1),(46,13),(47,1),(47,14),(48,1),(48,14),(49,1),(49,14),(50,1),(50,14),(51,1),(51,14),(52,1),(52,8),(53,1),(53,8),(54,1),(54,8),(56,1),(56,8),(57,1),(57,8),(59,1),(59,8),(60,1),(60,15),(61,1),(61,15),(62,1),(62,15),(63,1),(63,15),(66,1),(66,15),(69,1),(69,8),(70,1),(70,15),(73,1),(73,15),(74,1),(74,15),(76,1),(76,15),(78,1),(78,15),(79,1),(79,15),(80,1),(80,15),(81,1),(81,15),(83,1),(83,15),(87,1),(87,15),(88,1),(88,15),(89,1),(89,15),(91,1),(91,15),(92,1),(92,15),(93,1),(93,15),(94,1),(94,15),(96,1),(96,15),(97,1),(97,8),(98,1),(98,8),(100,1),(100,8),(102,1),(102,8),(102,9),(102,13),(102,14),(102,18),(103,1),(103,14),(104,1),(104,13),(105,1),(105,13),(106,1),(106,14),(108,1),(108,13),(110,1),(110,13),(111,1),(111,13),(113,1),(113,14),(114,1),(114,9),(115,1),(115,11),(117,1),(117,11),(118,1),(118,11),(119,1),(119,11),(120,1),(120,11),(121,1),(121,11),(122,1),(122,11),(123,1),(123,11),(124,1),(124,11),(125,1),(125,11),(126,1),(126,11),(127,1),(127,11),(128,1),(128,11),(129,1),(129,11),(130,1),(130,11),(131,1),(131,11),(132,1),(132,11),(133,1),(133,11),(135,1),(135,11),(138,1),(138,11),(139,1),(139,11),(140,1),(140,11),(143,1),(143,11),(144,1),(144,11),(145,1),(145,11),(146,1),(146,11),(147,1),(147,11),(148,1),(148,11),(149,1),(149,11),(150,1),(150,11),(151,1),(151,11),(152,1),(152,11),(153,1),(153,11),(154,1),(154,11),(155,1),(155,11),(156,1),(156,11),(157,1),(157,11),(158,1),(158,11),(159,1),(159,11),(160,1),(160,11),(161,1),(161,11),(162,1),(162,11),(163,1),(163,11),(164,1),(164,11),(166,1),(166,11),(167,1),(167,11),(168,1),(168,11),(169,1),(169,11),(170,1),(170,11),(171,1),(171,11),(172,1),(172,11),(173,1),(173,11),(174,1),(174,11),(175,1),(175,11),(176,1),(176,11),(177,1),(177,11),(179,1),(179,11),(180,1),(180,11),(181,1),(181,11),(182,1),(182,11),(183,1),(183,9),(184,1),(184,9),(185,1),(185,9),(186,1),(186,9),(189,1),(189,9),(191,1),(191,9),(192,1),(192,9),(194,1),(194,9),(195,1),(195,9),(196,1),(196,9),(197,1),(197,9),(198,1),(198,9),(199,1),(199,9),(200,1),(200,9),(201,1),(201,9),(202,1),(202,9),(203,1),(203,9),(204,1),(204,9),(206,1),(206,9),(207,1),(207,9),(208,1),(208,9),(209,1),(209,9),(210,1),(210,9),(211,1),(211,9),(212,1),(212,9),(214,1),(214,9),(217,1),(217,18),(218,1),(218,18),(219,1),(219,18),(220,1),(220,18),(221,1),(221,14),(222,1),(222,19),(224,1),(224,19),(225,1),(225,19),(226,1),(226,19),(227,1),(227,19),(228,1),(228,19),(229,1),(229,19),(230,1),(230,19),(232,1),(232,19),(234,1),(234,19),(235,1),(235,8),(237,1),(237,10),(239,1),(239,10),(240,1),(240,18),(241,1),(241,18),(242,1),(242,18),(244,1),(244,18),(246,1),(246,18),(247,1),(247,18),(249,1),(249,18),(251,1),(251,8),(252,1),(252,8),(253,1),(253,8),(257,1),(257,14),(259,1),(259,8),(261,1),(261,17),(262,1),(262,8),(265,1),(265,14),(266,1),(266,14),(267,1),(267,14),(269,1),(269,14),(271,1),(271,10),(273,1),(273,7),(275,1),(275,7),(277,1),(277,8),(283,1),(283,8),(284,1),(284,8),(285,1),(285,17),(286,1),(286,10),(287,1),(287,10),(289,1),(289,10),(291,1),(291,10),(293,1),(293,10),(295,1),(295,10),(296,1),(296,10),(297,1),(297,10),(298,1),(298,10),(299,1),(299,10),(300,1),(300,10),(301,1),(301,16),(303,1),(303,12),(305,1),(305,10),(307,1),(307,9),(309,1),(309,7),(316,1),(316,7),(317,1),(317,8),(318,1),(318,8),(318,17),(319,18),(320,1),(320,10),(321,1),(321,10),(322,1),(322,10),(323,1),(323,7),(324,1),(324,7),(325,1),(325,20),(328,1),(328,18),(329,1),(329,10),(330,1),(330,10),(333,1),(333,14);
/*!40000 ALTER TABLE `typecho_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_users`
--

DROP TABLE IF EXISTS `typecho_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_users`
--

LOCK TABLES `typecho_users` WRITE;
/*!40000 ALTER TABLE `typecho_users` DISABLE KEYS */;
INSERT INTO `typecho_users` VALUES (1,'hoyin','$P$BBckhYE4RUJFAgy.KSLlBDTWACnoGY1','499090583@qq.com','http://www.hoyins.com','hoyin',1461166575,1484737994,1481869303,'administrator','3da727c90d74375e2e7ad0f0b10d223b');
/*!40000 ALTER TABLE `typecho_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-02-06  3:42:32
